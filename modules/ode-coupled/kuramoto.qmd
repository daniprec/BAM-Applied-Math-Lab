---
title: "Kuramoto Model"
subtitle: "Coupled Oscillators"
format: html
---

The Kuramoto model describes a population of weakly coupled oscillators. Each oscillator has a phase $\theta_i$ and a natural frequency $\omega_i$.

To visualize the dynamics, imagine points moving on the unit circle. Synchronization corresponds to points clustering around a common phase.

```{python}
#| label: fig-kuramoto-circle
#| fig-cap: 'Kuramoto model: oscillators on the unit circle and the order-parameter vector.'
#| fig-width: 6
#| fig-height: 6
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

from amlab.odes_coupled.kuramoto import initialize_oscillators, kuramoto_order_parameter

num_oscillators = 100
theta, omega = initialize_oscillators(num_oscillators, distribution="normal", scale_omega=0.5, seed=1)

x = np.cos(theta)
y = np.sin(theta)

r, phi, rcosphi, rsinphi = kuramoto_order_parameter(theta)

fig, ax = plt.subplots(figsize=(6, 6))
ax.set_title("Kuramoto Model")
ax.set_xlabel("Cos(theta)")
ax.set_ylabel("Sin(theta)")
ax.set_xlim(-1.1, 1.1)
ax.set_ylim(-1.1, 1.1)
ax.set_aspect("equal")
ax.grid(True)

circle = plt.Circle((0, 0), 1, color="lightgray", fill=False)
ax.add_artist(circle)
ax.scatter(x, y, s=50, color="blue", alpha=0.5)
ax.plot([0, rcosphi], [0, rsinphi], color="red", linewidth=2)
ax.plot([rcosphi], [rsinphi], "ro", markersize=6)
plt.show()
plt.close()
```

## Initialize oscillators

The phases $\theta_i$ are sampled uniformly on $[0, 2\pi]$ and the natural frequencies $\omega_i$ from a normal distribution with standard deviation $\sigma$.

```python
def initialize_oscillators(num_oscillators: int, sigma: float = 1.0):
    # Assign a random initial phase to each oscillator
    theta =  # draw from uniform distribution

    # Assign a random natural frequency to each oscillator
    omega =  # draw from normal distribution
    return theta, omega
```

::: {.callout-tip collapse="true"}
## Hint: Initialization (click to expand)

```python
def initialize_oscillators(num_oscillators: int, sigma: float = 1.0):
    theta = np.random.uniform(0, 2 * np.pi, num_oscillators)
    omega = np.random.normal(0, sigma, num_oscillators)
    return theta, omega
```
:::

## Define the ODE

We will implement the mean-field form. Remember: `solve_ivp()` requires the time argument even if it is not used.

```python
def kuramoto_ode(t, theta, omega, coupling_strength=1.0):
    theta = np.mod(theta, 2 * np.pi)

    # TODO: compute the order parameter (r, phi)
    # TODO: implement mean-field coupling
    return dtheta_dt
```

::: {.callout-tip collapse="true"}
## Hint: Mean-field ODE (click to expand)

```python
def kuramoto_ode(t, theta, omega, coupling_strength=1.0):
    theta = np.mod(theta, 2 * np.pi)
    order_param = np.mean(np.exp(1j * theta))
    r = np.abs(order_param)
    phi = np.angle(order_param)
    dtheta_dt = omega + coupling_strength * r * np.sin(phi - theta)
    return dtheta_dt
```
:::

## Animate the phases

Follow the same animation loop used in the template. The update function solves one small IVP and updates the scatter plot.

```python
from scipy.integrate import solve_ivp
import matplotlib.animation as animation

# Parameters
coupling_strength = 1.0
num_oscillators = 100
sigma = 1.0
dt = 0.01

# Initialize oscillators
theta, omega = initialize_oscillators(num_oscillators, sigma=sigma)

# Figure setup
fig, ax_phase = plt.subplots(1, 1, figsize=(12, 6))
ax_phase.set_title("Kuramoto Model")
ax_phase.set_xlabel("Cos(theta)")
ax_phase.set_ylabel("Sin(theta)")
ax_phase.set_xlim(-1.1, 1.1)
ax_phase.set_ylim(-1.1, 1.1)
ax_phase.set_aspect("equal")
ax_phase.grid(True)

circle = plt.Circle((0, 0), 1, color="lightgray", fill=False)
ax_phase.add_artist(circle)
scatter = ax_phase.scatter([], [], s=50, color="blue", alpha=0.5)

# Animation update

def update(frame: int):
    global theta
    sol = solve_ivp(kuramoto_ode, (0, dt), theta, args=(omega, coupling_strength))
    theta = sol.y[..., -1]
    theta = np.mod(theta, 2 * np.pi)

    x = np.cos(theta)
    y = np.sin(theta)
    scatter.set_offsets(np.vstack((x, y)).T)
    return [scatter]

ani = animation.FuncAnimation(fig, update, blit=True, interval=1)
plt.tight_layout()
plt.show()
```

If you get stuck, see the mini template in [amlab/odes_coupled/kuramoto_template_mini.py](../../amlab/odes_coupled/kuramoto_template_mini.py).
