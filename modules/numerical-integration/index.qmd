---
title: "Numerical Integration"
subtitle: "Solving ODEs with SciPy"
format:
  html:
    toc: true
    number-sections: true
---

# Introduction

Numerical integration is fundamental for solving ordinary differential equations (ODEs) that don't have analytical solutions. In this module, you'll learn how to:

- Formulate ODEs in Python
- Use SciPy's `solve_ivp` to numerically integrate ODEs
- Visualize solutions and explore parameter spaces
- Apply these techniques to real-world models

# The Initial Value Problem

An **initial value problem (IVP)** consists of:

$$\frac{dy}{dt} = f(t, y), \quad y(t_0) = y_0$$

Where:
- $f(t, y)$ is the rate of change function
- $y_0$ is the initial condition at time $t_0$

# SciPy's `solve_ivp`

The `scipy.integrate.solve_ivp` function is the standard tool for solving ODEs in Python:

```python
from scipy.integrate import solve_ivp

def dydt(t, y):
    # Define your ODE system
    return # derivative
    
sol = solve_ivp(dydt, t_span=(0, 10), y0=[initial_condition])
```

## Key Parameters

- `fun`: The function defining the ODE system
- `t_span`: Tuple `(t_start, t_end)` for integration interval
- `y0`: Initial conditions (array)
- `method`: Integration method (default: 'RK45')
- `t_eval`: Specific time points to return solution

# Example: Exponential Growth

$$\frac{dy}{dt} = ky, \quad y(0) = y_0$$

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

def exponential_growth(t, y, k):
    return k * y

k = 0.5
y0 = [1.0]
t_span = (0, 10)
t_eval = np.linspace(0, 10, 100)

sol = solve_ivp(exponential_growth, t_span, y0,
                args=(k,), t_eval=t_eval)

plt.plot(sol.t, sol.y[0])
plt.xlabel('Time')
plt.ylabel('y(t)')
plt.title('Exponential Growth')
plt.show()
```

# Systems of ODEs

For multiple coupled equations, return a list or array of derivatives:

```python
def sir_model(t, y, beta, gamma):
    S, I, R = y
    N = S + I + R
    
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    
    return [dSdt, dIdt, dRdt]
```

# Best Practices

1. **Always check convergence**: Plot solutions at different tolerances
2. **Use appropriate methods**: `'RK45'` (default) works well for most problems
3. **Vectorize when possible**: Makes code faster and cleaner
4. **Document parameters**: Keep track of units and meanings
5. **Validate against known solutions**: Test your implementation

# Next Steps

Apply these techniques to the classical models in Session 1:
- SIR epidemiological model
- Spruce budworm population dynamics
- Michaelisâ€“Menten enzyme kinetics

# Resources

- [SciPy solve_ivp documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html)
- [Python for ODEs tutorial](https://python-numerical-methods.berkeley.edu/notebooks/chapter22.00-ODE-Initial-Value-Problems.html)
