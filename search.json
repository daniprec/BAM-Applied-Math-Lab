[
  {
    "objectID": "modules/ode-1d/spruce-budworm.html",
    "href": "modules/ode-1d/spruce-budworm.html",
    "title": "Spruce Budworm Model",
    "section": "",
    "text": "The spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\]\nwhere:\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-implementing-ode-function",
    "href": "modules/ode-1d/spruce-budworm.html#sec-implementing-ode-function",
    "title": "Spruce Budworm Model",
    "section": "Implementing the ODE Function",
    "text": "Implementing the ODE Function\nCreate a Python function that implements the spruce budworm differential equation. The function should follow the signature required by scipy.integrate.solve_ivp.\n\nFunction name: spruce_budworm\nParameters: t (time), x (population), r (growth rate), k (carrying capacity)\nReturn: The rate of change \\(\\frac{dx}{dt}\\).\nInclude appropriate docstring documentation.\n\nHere is a template to get you started:\ndef spruce_budworm(t: float, x: float, r: float = 0.5, k: float = 10) -&gt; float:\n    \"\"\"Docstring and type hints\"\"\"\n    # Your implementation here\n    dxdt = # fill in the equation\n    return dxdt\nWhy do we need t as an input? Although the equation does not explicitly depend on time, solve_ivp requires the function to accept time as the first argument.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-phase-portrait",
    "href": "modules/ode-1d/spruce-budworm.html#sec-phase-portrait",
    "title": "Spruce Budworm Model",
    "section": "Phase Portrait Visualization",
    "text": "Phase Portrait Visualization\nCreate a function that plots the rate of change \\(\\frac{dx}{dt}\\) as a function of the population \\(x\\). This phase portrait will help us visualize the equilibrium points and their stability.\n\nFunction name: plot_spruce_budworm_rate\nParameters: x_t (current population), r, k\nUse matplotlib for plotting\nPlot \\(\\frac{dx}{dt}\\) vs \\(x\\) for \\(x \\in [0, k]\\)\nIdentify and mark equilibrium points (where \\(\\frac{dx}{dt} = 0\\))\nColor-code equilibrium points:\n\nBlue circles for stable equilibria (where \\(\\frac{dx}{dt}\\) crosses zero from above).\nRed circles for unstable equilibria (where \\(\\frac{dx}{dt}\\) crosses zero from below).\n\nAdd a horizontal line at \\(y = 0\\) to indicate equilibria (null rate of change).\nLabel axes and add a title.\nMark the current population \\(x_t\\) with a vertical dashed line.\n\nFigure 1 shows an example of the expected output.\n\n\n\n\n\n\n\n\nFigure 1: Phase portrait (rate plot) of the spruce budworm model. Stable equilibria are marked in blue, unstable equilibria in red, and the current population \\(x_t\\) is shown as a green dashed line.\n\n\n\n\n\nHere are some hints to help you implement this function:\n\nYou can use np.linspace to create an array of \\(x\\) values.\nTo find zero crossings: you can look for sign changes combining np.diff and np.sign.\nStability: a fixed point is stable if \\(\\frac{dx}{dt}\\) decreases as you pass through it.\n\nReview the following definitions for clarity:\n\nEquilibrium point: A value \\(x^*\\) where \\(\\frac{dx}{dt} = 0\\).\nStable equilibrium: Small perturbations decay back to \\(x^*\\).\nUnstable equilibrium: Small perturbations grow away from \\(x^*\\).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-numerical-integration",
    "href": "modules/ode-1d/spruce-budworm.html#sec-numerical-integration",
    "title": "Spruce Budworm Model",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nCreate a function that evolves the system forward in time using numerical integration. This function should solve the ODE and append the results to existing time and population arrays.\n\nFunction name: evolve_spruce_budworm\nInputs: t (time array), x (population array), r, k, t_eval (duration to evolve).\nUse scipy.integrate.solve_ivp with the RK45 method.\nStart from the last values in the input arrays.\nConcatenate new results to the input arrays.\nEnsure population never goes negative (use np.clip).\nReturn updated t and x arrays.\n\nHere is a template to get you started:\ndef evolve_spruce_budworm(t: np.ndarray, x: np.ndarray, ...):\n    \"\"\"Don't forget the docstring and type hints\"\"\"\n    # Define time span from last time point\n    t_span = (t[-1], t[-1] + t_eval)\n\n    # Create evaluation points, t_eval\n    # This indicates where we want the solution evaluated\n    # and should be distributed along the time span\n    # Hint: use np.linspace\n\n    # Solve the ODE\n    solution = solve_ivp(\n        fun=spruce_budworm,\n        t_span=t_span,\n        y0=[x[-1]],\n        t_eval=t_eval,\n        args=(r, k),\n        method=\"RK45\",\n    )\n    t_new = solution.t\n    x_new = solution.y[0]\n\n    # Concatenate results - Hint: use np.concatenate\n    # Ensure non-negative population - Hint: use np.clip\n\n    return t, x\nSome important notes:\n\nThe args parameter in solve_ivp passes additional arguments to your ODE function. You can see how we use it in the example above.\nInitial condition should be [x[-1]] (last population value).\nUse method=\"RK45\" for adaptive step-size Runge-Kutta integration.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-time-series-visualization",
    "href": "modules/ode-1d/spruce-budworm.html#sec-time-series-visualization",
    "title": "Spruce Budworm Model",
    "section": "Time Series Visualization",
    "text": "Time Series Visualization\nCreate a function to plot the population dynamics over time. This visualization shows how the population evolves from the initial condition.\n\nFunction name: plot_spruce_budworm\nParameters: t (time array), x (population array).\nPlot time on the x-axis and population on the y-axis.\nUse green color for the trajectory.\nEnsure y-axis starts at 0 (populations cannot be negative).\nInclude grid, labels, and title.\nReturn the figure and axes objects.\n\nSee Figure 2 for an example output.\n\n\n\n\n\n\n\n\nFigure 2: Time series of the spruce budworm population generated with SciPy’s RK45 solver.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-streamlit-application",
    "href": "modules/ode-1d/spruce-budworm.html#sec-streamlit-application",
    "title": "Spruce Budworm Model",
    "section": "Building the Streamlit Application",
    "text": "Building the Streamlit Application\nNow that you have all the components, create an interactive Streamlit application that allows users to explore the spruce budworm model. This will enable real-time parameter adjustment and visualization.\nWhile all the previous code could be done in Google Colab, Streamlit has to be built on your local machine. Follow the instructions in the README.md file in the repository to set up your environment.\nDesign a script, name it spruce_budworm_app.py. You will find a suggested layout below. This script will use the functions you implemented in sections Section 1 through Section 4. You can either import them from a separate module (another script you created) or paste the function definitions directly into the script. For best practices, consider creating a module (e.g., spruce_budworm_model.py) and importing the functions.\nTo test your app, run the following command in your terminal:\nstreamlit run spruce_budworm_app.py\n\nSidebar Controls\nCreate sliders for:\n\nGrowth rate \\(r\\) (range: 0.0 to 1.0, default 0.5).\nCarrying capacity \\(k\\) (range: 0.1 to 10.0, default 10.0).\nInitial population: set automatically to \\(k/10\\) (the app uses \\(x_0 = k/10\\) by default).\nTime slider for evolution (range: 1 to 100, default 10).\n\n\n\nInteractive Features\n\nDisplay the differential equation with current parameter values.\nShow the phase portrait (rate of change plot), using your function from section Section 2.\nShow the time series evolution, using your function from section Section 4.\nAdd a button to “Evolve Forward” that continues the simulation, updating the plots.\nUse st.session_state to maintain simulation state between button clicks. You will need to store the time and population arrays in the session state, otherwise they will reset on each interaction.\n\n\n\nLayout Structure\nimport streamlit as st\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom your_module import (\n    spruce_budworm,\n    plot_spruce_budworm_rate,\n    evolve_spruce_budworm,\n    plot_spruce_budworm,\n)  # Or paste your functions here\n\nst.title(\"Spruce Budworm Population Dynamics\")\n\n# Sidebar parameters (as in the app)\nr = st.sidebar.slider(\"Intrinsic growth rate (r)\", 0.0, 1.0, 0.5)\nk = st.sidebar.slider(\"Carrying capacity (k)\", 0.1, 10.0, 10.0)\n\n# The app sets the initial population to k/10 by default\nx0 = k / 10\n\n# Initialize session state\nif (\"sbw_x\" not in st.session_state):\n    st.session_state[\"sbw_t\"] = np.array([0])\n    st.session_state[\"sbw_x\"] = np.array([x0])\n\n# Time slider and control buttons\nt_eval = st.sidebar.slider(\"Time\", 1, 100, 10)\nbutton = st.sidebar.button(\"Evolve\")\n\n# Retrieve session data\nt = st.session_state[\"sbw_t\"]\nx = st.session_state[\"sbw_x\"]\n\n# Evolve if requested\nif button:\n    t, x = evolve_spruce_budworm(t, x, r=r, k=k, t_eval=t_eval)\n    st.session_state[\"sbw_t\"] = t\n    st.session_state[\"sbw_x\"] = x\n\n# Plot phase portrait and time series\nfig1, ax1 = plot_spruce_budworm_rate(x[-1], r=r, k=k)\nst.pyplot(fig1)\nfig2, ax2 = plot_spruce_budworm(t, x)\nst.pyplot(fig2)\n\n\nAdvanced Features (Optional)\n\nAdd a reset button to restart the simulation.\nShow multiple trajectories with different initial conditions.\nAdd animation of the population dynamics.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-exploration-questions",
    "href": "modules/ode-1d/spruce-budworm.html#sec-exploration-questions",
    "title": "Spruce Budworm Model",
    "section": "Exploration Questions",
    "text": "Exploration Questions\nOnce your simulation is working, explore the following questions:\n\nMultiple Equilibria: For \\(r = 0.5\\) and \\(k = 10\\), how many equilibrium points exist? Which are stable?\nBistability: Start with two different initial conditions (e.g., \\(x_0 = 1\\) and \\(x_0 = 8\\)). Do they converge to the same equilibrium?\nHysteresis: Slowly increase the carrying capacity \\(k\\) from 5 to 15. Then slowly decrease it back to 5. Does the population return to the same state? If you are interested in this concept, see section Section 6.1.\nOutbreak Dynamics: What happens if you start with a small population (\\(x_0 &lt; 2\\)) and the carrying capacity is large (\\(k &gt; 10\\))?\nCritical Slowing Down: When the population is near an unstable equilibrium, how long does it take to move away? Compare this to the rate of change far from equilibrium.\nParameter Space: Create a diagram showing the number of equilibria as a function of \\(r\\) and \\(k\\). Where do bifurcations occur?\n\n\nSlow-Fast Dynamics\nThe carrying capacity \\(k\\) can be interpreted as a slowly varying parameter in real ecosystems (e.g., due to seasonal changes or forest management). You can simulate this by gradually changing \\(k\\) over time in your app. This can lead to hysteresis effects, where the population does not return to its original state after \\(k\\) is restored. Experiment with this by modifying your Streamlit app to allow \\(k\\) to vary over time.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-mathematical-background",
    "href": "modules/ode-1d/spruce-budworm.html#sec-mathematical-background",
    "title": "Spruce Budworm Model",
    "section": "Mathematical Background",
    "text": "Mathematical Background\nIn this section I provide some additional mathematical context for the spruce budworm model. Play with your simulation to see these concepts in action!\n\nEquilibrium Analysis\nEquilibrium points satisfy:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) - \\frac{(x^*)^2}{1 + (x^*)^2} = 0\n\\]\nThis can be rewritten as:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) = \\frac{(x^*)^2}{1 + (x^*)^2}\n\\]\nThe left side represents birth rate (logistic growth), and the right side represents predation rate. Equilibria occur where these balance.\n\n\nStability Analysis\nThe stability of an equilibrium \\(x^*\\) is determined by the sign of the derivative:\n\\[\n\\frac{d}{dx}\\left(\\frac{dx}{dt}\\right)\\bigg|_{x=x^*}\n\\]\nIf this derivative is:\n\nNegative: the equilibrium is stable (attracting).\nPositive: the equilibrium is unstable (repelling).\nZero: higher-order analysis is needed.\n\n\n\nEcological Interpretation\n\nLow equilibrium: Few budworms, controlled by predation.\nHigh equilibrium: Outbreak state, budworms overwhelm predators.\nMiddle equilibrium: Usually unstable, separates the two basins of attraction.\nHysteresis: The system can “jump” between states depending on history.\n\nThis behavior explains why spruce budworm populations can suddenly explode from low levels to outbreak proportions, and why simply reducing the outbreak may not return the forest to a healthy state.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#resources",
    "href": "modules/ode-1d/spruce-budworm.html#resources",
    "title": "Spruce Budworm Model",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 3.7) for theoretical background on the spruce budworm model.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nStreamlit documentation: https://docs.streamlit.io\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/sessions/s01_odes_1d",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html",
    "href": "modules/ode-1d/sir.html",
    "title": "SIR Epidemic Model",
    "section": "",
    "text": "The SIR model is a classical compartmental model in epidemiology. It splits the population into:\nand describes how individuals move between these compartments over time.\nWe will use the normalized SIR model (fractions of the population, so \\(S+I+R=1\\)):\n\\[\n\\begin{aligned}\n\\dot S &= -\\beta SI,\\\\\n\\dot I &= \\beta SI - \\gamma I,\\\\\n\\dot R &= \\gamma I.\n\\end{aligned}\n\\]",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-reference",
    "href": "modules/ode-1d/sir.html#sec-reference",
    "title": "SIR Epidemic Model",
    "section": "Reference Implementation",
    "text": "Reference Implementation\nA working implementation is provided in:\n\nsessions/s01_odes_1d/sir_model.py\n\nThe model function is sir_model(t, y, beta, gamma) and the plotting helper is plot_sir_model(...).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-render-figure",
    "href": "modules/ode-1d/sir.html#sec-render-figure",
    "title": "SIR Epidemic Model",
    "section": "Render-time Figure",
    "text": "Render-time Figure\nThe figure below is generated at render-time from the reference script.\n\n\n\n\n\n\n\n\nFigure 1: SIR dynamics for default parameters.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-exploration",
    "href": "modules/ode-1d/sir.html#sec-exploration",
    "title": "SIR Epidemic Model",
    "section": "Exploration",
    "text": "Exploration\n\nIncrease \\(\\beta\\) while keeping \\(\\gamma\\) fixed. What happens to the peak of \\(I(t)\\)?\nIncrease \\(\\gamma\\) while keeping \\(\\beta\\) fixed. Does the epidemic end sooner?\nTry different initial infected fractions \\(I(0)\\). Do you always see an outbreak?",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-run-locally",
    "href": "modules/ode-1d/sir.html#sec-run-locally",
    "title": "SIR Epidemic Model",
    "section": "Run Locally",
    "text": "Run Locally\nTo run the standalone script and show the plot:\npython sessions/s01_odes_1d/sir_model.py",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/assignment.html",
    "href": "modules/ode-1d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Implement the complete Streamlit application for the Spruce Budworm model as described here, following the sections from Implementing the ODE Function through Building the Streamlit Application. Ensure that all functions are correctly defined and integrated into the app. Test the application thoroughly to confirm that it behaves as expected.\nAnswer at least three of the exploration questions from Exploration Questions and document your findings in a brief report (1-2 pages). You are encouraged to use LaTeX here. Include graphs demonstrating different behaviors observed during your exploration.\nIf you want to go the extra mile, here are some additional challenges you can tackle:",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-1d/assignment.html#tips-for-success",
    "href": "modules/ode-1d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Get Implementing the ODE Function working first, then build up.\nTest incrementally: Verify each function works before moving to the next.\nUse the reference: The provided code (and additional documentation) is there to help you understand the structure.\nExperiment: Try different parameter values and see what happens.\nCollaborate: Discuss with your teammates, divide the work if needed. You can also work separately and then compare your implementations.\nAsk questions: If you’re stuck, ask for help!\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html",
    "href": "modules/pde-1d/turing-instability.html",
    "title": "Turing Instability",
    "section": "",
    "text": "Turing instability explains when a uniform steady state becomes unstable to spatial perturbations, leading to patterns. We analyze it for the Gierer-Meinhardt system by checking conditions on the Jacobian and diffusion ratio.\nFigure 1: Turing space for the Gierer-Meinhardt model (a vs d).",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#conditions",
    "href": "modules/pde-1d/turing-instability.html#conditions",
    "title": "Turing Instability",
    "section": "Conditions",
    "text": "Conditions\nLet the Jacobian at the fixed point be\n\\[J=\\begin{pmatrix} f_u & f_v \\\\ g_u & g_v \\end{pmatrix}.\\]\nA common set of conditions for Turing instability is:\n\\[\n\\begin{aligned}\n&f_u + g_v &lt; 0, \\\\\n&f_u g_v - f_v g_u &gt; 0, \\\\\n&g_v + d f_u &gt; 2\\sqrt{d\\,(f_u g_v - f_v g_u)}.\n\\end{aligned}\n\\]",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#exercise-implement-a-turing-test",
    "href": "modules/pde-1d/turing-instability.html#exercise-implement-a-turing-test",
    "title": "Turing Instability",
    "section": "Exercise: Implement a Turing test",
    "text": "Exercise: Implement a Turing test\nCreate a function that returns True if all conditions are satisfied. In the reference script the Jacobian entries are hard-coded at the fixed point.\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    # TODO: compute fu, fv, gu, gv at the fixed point\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    # TODO: implement the three conditions\n    return cond1 & cond2 & cond3\n\n\n\n\n\n\nHint: Turing instability functions (click to expand)\n\n\n\n\n\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    fu = 2 * b / (a + 1) - b\n    fv = -((b / (a + 1)) ** 2)\n    gu = 2 * (a + 1) / b\n    gv = -1.0\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    nabla = fu * gv - fv * gu\n    cond1 = (fu + gv) &lt; 0\n    cond2 = nabla &gt; 0\n    cond3 = (gv + d * fu) &gt; (2 * np.sqrt(d) * np.sqrt(nabla))\n    return cond1 & cond2 & cond3",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#turing-space-diagram",
    "href": "modules/pde-1d/turing-instability.html#turing-space-diagram",
    "title": "Turing Instability",
    "section": "Turing Space Diagram",
    "text": "Turing Space Diagram\nPlot the region of \\((a, d)\\) where the instability holds.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\narr_a = np.linspace(0, 1, 1000)\narr_d = np.linspace(0, 100, 1000)\nmesh_a, mesh_d = np.meshgrid(arr_a, arr_d)\nmask_turing = is_turing_instability(mesh_a, b, mesh_d)\n\nfig, ax = plt.subplots(figsize=(6, 4))\nax.contourf(mesh_a, mesh_d, mask_turing)\nax.set_xlabel(\"a\")\nax.set_ylabel(\"d\")\nax.set_title(\"Turing Space\")\nEnsure your function works with arrays.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#unstable-spatial-modes",
    "href": "modules/pde-1d/turing-instability.html#unstable-spatial-modes",
    "title": "Turing Instability",
    "section": "Unstable Spatial Modes",
    "text": "Unstable Spatial Modes\nThe temporal eigenvalues for spatial mode \\(\\lambda_n\\) are the eigenvalues of\n\\[A_n = J - \\lambda_n \\;\\mathrm{diag}(1, d).\\]\nYou can scan modes to find which ones are unstable:\nimport numpy as np\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length=40.0, num_modes=10):\n    # TODO: build Jacobian and scan spatial modes\n    return unstable_modes\n\n\n\n\n\n\nHint: Spatial mode scan (click to expand)\n\n\n\n\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length=40.0, num_modes=10):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    jac = np.array([[fu, fv], [gu, gv]])\n    n_values = np.arange(num_modes)\n    max_eigs = np.zeros(num_modes)\n\n    for n in n_values:\n        lambda_n = (n * np.pi / length) ** 2\n        a_n = jac - lambda_n * np.diag([1, d])\n        sigma1, sigma2 = np.linalg.eigvals(a_n)\n        max_eigs[n] = max(sigma1.real, sigma2.real)\n\n    sorted_indices = np.argsort(max_eigs)[::-1]\n    unstable_modes = sorted_indices[max_eigs[sorted_indices] &gt; 0]\n    return unstable_modes",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#interaction-extension",
    "href": "modules/pde-1d/turing-instability.html#interaction-extension",
    "title": "Turing Instability",
    "section": "Interaction Extension",
    "text": "Interaction Extension\nMake the plot interactive: clicking on the Turing diagram updates \\((a, d)\\) and restarts the animation of \\(v(x)\\).\nfrom matplotlib.backend_bases import MouseEvent\n\ndef mouse_click(event: MouseEvent):\n    if event.inaxes == ax_turing:\n        a = event.xdata\n        d = event.ydata\n        # TODO: reset u,v and restart the animation\n\nfig.canvas.mpl_connect(\"button_press_event\", mouse_click)\n\n\n\n\n\n\nTip\n\n\n\nYou can find a complete interactive implementation in sessions/s03_pdes_1d.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html",
    "href": "modules/pde-1d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Implement a full 1D reaction-diffusion workflow for the Gierer-Meinhardt model. Your submission should include code and figures that demonstrate pattern formation.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#required",
    "href": "modules/pde-1d/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement the PDE solver using an explicit Euler time step.\nEnforce Neumann boundary conditions at each step.\nUse \\(L=40\\), \\(dx=0.5\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).\nCreate an animation of \\(v(x)\\) that updates in time.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#turing-instability",
    "href": "modules/pde-1d/assignment.html#turing-instability",
    "title": "Assignment",
    "section": "Turing Instability",
    "text": "Turing Instability\n\nImplement is_turing_instability(a, b, d) and plot the Turing space diagram.\nMark the point \\((a, d)\\) you are using on the diagram.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#extra-mile-optional",
    "href": "modules/pde-1d/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nCompute unstable spatial modes and display the leading mode on the animation.\nMake the diagram interactive: clicking on \\((a, d)\\) updates the simulation.\nTry other boundary conditions and compare.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#tips-for-success",
    "href": "modules/pde-1d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Verify your Laplacian and boundary conditions first.\nTest incrementally: Plot intermediate results to detect instability early.\nBe careful with dt: If the simulation explodes, reduce \\(dt\\) or increase \\(dx\\).\nDocument choices: Report the parameters you used and the patterns you observed.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html",
    "href": "modules/ode-2d/fitzhugh-nagumo.html",
    "title": "FitzHugh–Nagumo Model",
    "section": "",
    "text": "The FitzHugh–Nagumo model is a simplified neuron model that captures key features of excitability and spiking behavior. It consists of two coupled ODEs:\n\\[\\begin{aligned}\n\\epsilon \\dot v &= f(v) - w + I_{\\text{app}} \\\\\n\\dot w &= v - \\gamma w\n\\end{aligned}\\]\nWhere \\(v\\) is the fast variable representing the membrane potential, \\(w\\) is a recovery variable, \\(I_{\\text{app}}\\) is an applied current, and \\(\\epsilon \\ll 1\\) controls the timescale separation between the fast variable \\(v\\) and the slow variable \\(w\\). \\(f(v)\\) is a cubic nonlinearity, often taken as\n\\[\nf(v) = v (1 - v)(v - \\alpha),\\quad \\text{for } 0 &lt; \\alpha &lt; 1\n\\]\nFigure 1: Phase plane of the FitzHugh–Nagumo system with epsilon = 0.01, gamma = 0.5, I_app = 0.5 and alpha = 0.1. Trajectories are shown for different initial conditions (IC as v-w, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\nFollow the steps outline in the CDIMA model to explore how the FitzHugh–Nagumo system behaves for different initial conditions and parameters.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html#time-series-and-excitability",
    "href": "modules/ode-2d/fitzhugh-nagumo.html#time-series-and-excitability",
    "title": "FitzHugh–Nagumo Model",
    "section": "Time Series and Excitability",
    "text": "Time Series and Excitability\nIn the excitable regime, trajectories typically stay near the resting equilibrium, but sufficiently large perturbations can trigger a large excursion (a “spike”) before returning to rest.\nBelow we plot the fast variable \\(v(t)\\) for a fixed parameter set and initial condition.\n\n\n\n\n\n\n\n\nFigure 2: Time series \\(v(t)\\) for the FitzHugh–Nagumo system (same parameters as the phase-plane plot). Depending on the initial condition, the solution may relax to rest or exhibit a spike/oscillation.\n\n\n\n\n\nTry changing the initial condition and parameters to see how the time series changes. What regimes of behavior do you observe? Can you connect these observations to the phase plane trajectories and the underlying theory of excitability?",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html#resources",
    "href": "modules/ode-2d/fitzhugh-nagumo.html#resources",
    "title": "FitzHugh–Nagumo Model",
    "section": "Resources",
    "text": "Resources\n\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/sessions/s02_odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html",
    "href": "modules/ode-2d/van-der-pol.html",
    "title": "Van der Pol Oscillator",
    "section": "",
    "text": "The Van der Pol oscillator is a prototypical nonlinear system that exhibits self-sustained oscillations. For a wide range of initial conditions, trajectories converge to a stable limit cycle.\nIn the form we will use in this course, the system is written as (Strogatz 2024, chap. 7.5):\n\\[\\begin{aligned}\n\\dot x &= \\mu\\,(y - f(x)) \\\\\n\\dot y &= -\\frac{x}{\\mu}\n\\end{aligned}\\]\nwhere \\(\\mu&gt;0\\) controls the strength of the nonlinearity (and the fast–slow character for large \\(\\mu\\)), and\n\\[\nf(x) = \\frac{x^3}{3} - x.\n\\]\nFigure 1: Phase plane of the Van der Pol system with mu = 3. Trajectories are shown for different initial conditions (IC as x-y, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\nFollow the steps outline in the CDIMA model to explore how the Van der Pol system behaves for different initial conditions and parameters.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html#the-stable-limit-cycle",
    "href": "modules/ode-2d/van-der-pol.html#the-stable-limit-cycle",
    "title": "Van der Pol Oscillator",
    "section": "The Stable Limit Cycle",
    "text": "The Stable Limit Cycle\nThe Van der Pol system has a stable limit cycle that attracts trajectories from a wide range of initial conditions. Plot this limit cycle as a \\(x(t)-t\\) plot, and verify that it matches the phase plane trajectories.\n\n\n/tmp/ipykernel_2875/2854713749.py:14: UserWarning:\n\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n\n\n\n\n\n\n\n\n\nFigure 2: Time series of x(t) for the Van der Pol system with mu = 3 and IC: (2, -2). Generated with scipy.integrate.solve_ivp() and matplotlib.\n\n\n\n\n\nThe amplitude and period of the limit cycle depend on \\(\\mu\\). There are two phases of the limit cycle: a slow phase where trajectories move slowly near the cubic nullcline, and a fast phase where trajectories rapidly jump between branches of the nullcline. The speed of the slow phase increases with \\(\\mu\\), while the fast phase becomes more abrupt. This leads to a characteristic “relaxation oscillation” shape for large \\(\\mu\\).\nPlay with the parameter \\(\\mu\\) to see how it changes the shape of the limit cycle and the transient dynamics.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html#resources",
    "href": "modules/ode-2d/van-der-pol.html#resources",
    "title": "Van der Pol Oscillator",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 7.5) for theoretical background on the Van der Pol oscillator.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/sessions/s02_odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/assignment.html",
    "href": "modules/ode-2d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "You will build a Matplotlib animation for one 2D ODE model.\nChoose a model\nWrite one Python script that, when executed, opens a figure showing:\nUse the pipeline showed for the CDIMA model as a starting point, and adapt it to the model you choose. For the animation, follow the steps outlined in the animation page.\nThen, add a second subplot that animates the time evolution of one variable (as indicated in the page for each model).\nExtra Mile (Optional): Make the figure interactive: clicking on the phase plane sets the initial condition, and the animation restarts.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-2d/assignment.html#tips-for-success",
    "href": "modules/ode-2d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Get the ODE function working first, then build up.\nTest incrementally: Verify each function works before moving to the next.\nUse the reference: The provided code (and additional documentation) is there to help you understand the structure.\nExperiment: Try different parameter values and see what happens.\nCollaborate: Discuss with your teammates, divide the work if needed. You can also work separately and then compare your implementations.\nAsk questions: If you’re stuck, ask for help!\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Assignment"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Math Modeling (Python)",
    "section": "",
    "text": "Welcome! This site collects the notes, code, and datasets for the Applied Math Lab.",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#course-at-a-glance",
    "href": "index.html#course-at-a-glance",
    "title": "Applied Math Modeling (Python)",
    "section": "Course at a glance",
    "text": "Course at a glance\n\nFormat: 10 live in-person sessions\nTools: Python, NumPy, SciPy, matplotlib, Streamlit, NetworkX\nMain goal: learn modeling by building simulations you can explore and explain",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#how-this-reposite-is-organized",
    "href": "index.html#how-this-reposite-is-organized",
    "title": "Applied Math Modeling (Python)",
    "section": "How this repo/site is organized",
    "text": "How this repo/site is organized\n\nModules (theory + guided notebooks/notes): modules/\nSession code (classroom scripts and demos): sessions/\nStreamlit app (interactive demos): streamlit/\nDatasets used in network sessions: data/",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#what-you-will-build",
    "href": "index.html#what-you-will-build",
    "title": "Applied Math Modeling (Python)",
    "section": "What you will build",
    "text": "What you will build\nAcross the course you will implement and experiment with:\n\nODE models (SIR, spruce budworm, Michaelis–Menten)\nNonlinear oscillators (Van der Pol, FitzHugh–Nagumo)\nReaction–diffusion PDEs (finite differences + animations)\nCollective behavior (Vicsek flocking + interaction)\nNetworks (metrics, spreading processes, real datasets)\nCellular automata (1D rules + traffic models)",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#getting-started-locally",
    "href": "index.html#getting-started-locally",
    "title": "Applied Math Modeling (Python)",
    "section": "Getting started locally",
    "text": "Getting started locally\n\nCreate an environment\nIf you use Conda:\nconda create --name amlab python=3.13\nconda activate amlab\nconda install --yes --file requirements.txt\nIf you prefer pip:\nWindows (PowerShell):\npython -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\npip install -r requirements.txt\nmacOS/Linux:\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\n\n\nRun the Streamlit app\nstreamlit run ./streamlit/home.py",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#where-to-go-next",
    "href": "index.html#where-to-go-next",
    "title": "Applied Math Modeling (Python)",
    "section": "Where to go next",
    "text": "Where to go next\n\nStart with Session 1: ODEs in 1D\nContinue with Session 3: PDEs in 1D\nReview the full schedule in the Syllabus",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#program",
    "href": "syllabus.html#program",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html",
    "href": "modules/ode-2d/index.html",
    "title": "Ordinary Differential Equations in 2D",
    "section": "",
    "text": "In this session we move from 1D dynamics to planar systems \\[\\dot x=f(x,y;\\,\\theta),\\qquad \\dot y=g(x,y;\\,\\theta),\\] where behavior can depend strongly on both the initial state \\((x_0,y_0)\\) and the parameters \\(\\theta\\).",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#case-studies",
    "href": "modules/ode-2d/index.html#case-studies",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Case Studies",
    "text": "Case Studies\n\nChlorine Dioxide–Iodine–Malonic Acid (CDIMA)\nThe CDIMA reaction is a classical example from chemical kinetics that can display rich nonlinear dynamics. We will use a reduced 2D model to explore how parameter changes can trigger qualitatively different behaviors (e.g., convergence to a steady state vs. sustained oscillations).\nGo to this example\n\n\nVan der Pol oscillator\nThe Van der Pol system is a prototypical self-excited oscillator: it exhibits a stable limit cycle for a wide range of initial conditions. It is a clean testbed for studying how nonlinear damping (controlled by a parameter) changes trajectories and transient dynamics.\nGo to this example\n\n\nFitzHugh–Nagumo\nThe FitzHugh–Nagumo model is a simplified neuron model capturing excitability and spiking. It’s a great example of a fast–slow 2D system, where parameters control whether trajectories relax to rest, fire spikes, or oscillate.\nGo to this example",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#goals",
    "href": "modules/ode-2d/index.html#goals",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Goals",
    "text": "Goals\n\nExplore the evolution of the system depending on its initial state \\((x_0,y_0)\\).\nStudy how solutions depend on equation parameters (bifurcation-style exploration).\nBuild intuition using phase portraits, time series, and (simple) animations.\nConnect the simulations to the theory: oscillations/limit cycles, fast–slow dynamics, and excitability.\nRun the provided scripts and modify initial conditions/parameters to reproduce and explain the behaviors discussed in lecture.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#what-do-we-need",
    "href": "modules/ode-2d/index.html#what-do-we-need",
    "title": "Ordinary Differential Equations in 2D",
    "section": "What do we need?",
    "text": "What do we need?\n\nscipy\nWe’ll use numerical integration to evolve the ODEs forward in time. In particular, we’ll rely on scipy.integrate.solve_ivp() which supports explicit Runge–Kutta methods (and many other solvers). Review session 1 for a refresher on how to use solve_ivp() for 1D ODEs, and we’ll extend that workflow to 2D systems here.\n\n\nsolve_ivp()\nCore workflow:\n\ndefine the right-hand side \\((f,g)\\) as a Python function\nchoose a time span and evaluation grid\nintegrate with an RK method (or a stiff method when needed)\nanalyze \\((x(t),y(t))\\) in time and in phase space\n\n\n\nmatplotlib.animation\nTo animate trajectories we update plot elements frame-by-frame (lines, markers, text), creating the illusion of motion. This is a lightweight way to visualize how trajectories “flow” through the phase plane.\n\n\nmatplotlib.pyplot\nUsed to initialize the figure/axes and draw static plot elements:\n\naxes labels, titles, legends\nnullclines or vector fields (when included)\nstatic phase portrait scaffolding\n\n\n\nmatplotlib.backend_bases\nWe’ll hook into Matplotlib’s event system (e.g. mouse clicks) to let the user interact with the model. For example, clicking in the phase plane can set a new initial condition \\((x_0,y_0)\\) and re-run the integration.\n\n\nstreamlit?\nAt the moment, animations and interactive plots are not implemented yet in Streamlit. For this reason, we will run the code in Python scripts for now.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#lets-get-started",
    "href": "modules/ode-2d/index.html#lets-get-started",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Let’s Get Started!",
    "text": "Let’s Get Started!\nGo to the assignment page for the details of the coding task, and check out the provided code for each model to get a head start.\nThe CDIMA model is fully explained and implemented, so it’s a great place to start. Then, you can move on to the Van der Pol and FitzHugh–Nagumo models.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html",
    "href": "modules/ode-2d/cdima.html",
    "title": "CDIMA Reaction",
    "section": "",
    "text": "The CDIMA model (Chlorine Dioxide–Iodine–Malonic Acid reaction) is a classic 2D chemical oscillator used to study phase-plane dynamics. The equations are:\n\\[\\begin{aligned}\n\\dot x &= a - x - \\frac{4xy}{1+x^2} \\\\\n\\dot y &= bx \\left( 1 - \\frac{y}{1+x^2} \\right)\n\\end{aligned}\\]\nwhere \\(x\\) and \\(y\\) are the dimensionless concentrations of I\\(^-\\) and ClO\\(_2^-\\). The parameters \\(a,\\ b &gt; 0\\) depend on the empirical rate constants and on the concentrations assumed for the slow reactants (Strogatz 2024, chap. 8.3).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#phase-plane-analysis",
    "href": "modules/ode-2d/cdima.html#phase-plane-analysis",
    "title": "CDIMA Reaction",
    "section": "Phase-Plane Analysis",
    "text": "Phase-Plane Analysis\nTo understand the dynamics, we can analyze the phase plane. A phase plane is a 2D plot whose axes are the state variables (here, \\(x\\) and \\(y\\)). Each point \\((x,y)\\) represents the system’s state at a given time, and the differential equations define a vector field on this plane that indicates how the state evolves. Trajectories (solution curves) show how \\((x(t),y(t))\\) moves through the plane, revealing features such as equilibrium points, nullclines, limit cycles, and their stability.\n\n\n\n\n\n\n\n\nFigure 1: Phase plane of the CDIMA system with a = 10, b = 4. Trajectories are shown for different initial conditions (IC as x-y, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\n\n\n\n\n\nGenerating this phase plane in Python is simple. We will follow the same approach as in 1D: define the right-hand side as a function, choose a time span and evaluation grid, and integrate with scipy.integrate.solve_ivp(). Follow the steps below.\n\nDefine the ODE Function\nFirst, define the cdima() function. Remeber that any ODE (in any dimension), can be written as:\ndef ode(t, state, *params):\n    # state represents the current values of the variables (e.g., x, y)\n\n    # params are any additional parameters needed to compute the derivatives\n    # each of them is separated by commas\n\n    return dstate_dt  # this should be a sequence of the same length as `state`\nCan you write the cdima() function in this format? If you need an extra hint, uncollapse the code block below.\n\n\n\n\n\n\nHint: CDIMA right-hand side (click to expand)\n\n\n\n\n\ndef cdima(t: float, state: tuple[float, float], a: int, b: int) -&gt; tuple[float, float]:\n    \"\"\"Remember the docstring and type hints!\"\"\"\n    x, y = state  # unpack the state variables\n    dxdt =  # compute dx/dt\n    dydt = # compute dy/dt\n    return (dxdt, dydt)  # return the derivatives as a list\n\n\n\n\n\nSolve the Initial Value Problem\nNext, we need to solve the initial value problem (IVP) for a given initial condition and parameters. The workflow is similar to 1D, but now we have a vector of state variables instead of a single variable. The solve_ivp() function will return the trajectories for both \\(x(t)\\) and \\(y(t)\\), which we can then plot in the phase plane.\nUsing scipy.integrate.solve_ivp() and your previously defined cdima() function, can you write the code to solve the IVP for a specific initial condition and parameters? The output should be the trajectories of \\(x(t)\\) and \\(y(t)\\), i.e. two arrays of the same length.\nIf you need a hint, uncollapse the code block below.\n\n\n\n\n\n\nHint: Solving the IVP (click to expand)\n\n\n\n\n\nfrom scipy.integrate import solve_ivp\nimport numpy as np\n\n# Define parameters\na, b = 10, 4\n# Define initial condition\nx0, y0 = 0, 3 \n# Define time span and evaluation points\nt_span = (0, 20) # Start at t=0 and end at t=20\nt_eval = np.linspace(t_span[0], t_span[1], 2000)  # Return 2000 points between t=0 and t=20\n# Solve the IVP\nsol = solve_ivp(cdima, t_span, [x0, y0], args=(a, b), t_eval=t_eval)\n# sol.y[0] will give you x(t) and sol.y[1] will give you y(t)\n\n\n\nDo you have it? Great! Try the following initial conditions: \\(a=10\\), \\(b=4\\), and \\((x_0,y_0) = (0,3)\\). You can see this trajectory in Figure 1. What will be the state of the system at \\(t=5\\)?\n\n\n\n\n\n\nSolution: State at t=20 (click to expand)\n\n\n\n\n\n\nfrom scipy.integrate import solve_ivp\nimport numpy as np\n\nfrom sessions.s02_odes_2d.cdima import cdima\n\na, b = 10, 4\nx0, y0 = 0, 3\n\nt_span = (0, 5)\nt_eval = np.linspace(t_span[0], t_span[1], 500)\nsol = solve_ivp(cdima, t_span, [x0, y0], args=(a, b), t_eval=t_eval)\nfinal_state = sol.y[:, -1]  # Get the last column of sol.y, which corresponds to the state at t=5\nprint(f\"State at t=5: x={final_state[0]:.2f}, y={final_state[1]:.2f}\")\n\nState at t=5: x=2.08, y=4.13\n\n\n\n\n\n\n\nPlotting the Phase Plane\nFinally, we can plot the trajectories in the phase plane using matplotlib.pyplot. Try to reproduce the plot in Figure 1 by plotting \\(y(t)\\) vs. \\(x(t)\\) for different initial conditions. You can also mark the initial conditions on the plot to see where the trajectories start.\n\n\n\n\n\n\nHint: Plotting the Phase Plane (click to expand)\n\n\n\n\n\nimport matplotlib.pyplot as plt \n\nfig, ax = plt.subplots(figsize=(8, 4))\nfor x0, y0 in [(0, 3), (0, 1.5), (2, 0)]:\n    sol = solve_ivp(cdima, [0, 20], [x0, y0], args=(a, b), t_eval=np.linspace(0, 20, 2000))\n    ax.plot(sol.y[0], sol.y[1], label=f\"IC: ({x0}, {y0})\")  # Plot y vs. x\n    ax.plot(x0, y0, 'o', color='black')  # Mark the initial condition\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.show()",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#nullclines-in-the-phase-plane",
    "href": "modules/ode-2d/cdima.html#nullclines-in-the-phase-plane",
    "title": "CDIMA Reaction",
    "section": "Nullclines in the Phase Plane",
    "text": "Nullclines in the Phase Plane\nIn addition to trajectories, we can also plot nullclines in the phase plane. Nullclines are curves where the derivative of one of the variables is zero. They help us identify equilibrium points and understand the flow of trajectories.\n\n\n\n\n\n\n\n\nFigure 2: Nullclines of the CDIMA system with a = 10, b = 4. The x-nullcline (dx/dt=0) is shown in blue, and the y-nullcline (dy/dt=0) is shown in red. Generated with matplotlib.pyplot.\n\n\n\n\n\nHow can we find the nullclines for the CDIMA system? We have two options:\n\nAnalytical approach: Set \\(\\dot x = 0\\) and \\(\\dot y = 0\\) and solve the resulting equations for \\(y\\) as a function of \\(x\\) (or vice versa). This can be done by hand or using symbolic computation tools like SymPy.\nNumerical approach: Evaluate the derivatives on a grid of \\((x,y)\\) values and identify where they change sign (i.e., where they cross zero). This can be done using numerical methods and is often more practical for complex systems. Figure 2 shows the nullclines computed using a numerical approach.\n\nPick one of these methods to compute the nullclines for the CDIMA system, and then plot them in the phase plane. The intersection points of the nullclines correspond to equilibrium points of the system.\n\n\n\n\n\n\nHint: Computing Nullclines (click to expand)\n\n\n\n\n\n# Define the limits for the grid\nx_min, x_max = 0.1, 5\ny_min, y_max = 0, 10\nnum_points = 1000  # Number of points in the grid\n\n# Create a grid of points\nx_values = np.linspace(x_min, x_max, num_points)\ny_values = np.linspace(y_min, y_max, num_points)\nx_grid, y_grid = np.meshgrid(x_values, y_values)\n# meshgrid creates two 2D arrays:\n# x_grid and y_grid, where each element (i,j) corresponds to the\n# coordinates (x_values[i], y_values[j]) in the phase plane.\n\n# Evaluate the derivatives at each point\ndx_dt: np.ndarray\ndy_dt: np.ndarray\ndx_dt, dy_dt = cdima(0, [x_grid, y_grid], a, b)\n\n# Extract nullcline data:\n# Find where dx_dt changes sign (zero crossings)\ndxdt_zero_crossings = np.where(np.diff(np.sign(dx_dt), axis=0))\ndxdt_nullcline_x = x_grid[dxdt_zero_crossings]\ndxdt_nullcline_y = y_grid[dxdt_zero_crossings]\n\n# Extract nullcline data - Find where dy_dt changes sign (zero crossings)\ndydt_zero_crossings = np.where(np.diff(np.sign(dy_dt), axis=1))\ndydt_nullcline_x = x_grid[dydt_zero_crossings]\ndydt_nullcline_y = y_grid[dydt_zero_crossings]\nNow you can plot the nullclines using matplotlib Recommendation: do not join the points! There is no guarantee that the sequence of points in dxdt_nullcline_x and dxdt_nullcline_y (or dydt_nullcline_x and dydt_nullcline_y) will form a continuous curve, so it’s better to plot them as individual points (e.g., using 'o' markers) rather than trying to connect them with lines.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#equilibrium-points-on-the-phase-plane",
    "href": "modules/ode-2d/cdima.html#equilibrium-points-on-the-phase-plane",
    "title": "CDIMA Reaction",
    "section": "Equilibrium Points on the Phase Plane",
    "text": "Equilibrium Points on the Phase Plane\nThe intersection points of the nullclines correspond to equilibrium points (equilibria) of the system. In other words, they are points where both \\(\\dot x = 0\\) and \\(\\dot y = 0\\) simultaneously.\nTo find the equilibrium points, we can look for the coordinates where the x-nullcline and y-nullcline intersect. This can be done by checking for points that are close to each other in both nullcline datasets or by using a more systematic approach (e.g., clustering or root-finding methods).\nIn Python, we can use the scipy.optimize.fsolve() function to find the roots of the system of equations defined by the nullclines. This will give us the coordinates of the equilibrium points.\nfrom scipy.optimize import fsolve\n\na, b = 10, 4\n\n# We need to define a function that represents the system of\n# equations for the nullclines\ndef cdima_fixed(xy: np.ndarray) -&gt; np.ndarray:\n    return cdima(None, xy, a, b)\n\nequilibrium_point = fsolve(cdima_fixed, [1, 1])  # Initial guess for the equilibrium point\nprint(f\"Equilibrium point: x={equilibrium_point[0]:.2f}, y={equilibrium_point[1]:.2f}\")\nIf we have done things well, plotting the equilibrium point on the phase plane should show that it lies at the intersection of the nullclines.\n\n\n\n\n\n\n\n\nFigure 3: Equilibrium point of the CDIMA system with a = 10, b = 4. The equilibrium point is marked with a black dot at the intersection of the nullclines. Generated with scipy.optimize.fsolve() and matplotlib.pyplot.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#stability-of-the-equilibrium-point",
    "href": "modules/ode-2d/cdima.html#stability-of-the-equilibrium-point",
    "title": "CDIMA Reaction",
    "section": "Stability of the Equilibrium Point",
    "text": "Stability of the Equilibrium Point\nAs you know from 1D systems, a equilibrium point can be stable or unstable. A stable equilibrium point attracts nearby trajectories, while an unstable equilibrium point repels them. In 2D systems, we can determine the stability of an equilibrium point by analyzing the Jacobian matrix of the system at that point. The Jacobian matrix is a 2x2 matrix that contains the partial derivatives of the right-hand side of the ODEs with respect to the state variables.\n\\[J =\n\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x} & \\frac{\\partial f}{\\partial y} \\\\\n\\frac{\\partial g}{\\partial x} & \\frac{\\partial g}{\\partial y}\n\\end{bmatrix}\\]\nWhere \\(f\\) and \\(g\\) are the right-hand sides of the ODEs for \\(\\dot x\\) and \\(\\dot y\\), respectively. The eigenvalues of the Jacobian determine the stability of the equilibrium point:\n\nIf both eigenvalues have negative real parts, the equilibrium point is stable (attracting).\nIf at least one eigenvalue has a positive real part, the equilibrium point is unstable (repelling).\n\nSo all we need to do is compute the equilibrium point \\((x^*, y^*)\\), evaluate the Jacobian at that point, and compute its eigenvalues to determine stability.\nAs the CDIMA model has two parameters, we can explore how the stability of the equilibrium point changes as we vary \\(a\\) and \\(b\\). This leads to a stability diagram in the parameter space, which can be very insightful for understanding the system’s behavior.\nFor the CDIMA model, we can prove that the boundary between stable and unstable regimes is given by the curve \\(b = \\frac{3}{5} a - \\frac{25}{a}\\) in the \\((a,b)\\) parameter space (Strogatz 2024, chap. 8.3). Now go to your CDIMA simulation and explore how the trajectories change as you cross this boundary by varying \\(a\\) and \\(b\\).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#closing-remarks",
    "href": "modules/ode-2d/cdima.html#closing-remarks",
    "title": "CDIMA Reaction",
    "section": "Closing Remarks",
    "text": "Closing Remarks\nHave you done all the steps above? Great! You should now have a good understanding of how to analyze a 2D ODE system using phase-plane methods. You can explore how changing the parameters affects the trajectories, nullclines, and equilibrium points. Try different initial conditions to see how the system’s behavior changes.\nYour next steps:\n\nReproduce the phase plane and nullcline plots for other systems such as the Van der Pol oscillator and the FitzHugh–Nagumo model.\nCreate an interactive animation of the trajectories in the phase plane using matplotlib.animation. You can follow the guide showed here to get started.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#resources",
    "href": "modules/ode-2d/cdima.html#resources",
    "title": "CDIMA Reaction",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 8.3) for theoretical background on the CDIMA model and phase-plane analysis.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/sessions/s02_odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html",
    "href": "modules/ode-2d/animation.html",
    "title": "Animations and Interactivity",
    "section": "",
    "text": "This page summarizes the core Matplotlib pattern we use to animate trajectories in the phase plane, and how to restart an animation when the user changes parameters or initial conditions.\nIf you struggle with this part, feel free to check a complete example of the CDMI animation here.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#minimal-animation-template",
    "href": "modules/ode-2d/animation.html#minimal-animation-template",
    "title": "Animations and Interactivity",
    "section": "Minimal Animation Template",
    "text": "Minimal Animation Template\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\n\n# ...\n# Your code to compute trajectories, nullclines, fixed point...\n# Example: sol = solve_ivp(...)\n# ...\n\n# Open a new figure (white canvas)\nfig = plt.figure()\nax = plt.gca()  # get current axis\n\n# Initialize the line object for animation on the phase plane\n(plot_trajectory,) = ax.plot([], [], lw=2)\n# This trajectory would be x-y for the\n# phase plane of the CDIMA and Van der Pol models, and v-w for the FitzHugh–Nagumo model\n\n\ndef animate(frame: int, xy: tuple[np.ndarray, np.ndarray]):\n    \"\"\"Update function called once per frame.\"\"\"\n    # unpack the solution (x(t), y(t)) or (v(t), w(t))\n    x, y = xy\n    # update the line data to show the trajectory up to the current frame\n    plot_trajectory.set_data(x[:frame], y[:frame])\n    # return the updated artist (line) for blitting\n    return (plot_trajectory,)\n\n\n# The animation object that will run the animation\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    fargs=(sol.y,),\n    frames=len(sol.t),\n    interval=1,  # delay between frames in milliseconds\n    blit=True,  # redraw only the updated artists for efficiency\n)\n\nWhat Happens in an Animation?\nThe animation function is called once per frame:\n\nframe (or i) is the frame index (0, 1, 2, …).\nxy is the data to plot (here, the solution sol.y returned by solve_ivp).\nthe function must update the artists (lines, points, text, etc.).\nit must return an iterable with the updated artists when blit=True. This tells Matplotlib which parts of the plot to redraw for the next frame, improving performance.\n\n\n\nThe Animation Function in Detail\nTemplate:\ndef animate_function(i: int, *args):\n    # update plot elements\n    return (artist1, artist2, ...)\nIn our case, the second input argument is the solution from solve_ivp. Updating a line is typically done with:\nline.set_data(x, y)\nThis replaces the line coordinates by the new points \\((x,y)\\).\n\n\nCreating the Animation (FuncAnimation)\nimport matplotlib.animation as animation\n\nani = animation.FuncAnimation(\n    fig,\n    function,\n    fargs=(sol.y,),\n    interval=1,\n    blit=True,\n)\nArguments:\n\nfig: the Matplotlib figure to animate\nfunction: the callback that updates plot elements on each frame\nfargs: extra arguments passed to function (everything except the frame index)\ninterval: delay between frames (milliseconds)\nblit: if True, redraws only the updated artists (faster). When using blit=True, your animation function must return the artists that were updated.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#interactivity-restarting-the-animation",
    "href": "modules/ode-2d/animation.html#interactivity-restarting-the-animation",
    "title": "Animations and Interactivity",
    "section": "Interactivity: Restarting the Animation",
    "text": "Interactivity: Restarting the Animation\nWhen the user clicks (new initial condition) or changes a parameter, a common pattern is:\nani.event_source.stop()          # stop the current animation\nani.frame_seq = ani.new_frame_seq()  # reset frame generator\nani._args = (xy, ...)            # replace animation inputs (like new fargs)\nani.event_source.start()         # start again\nThis is the mechanism used in the interactive scripts: recompute solve_ivp(...), update nullclines/fixed point, then restart the animation with the new data.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#mouse-clicks",
    "href": "modules/ode-2d/animation.html#mouse-clicks",
    "title": "Animations and Interactivity",
    "section": "Mouse Clicks",
    "text": "Mouse Clicks\nMatplotlib figures can react to user input via the event system. A common pattern is to capture clicks in a specific axis and use the click position as a new initial condition.\nfrom matplotlib.backend_bases import MouseEvent\n\n\ndef mouse_click(event: MouseEvent):\n    # Check if the mouse click happens in the axis \"ax1\"\n    if event.inaxes == ax1:\n        # Get the position of the mouse click on the axis\n        x0 = event.xdata\n        y0 = event.ydata\n    else:\n        return\n\n    # This part of the code should update the plot.\n    # Use the animation functions we have learnt:\n    # 1) stop the current animation\n    # 2) clear/reset it\n    # 3) recompute the solution (and nullclines/fixed point if needed)\n    # 4) set new animation arguments\n    # 5) start again\n\n\n# Make the figure aware of user clicks.\n# Whenever the user clicks, we run the function \"mouse_click\".\nfig.canvas.mpl_connect(\"button_press_event\", mouse_click)\nYou will need to stop the current animation, clear it, update the parameters/initial conditions, and start over (see the previous section).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html",
    "href": "modules/pde-1d/index.html",
    "title": "Partial Differential Equations in 1D",
    "section": "",
    "text": "In this session we move from ODEs to reaction-diffusion PDEs in one spatial dimension. We will discretize space with finite differences, advance in time with Euler’s method, and visualize pattern formation.",
    "crumbs": [
      "Session 3: PDEs in 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#case-studies",
    "href": "modules/pde-1d/index.html#case-studies",
    "title": "Partial Differential Equations in 1D",
    "section": "Case Studies",
    "text": "Case Studies\nGierer-Meinhardt 1D Turing Instability Assignment",
    "crumbs": [
      "Session 3: PDEs in 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#goals",
    "href": "modules/pde-1d/index.html#goals",
    "title": "Partial Differential Equations in 1D",
    "section": "Goals",
    "text": "Goals\n\nImplement the 1D Laplacian with finite differences.\nSimulate a reaction-diffusion system with explicit time stepping.\nVisualize patterns and understand when they emerge.\nConnect parameter choices to stability and pattern formation.\nBuild animations and add simple user interaction.",
    "crumbs": [
      "Session 3: PDEs in 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#what-do-we-need",
    "href": "modules/pde-1d/index.html#what-do-we-need",
    "title": "Partial Differential Equations in 1D",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nWe use NumPy arrays to represent spatial fields and np.roll() to compute the discrete Laplacian.\n\n\nmatplotlib.pyplot\nInitialize the figure and axes and plot static elements (labels, titles, limits).\n\n\nmatplotlib.animation\nUpdate line objects frame-by-frame to create animations.\n\n\nmatplotlib.backend_bases\nHandle mouse clicks to let the user interact with the simulation.\n\n\nscipy\nGreat for ODEs, but we will not use it for PDEs in this session. We need to enforce boundary conditions at every step.",
    "crumbs": [
      "Session 3: PDEs in 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html",
    "href": "modules/pde-1d/gierer-meinhardt.html",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "",
    "text": "The Gierer-Meinhardt model is a classical reaction-diffusion system that can generate spatial patterns. In 1D it reads\n\\[\n\\begin{aligned}\n\\frac{\\partial u}{\\partial t} &= \\Delta u + \\gamma \\left(a - b u + \\frac{u^2}{v}\\right), \\\\\n\\frac{\\partial v}{\\partial t} &= d\\,\\Delta v + \\gamma \\left(u^2 - v\\right),\n\\end{aligned}\n\\]\nwhere \\(u(x,t)\\) and \\(v(x,t)\\) are concentrations, \\(a,b,\\gamma\\) are reaction parameters, and \\(d\\) is the diffusion ratio for \\(v\\).\nFigure 1: Gierer-Meinhardt 1D: example profile of \\(v(x)\\) after explicit Euler integration with \\(L=40\\), \\(dx=0.5\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#laplacian-in-1d",
    "href": "modules/pde-1d/gierer-meinhardt.html#laplacian-in-1d",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Laplacian in 1D",
    "text": "Laplacian in 1D\nIn one dimension, the Laplacian is the second derivative:\n\\[\n\\Delta u = \\frac{d^2 u}{dx^2}.\n\\]\nUsing a centered finite difference on a grid with spacing \\(h\\):\n\\[\n\\Delta u(x) \\approx \\frac{u(x+h) - 2u(x) + u(x-h)}{h^2} + \\mathcal{O}(h^2).\n\\]\nThis is easy to implement with np.roll() to access neighbors on a grid.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#boundary-conditions",
    "href": "modules/pde-1d/gierer-meinhardt.html#boundary-conditions",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Boundary Conditions",
    "text": "Boundary Conditions\n\nNeumann (zero flux)\n\\[u_x(0)=0,\\quad u(0)=u(h)\\]\n\n\nDirichlet (fixed values)\n\\[u(0)=\\alpha,\\quad u(L)=\\beta\\]\n\n\nPeriodic\n\\[u(0)=u(L)\\]",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "href": "modules/pde-1d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Exercise: Simulate the PDE",
    "text": "Exercise: Simulate the PDE\nThe reference script uses \\(L=40\\), \\(dx=0.5\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), and \\(\\gamma=1\\). We initialize \\(u(x)\\) and \\(v(x)\\) at 1, add 1% noise, integrate with Euler’s method, apply Neumann boundary conditions, and visualize \\(v(x)\\).\n\nStep 1: Initialize\nimport numpy as np\n\nlength = 40\ndx = 0.5\nlenx = int(length / dx)\n\nuv = np.ones((2, lenx))\nuv += uv * np.random.randn(2, lenx) / 100\n\n\nStep 2: Define the PDE\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    # Laplacian via finite differences (np.roll handles neighbors)\n    lap = -2 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap /= dx**2\n\n    u, v = uv\n    lu, lv = lap\n\n    # TODO: implement the reaction terms f(u, v) and g(u, v)\n    # TODO: combine diffusion + reaction to build du_dt and dv_dt\n    return du_dt, dv_dt\n\n\n\n\n\n\nHint: Gierer-Meinhardt PDE (click to expand)\n\n\n\n\n\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    lap = -2 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap /= dx**2\n\n    u, v = uv\n    lu, lv = lap\n\n    f = a - b * u + (u**2) / v\n    g = u**2 - v\n    du_dt = lu + gamma * f\n    dv_dt = d * lv + gamma * g\n    return du_dt, dv_dt\n\n\n\n\n\nStep 3: Time stepping\nnum_iter = 50000\ndt = 0.001\n\nfor _ in range(num_iter):\n    dudt, dvdt = gierer_meinhardt_pde(0, uv, dx=dx)\n    uv[0] = uv[0] + dudt * dt\n    uv[1] = uv[1] + dvdt * dt\n\n    # Neumann boundary conditions\n    uv[:, 0] = uv[:, 1]\n    uv[:, -1] = uv[:, -2]\n\n\nStep 4: Plot\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, length, lenx)\nfig, ax = plt.subplots()\nax.plot(x, uv[1])\nplt.show()\n\n\nExplore\nRe-run with \\(d=30\\) and compare the pattern. Try other \\((a, d)\\) pairs and share your observations.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#animation-extension",
    "href": "modules/pde-1d/gierer-meinhardt.html#animation-extension",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Animation Extension",
    "text": "Animation Extension\nInstead of plotting only the final state, update the line at every frame:\nimport matplotlib.animation as animation\n\n(plot_v,) = ax.plot(x, uv[1])\n\ndef animate(frame):\n    nonlocal uv\n    dudt, dvdt = gierer_meinhardt_pde(frame, uv, dx=dx)\n    uv[0] = uv[0] + dudt * dt\n    uv[1] = uv[1] + dvdt * dt\n    plot_v.set_data(x, uv[1])\n    return (plot_v,)\n\nani = animation.FuncAnimation(fig, animate, interval=1, blit=True)\nIf the system stays flat for some parameters and forms waves for others, you are seeing the onset of Turing instability. Proceed to the next page to analyze it.\n\n\n\n\n\n\nTip\n\n\n\nFull reference code is available in sessions/s03_pdes_1d.",
    "crumbs": [
      "Session 3: PDEs in 1D",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html",
    "href": "modules/ode-1d/index.html",
    "title": "Ordinary Differential Equations in 1D",
    "section": "",
    "text": "Numerical integration is fundamental for solving ordinary differential equations (ODEs) that don’t have analytical solutions. In this first session, you will learn how to:",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#contents",
    "href": "modules/ode-1d/index.html#contents",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Contents",
    "text": "Contents\n\nSIR Epidemic Model\nMichaelis–Menten Enzyme Kinetics\nSpruce Budworm Population Model\nAssignment",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#the-initial-value-problem",
    "href": "modules/ode-1d/index.html#the-initial-value-problem",
    "title": "Ordinary Differential Equations in 1D",
    "section": "The Initial Value Problem",
    "text": "The Initial Value Problem\nAn initial value problem (IVP) consists of:\n\\[\\frac{dy}{dt} = f(t, y), \\quad y(t_0) = y_0\\]\nWhere: - \\(f(t, y)\\) is the rate of change function - \\(y_0\\) is the initial condition at time \\(t_0\\)",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#scipys-solve_ivp",
    "href": "modules/ode-1d/index.html#scipys-solve_ivp",
    "title": "Ordinary Differential Equations in 1D",
    "section": "SciPy’s solve_ivp",
    "text": "SciPy’s solve_ivp\nThe scipy.integrate.solve_ivp function is the standard tool for solving ODEs in Python. Try the following code:\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef exponential_decay(t, y):\n     return -0.5 * y\n\nt_span = [0, 10]\ny0 = [2, 4, 8]\nsol = solve_ivp(\n    fun=exponential_decay,\n    t_span=t_span, \n    y0=y0)\n\nprint(sol.t)\n\nprint(sol.y)\nHow does solve_ivp work? Let’s understand its parameters (copied from the documentation):\n\nfun: Right-hand side of the system: the time derivative of the state \\(y\\) at time \\(t\\). The calling signature is fun(t, y), where t is a scalar and y is an ndarray with len(y) = len(y0). Additional arguments need to be passed if args is used (see documentation of args argument). fun must return an array of the same shape as y. In our example, exponential_decay defines the ODE \\(\\frac{dy}{dt} = -0.5y\\), which models exponential decay \\(y(t) = y_0 e^{-0.5t}\\).\nt_span: Interval of integration \\((t_0, t_f)\\). The solver starts with \\(t=t_0\\) and integrates until it reaches \\(t=t_f\\). Both \\(t_0\\) and \\(t_f\\) must be floats or values interpretable by the float conversion function.\ny0: Initial state. For problems in the complex domain, pass y0 with a complex data type (even if the initial value is purely real).\n\nYou can also specify additional parameters: - method: Integration method to use. Common choices include 'RK45' (default), 'RK23', 'DOP853', 'Radau', 'BDF', and 'LSODA'. - t_eval: Times at which to store the computed solution, must be sorted and lie within t_span. If None (default), use points selected by the solver. - args: Additional arguments to pass to the user-defined functions. If, for example, fun has the signature fun(t, y, a, b, c), then args=(a, b, c).",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#systems-of-odes",
    "href": "modules/ode-1d/index.html#systems-of-odes",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Systems of ODEs",
    "text": "Systems of ODEs\nFor multiple coupled equations, return a list or array of derivatives:\ndef sir_model(t, y, beta, gamma):\n    S, I, R = y\n    N = S + I + R\n    \n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    \n    return [dSdt, dIdt, dRdt]",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#best-practices",
    "href": "modules/ode-1d/index.html#best-practices",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways check convergence: Plot solutions at different tolerances\nUse appropriate methods: 'RK45' (default) works well for most problems\nVectorize when possible: Makes code faster and cleaner\nDocument parameters: Keep track of units and meanings\nValidate against known solutions: Test your implementation",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#next-steps",
    "href": "modules/ode-1d/index.html#next-steps",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Next Steps",
    "text": "Next Steps\nApply these techniques to the classical models in Session 1: - SIR epidemiological model - Spruce budworm population dynamics - Michaelis–Menten enzyme kinetics",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#resources",
    "href": "modules/ode-1d/index.html#resources",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Resources",
    "text": "Resources\n\nSciPy solve_ivp documentation\nPython for ODEs tutorial",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html",
    "href": "modules/ode-1d/michaelis-menten.html",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "",
    "text": "Michaelis–Menten kinetics is a foundational model in biochemical reaction dynamics. It relates substrate concentration to reaction rate using a saturating nonlinearity.\nThe (simplified) substrate dynamics implemented in the reference script is:\n\\[\n\\dot s = \\frac{V_{\\max}s}{K_m + s}\n\\]\nwhere \\(V_{\\max}\\) is the maximum rate and \\(K_m\\) is the Michaelis constant.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-reference",
    "href": "modules/ode-1d/michaelis-menten.html#sec-reference",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Reference Implementation",
    "text": "Reference Implementation\nSee:\n\nsessions/s01_odes_1d/michaelis_menten.py\n\nThe helper plot_michaelis_menten(...) produces:\n\n\\(s(t)\\) over time\n\\(v(s)\\) with guides at \\(s=K_m\\) and \\(v=V_{\\max}/2\\)",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-render-figure",
    "href": "modules/ode-1d/michaelis-menten.html#sec-render-figure",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Render-time Figure",
    "text": "Render-time Figure\n\n\n\n\n\n\n\n\nFigure 1: Michaelis–Menten: time series \\(s(t)\\) and rate curve \\(v(s)\\).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-exploration",
    "href": "modules/ode-1d/michaelis-menten.html#sec-exploration",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Exploration",
    "text": "Exploration\n\nIncrease \\(V_{\\max}\\) and observe how the rate curve changes.\nIncrease \\(K_m\\) (lower affinity). How does the saturation point shift?",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-run-locally",
    "href": "modules/ode-1d/michaelis-menten.html#sec-run-locally",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Run Locally",
    "text": "Run Locally\npython sessions/s01_odes_1d/michaelis_menten.py",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  }
]