[
  {
    "objectID": "modules/numerical-integration/ode-1d-michaelis-menten.html",
    "href": "modules/numerical-integration/ode-1d-michaelis-menten.html",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "Michaelis–Menten kinetics is a foundational model in biochemical reaction dynamics. It relates substrate concentration to reaction rate using a saturating nonlinearity.\n\n\n\nSolve a 1D ODE with solve_ivp.\nPlot both a time series and the rate curve \\(v(s)\\).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-michaelis-menten.html#learning-objectives",
    "href": "modules/numerical-integration/ode-1d-michaelis-menten.html#learning-objectives",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "Solve a 1D ODE with solve_ivp.\nPlot both a time series and the rate curve \\(v(s)\\).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-sir.html",
    "href": "modules/numerical-integration/ode-1d-sir.html",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "The SIR model is a classical compartmental model in epidemiology. It splits the population into:\n\n\\(S(t)\\): susceptible\n\\(I(t)\\): infected\n\\(R(t)\\): recovered\n\nand describes how individuals move between these compartments over time.\n\n\n\nImplement and solve a system of ODEs with scipy.integrate.solve_ivp.\nVisualize \\(S(t)\\), \\(I(t)\\), and \\(R(t)\\).\nInterpret how the parameters \\((\\beta, \\gamma)\\) change the epidemic curve.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-sir.html#learning-objectives",
    "href": "modules/numerical-integration/ode-1d-sir.html#learning-objectives",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "Implement and solve a system of ODEs with scipy.integrate.solve_ivp.\nVisualize \\(S(t)\\), \\(I(t)\\), and \\(R(t)\\).\nInterpret how the parameters \\((\\beta, \\gamma)\\) change the epidemic curve.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-van-der-pol.html",
    "href": "modules/numerical-integration/ode-2d-van-der-pol.html",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "",
    "text": "1 Introduction\nThe Van der Pol oscillator is a canonical nonlinear system that exhibits a limit cycle and, for large \\(\\mu\\), a relaxation oscillation.\nThe reference implementation is in:\n\nsessions/s02_odes_2d/van_der_pol.py\n\n\n\n2 Model\nUsing the same form as the reference script:\n\\[\n\\begin{aligned}\n\\dot x &= \\mu\\left(y - \\left(\\frac{x^3}{3} - x\\right)\\right),\\\\\n\\dot y &= -\\frac{x}{\\mu}.\n\\end{aligned}\n\\]\n\n\n3 Render-time Phase Plane\n\n\n\n\n\n\n\n\nFigure 1: Van der Pol: trajectory in the phase plane with numerically approximated nullclines.\n\n\n\n\n\n\n\n4 Run the Interactive Version\npython sessions/s02_odes_2d/van_der_pol.py",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html",
    "href": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "",
    "text": "In Session 1 we studied 1D ODEs, where the geometry is simple: trajectories move along a line and equilibria are points where \\(\\dot x = 0\\). In 2D, the state is \\((x(t), y(t))\\) and trajectories live in the phase plane. This unlocks new qualitative behaviors: spirals, limit cycles, excitability, and relaxation oscillations.\nIn the course material, we will use several 2D models (CDIMA reaction, Van der Pol, FitzHugh–Nagumo). In this session we focus on the workflow:\n\nintegrate a system with scipy.integrate.solve_ivp\nvisualize trajectories in the phase plane\ncompute nullclines and fixed points\nanimate the trajectory with matplotlib.animation\nrestart the simulation interactively using mouse clicks\n\n\n\nBy the end of this session, you will be able to:\n\nImplement a 2D ODE in the signature expected by solve_ivp.\nCompute and plot phase-plane trajectories.\nCompute nullclines (analytically when possible, numerically otherwise).\nLocate fixed points using scipy.optimize.fsolve.\nCreate a Matplotlib animation that updates plot elements per frame.\nAdd an on-click event to change initial conditions/parameters and restart the animation.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#learning-objectives",
    "href": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#learning-objectives",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "",
    "text": "By the end of this session, you will be able to:\n\nImplement a 2D ODE in the signature expected by solve_ivp.\nCompute and plot phase-plane trajectories.\nCompute nullclines (analytically when possible, numerically otherwise).\nLocate fixed points using scipy.optimize.fsolve.\nCreate a Matplotlib animation that updates plot elements per frame.\nAdd an on-click event to change initial conditions/parameters and restart the animation.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-nullclines-analytical",
    "href": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-nullclines-analytical",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "6.1 Nullclines (Analytical)",
    "text": "6.1 Nullclines (Analytical)\nFor the FHN system we can write nullclines explicitly.\nBecause \\(\\dot v = 0\\) is equivalent to the numerator being zero,\n\\[v(1-v)(v-\\alpha) - w + I_{\\mathrm{app}} = 0 \\quad\\Rightarrow\\quad w = v(1-v)(v-\\alpha) + I_{\\mathrm{app}}.\\]\nAnd from \\(\\dot w = 0\\):\n\\[v - \\gamma w = 0 \\quad\\Rightarrow\\quad w = \\frac{v}{\\gamma}.\\]\nThese are often faster and cleaner than numerical approximations.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-nullclines-numerical",
    "href": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-nullclines-numerical",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "6.2 Nullclines (Numerical)",
    "text": "6.2 Nullclines (Numerical)\nIn many models, nullclines are not available in closed form. A robust numerical alternative is:\n\ncreate a grid in \\((v, w)\\)\nevaluate \\((\\dot v, \\dot w)\\) on the grid\nfind sign changes (zero crossings) of \\(\\dot v\\) and \\(\\dot w\\)\n\nThe repository includes a general helper in sessions/s02_odes_2d/cdima.py called compute_nullclines that does exactly this (it is reused by the baseline FHN script).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-fixed-point",
    "href": "modules/numerical-integration/ode-2d-fitzhugh-nagumo.html#sec-fixed-point",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "6.3 Fixed Point via fsolve",
    "text": "6.3 Fixed Point via fsolve\nTo locate a fixed point, we solve \\[F(v,w) = (\\dot v, \\dot w) = (0,0).\\]\nNumerically, scipy.optimize.fsolve can find a root near an initial guess:\nimport numpy as np\nfrom scipy.optimize import fsolve\n\n\ndef fixed_point(system_func, guess, args):\n    def F(x):\n        return system_func(None, x, *args)\n\n    return fsolve(F, guess)\n\n\nfp = fixed_point(fitzhugh_nagumo, guess=np.array([0.0, 0.0]), args=args)\nprint(fp)  # [v*, w*]",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Math Modeling (Python)",
    "section": "",
    "text": "Welcome! This site collects the notes, code, and datasets for the Applied Math Lab.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#create-an-environment",
    "href": "index.html#create-an-environment",
    "title": "Applied Math Modeling (Python)",
    "section": "4.1 Create an environment",
    "text": "4.1 Create an environment\nIf you use Conda:\nconda create --name amlab python=3.13\nconda activate amlab\nconda install --yes --file requirements.txt\nIf you prefer pip:\nWindows (PowerShell):\npython -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\npip install -r requirements.txt\nmacOS/Linux:\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#run-the-streamlit-app",
    "href": "index.html#run-the-streamlit-app",
    "title": "Applied Math Modeling (Python)",
    "section": "4.2 Run the Streamlit app",
    "text": "4.2 Run the Streamlit app\nstreamlit run ./streamlit/home.py",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-1-1d-odes-scipy-streamlit",
    "href": "syllabus.html#session-1-1d-odes-scipy-streamlit",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-2-2d-odes-nonlinear-oscillators",
    "href": "syllabus.html#session-2-2d-odes-nonlinear-oscillators",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Explore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-3-pdes-via-reactiondiffusion-systems",
    "href": "syllabus.html#session-3-pdes-via-reactiondiffusion-systems",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-4-coupled-odes-kuramoto-model",
    "href": "syllabus.html#session-4-coupled-odes-kuramoto-model",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Implement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-5-flocking-vicsek-model",
    "href": "syllabus.html#session-5-flocking-vicsek-model",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-6-networks-i-networkx-fundamentals",
    "href": "syllabus.html#session-6-networks-i-networkx-fundamentals",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-7-networks-ii-spreading-on-real-networks",
    "href": "syllabus.html#session-7-networks-ii-spreading-on-real-networks",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-8-cellular-automata-i-1d-ca",
    "href": "syllabus.html#session-8-cellular-automata-i-1d-ca",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-9-cellular-automata-ii-traffic-dynamics",
    "href": "syllabus.html#session-9-cellular-automata-ii-traffic-dynamics",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Apply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-10-final-project-support",
    "href": "syllabus.html#session-10-final-project-support",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Wrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "modules/numerical-integration/index.html",
    "href": "modules/numerical-integration/index.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "Numerical integration is fundamental for solving ordinary differential equations (ODEs) that don’t have analytical solutions. In this module, you’ll learn how to:\n\nFormulate ODEs in Python\nUse SciPy’s solve_ivp to numerically integrate ODEs\nVisualize solutions and explore parameter spaces\nApply these techniques to real-world models"
  },
  {
    "objectID": "modules/numerical-integration/index.html#session-1-1d-odes",
    "href": "modules/numerical-integration/index.html#session-1-1d-odes",
    "title": "Numerical Integration",
    "section": "2.1 Session 1: 1D ODEs",
    "text": "2.1 Session 1: 1D ODEs\n\nSIR Epidemic Model\nMichaelis–Menten Enzyme Kinetics\nSpruce Budworm Population Model"
  },
  {
    "objectID": "modules/numerical-integration/index.html#session-2-2d-odes",
    "href": "modules/numerical-integration/index.html#session-2-2d-odes",
    "title": "Numerical Integration",
    "section": "2.2 Session 2: 2D ODEs",
    "text": "2.2 Session 2: 2D ODEs\n\nCDIMA Reaction\nVan der Pol Oscillator\nFitzHugh–Nagumo Model"
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "Welcome to this hands-on session on mathematical modeling using ordinary differential equations (ODEs). Today, we will explore the spruce budworm model, a classic example from ecological modeling that demonstrates how simple nonlinear systems can exhibit complex behaviors including multiple equilibria and catastrophic transitions.\n\n\nBy the end of this session, you will be able to:\n\nUnderstand the mathematical formulation of the spruce budworm model.\nImplement the model as a Python function.\nSolve the ODE numerically using scipy.integrate.solve_ivp.\nVisualize the phase portrait and identify equilibrium points.\nBuild an interactive Streamlit application to explore the model.\n\n\n\n\nThe spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\]\nwhere:\n\n\\(x(t)\\) is the budworm population (adimensional).\n\\(r\\) is the intrinsic growth rate (typically \\(r \\approx 0.5\\)).\n\\(k\\) is the carrying capacity of the forest (typically \\(k \\approx 10\\)).\n\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#learning-objectives",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#learning-objectives",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "By the end of this session, you will be able to:\n\nUnderstand the mathematical formulation of the spruce budworm model.\nImplement the model as a Python function.\nSolve the ODE numerically using scipy.integrate.solve_ivp.\nVisualize the phase portrait and identify equilibrium points.\nBuild an interactive Streamlit application to explore the model.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#the-spruce-budworm-model",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#the-spruce-budworm-model",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "The spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\]\nwhere:\n\n\\(x(t)\\) is the budworm population (adimensional).\n\\(r\\) is the intrinsic growth rate (typically \\(r \\approx 0.5\\)).\n\\(k\\) is the carrying capacity of the forest (typically \\(k \\approx 10\\)).\n\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sidebar-controls",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sidebar-controls",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.1 Sidebar Controls",
    "text": "6.1 Sidebar Controls\nCreate sliders for:\n\nGrowth rate \\(r\\) (range: 0.0 to 1.0, default 0.5).\nCarrying capacity \\(k\\) (range: 0.1 to 10.0, default 10.0).\nInitial population: set automatically to \\(k/10\\) (the app uses \\(x_0 = k/10\\) by default).\nTime slider for evolution (range: 1 to 100, default 10).",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#interactive-features",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#interactive-features",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.2 Interactive Features",
    "text": "6.2 Interactive Features\n\nDisplay the differential equation with current parameter values.\nShow the phase portrait (rate of change plot), using your function from section Section 3.\nShow the time series evolution, using your function from section Section 5.\nAdd a button to “Evolve Forward” that continues the simulation, updating the plots.\nUse st.session_state to maintain simulation state between button clicks. You will need to store the time and population arrays in the session state, otherwise they will reset on each interaction.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#layout-structure",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#layout-structure",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.3 Layout Structure",
    "text": "6.3 Layout Structure\nimport streamlit as st\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom your_module import (\n    spruce_budworm,\n    plot_spruce_budworm_rate,\n    evolve_spruce_budworm,\n    plot_spruce_budworm,\n)  # Or paste your functions here\n\nst.title(\"Spruce Budworm Population Dynamics\")\n\n# Sidebar parameters (as in the app)\nr = st.sidebar.slider(\"Intrinsic growth rate (r)\", 0.0, 1.0, 0.5)\nk = st.sidebar.slider(\"Carrying capacity (k)\", 0.1, 10.0, 10.0)\n\n# The app sets the initial population to k/10 by default\nx0 = k / 10\n\n# Initialize session state\nif (\"sbw_x\" not in st.session_state):\n    st.session_state[\"sbw_t\"] = np.array([0])\n    st.session_state[\"sbw_x\"] = np.array([x0])\n\n# Time slider and control buttons\nt_eval = st.sidebar.slider(\"Time\", 1, 100, 10)\nbutton = st.sidebar.button(\"Evolve\")\n\n# Retrieve session data\nt = st.session_state[\"sbw_t\"]\nx = st.session_state[\"sbw_x\"]\n\n# Evolve if requested\nif button:\n    t, x = evolve_spruce_budworm(t, x, r=r, k=k, t_eval=t_eval)\n    st.session_state[\"sbw_t\"] = t\n    st.session_state[\"sbw_x\"] = x\n\n# Plot phase portrait and time series\nfig1, ax1 = plot_spruce_budworm_rate(x[-1], r=r, k=k)\nst.pyplot(fig1)\nfig2, ax2 = plot_spruce_budworm(t, x)\nst.pyplot(fig2)",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#advanced-features-optional",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#advanced-features-optional",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.4 Advanced Features (Optional)",
    "text": "6.4 Advanced Features (Optional)\n\nAdd a reset button to restart the simulation.\nShow multiple trajectories with different initial conditions.\nAdd animation of the population dynamics.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-slow-fast-dynamics",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-slow-fast-dynamics",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "7.1 Slow-Fast Dynamics",
    "text": "7.1 Slow-Fast Dynamics\nThe carrying capacity \\(k\\) can be interpreted as a slowly varying parameter in real ecosystems (e.g., due to seasonal changes or forest management). You can simulate this by gradually changing \\(k\\) over time in your app. This can lead to hysteresis effects, where the population does not return to its original state after \\(k\\) is restored. Experiment with this by modifying your Streamlit app to allow \\(k\\) to vary over time.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#equilibrium-analysis",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#equilibrium-analysis",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.1 Equilibrium Analysis",
    "text": "9.1 Equilibrium Analysis\nEquilibrium points satisfy:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) - \\frac{(x^*)^2}{1 + (x^*)^2} = 0\n\\]\nThis can be rewritten as:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) = \\frac{(x^*)^2}{1 + (x^*)^2}\n\\]\nThe left side represents birth rate (logistic growth), and the right side represents predation rate. Equilibria occur where these balance.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-stability-analysis",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-stability-analysis",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.2 Stability Analysis",
    "text": "9.2 Stability Analysis\nThe stability of an equilibrium \\(x^*\\) is determined by the sign of the derivative:\n\\[\n\\frac{d}{dx}\\left(\\frac{dx}{dt}\\right)\\bigg|_{x=x^*}\n\\]\nIf this derivative is:\n\nNegative: the equilibrium is stable (attracting).\nPositive: the equilibrium is unstable (repelling).\nZero: higher-order analysis is needed.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#ecological-interpretation",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#ecological-interpretation",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.3 Ecological Interpretation",
    "text": "9.3 Ecological Interpretation\n\nLow equilibrium: Few budworms, controlled by predation.\nHigh equilibrium: Outbreak state, budworms overwhelm predators.\nMiddle equilibrium: Usually unstable, separates the two basins of attraction.\nHysteresis: The system can “jump” between states depending on history.\n\nThis behavior explains why spruce budworm populations can suddenly explode from low levels to outbreak proportions, and why simply reducing the outbreak may not return the forest to a healthy state.",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 1: 1D ODEs",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-2d-cdima.html",
    "href": "modules/numerical-integration/ode-2d-cdima.html",
    "title": "Session 2: 2D Ordinary Differential Equations",
    "section": "",
    "text": "1 Introduction\nThe CDIMA model (Chlorine Dioxide–Iodine–Malonic Acid reaction) is a classic 2D chemical oscillator used to study phase-plane dynamics.\nThis page focuses on:\n\nintegrating a 2D system with solve_ivp\nplotting trajectories in the phase plane\ncomputing numerical nullclines using the shared helper compute_nullclines\n\n\n\n2 Model\nThe reference implementation lives in:\n\nsessions/s02_odes_2d/cdima.py\n\nand defines the vector field:\n\\[\n\\begin{aligned}\n\\dot x &= a - x - \\frac{4xy}{1+x^2},\\\\\n\\dot y &= bx\\left(1 - \\frac{y}{1+x^2}\\right).\n\\end{aligned}\n\\]\n\n\n3 Render-time Phase Plane\n\n\n\n\n\n\n\n\nFigure 1: CDIMA: trajectory in the phase plane with numerically approximated nullclines.\n\n\n\n\n\n\n\n4 Run the Interactive Version\nThe full interactive + animated version (with click-to-restart) is in the reference script:\npython sessions/s02_odes_2d/cdima.py",
    "crumbs": [
      "Home",
      "Module 1: Numerical Integration with Python",
      "Session 2: 2D ODEs",
      "CDIMA Reaction"
    ]
  }
]