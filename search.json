[
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "Welcome to this hands-on session on mathematical modeling using ordinary differential equations (ODEs). Today, we will explore the spruce budworm model, a classic example from ecological modeling that demonstrates how simple nonlinear systems can exhibit complex behaviors including multiple equilibria and catastrophic transitions.\n\n\nBy the end of this session, you will be able to:\n\nUnderstand the mathematical formulation of the spruce budworm model.\nImplement the model as a Python function.\nSolve the ODE numerically using scipy.integrate.solve_ivp.\nVisualize the phase portrait and identify equilibrium points.\nBuild an interactive Streamlit application to explore the model.\n\n\n\n\nThe spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\]\nwhere:\n\n\\(x(t)\\) is the budworm population (adimensional).\n\\(r\\) is the intrinsic growth rate (typically \\(r \\approx 0.5\\)).\n\\(k\\) is the carrying capacity of the forest (typically \\(k \\approx 10\\)).\n\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#learning-objectives",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#learning-objectives",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "By the end of this session, you will be able to:\n\nUnderstand the mathematical formulation of the spruce budworm model.\nImplement the model as a Python function.\nSolve the ODE numerically using scipy.integrate.solve_ivp.\nVisualize the phase portrait and identify equilibrium points.\nBuild an interactive Streamlit application to explore the model.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#the-spruce-budworm-model",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#the-spruce-budworm-model",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "",
    "text": "The spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\]\nwhere:\n\n\\(x(t)\\) is the budworm population (adimensional).\n\\(r\\) is the intrinsic growth rate (typically \\(r \\approx 0.5\\)).\n\\(k\\) is the carrying capacity of the forest (typically \\(k \\approx 10\\)).\n\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sidebar-controls",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sidebar-controls",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.1 Sidebar Controls",
    "text": "6.1 Sidebar Controls\nCreate sliders for:\n\nGrowth rate \\(r\\) (range: 0.0 to 1.0, default 0.5).\nCarrying capacity \\(k\\) (range: 0.1 to 10.0, default 10.0).\nInitial population: set automatically to \\(k/10\\) (the app uses \\(x_0 = k/10\\) by default).\nTime slider for evolution (range: 1 to 100, default 10).",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#interactive-features",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#interactive-features",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.2 Interactive Features",
    "text": "6.2 Interactive Features\n\nDisplay the differential equation with current parameter values.\nShow the phase portrait (rate of change plot), using your function from section Section 3.\nShow the time series evolution, using your function from section Section 5.\nAdd a button to “Evolve Forward” that continues the simulation, updating the plots.\nUse st.session_state to maintain simulation state between button clicks. You will need to store the time and population arrays in the session state, otherwise they will reset on each interaction.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#layout-structure",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#layout-structure",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.3 Layout Structure",
    "text": "6.3 Layout Structure\nimport streamlit as st\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom your_module import (\n    spruce_budworm,\n    plot_spruce_budworm_rate,\n    evolve_spruce_budworm,\n    plot_spruce_budworm,\n)  # Or paste your functions here\n\nst.title(\"Spruce Budworm Population Dynamics\")\n\n# Sidebar parameters (as in the app)\nr = st.sidebar.slider(\"Intrinsic growth rate (r)\", 0.0, 1.0, 0.5)\nk = st.sidebar.slider(\"Carrying capacity (k)\", 0.1, 10.0, 10.0)\n\n# The app sets the initial population to k/10 by default\nx0 = k / 10\n\n# Initialize session state\nif (\"sbw_x\" not in st.session_state):\n    st.session_state[\"sbw_t\"] = np.array([0])\n    st.session_state[\"sbw_x\"] = np.array([x0])\n\n# Time slider and control buttons\nt_eval = st.sidebar.slider(\"Time\", 1, 100, 10)\nbutton = st.sidebar.button(\"Evolve\")\n\n# Retrieve session data\nt = st.session_state[\"sbw_t\"]\nx = st.session_state[\"sbw_x\"]\n\n# Evolve if requested\nif button:\n    t, x = evolve_spruce_budworm(t, x, r=r, k=k, t_eval=t_eval)\n    st.session_state[\"sbw_t\"] = t\n    st.session_state[\"sbw_x\"] = x\n\n# Plot phase portrait and time series\nfig1, ax1 = plot_spruce_budworm_rate(x[-1], r=r, k=k)\nst.pyplot(fig1)\nfig2, ax2 = plot_spruce_budworm(t, x)\nst.pyplot(fig2)",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#advanced-features-optional",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#advanced-features-optional",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "6.4 Advanced Features (Optional)",
    "text": "6.4 Advanced Features (Optional)\n\nAdd a reset button to restart the simulation.\nShow multiple trajectories with different initial conditions.\nAdd animation of the population dynamics.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-slow-fast-dynamics",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-slow-fast-dynamics",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "7.1 Slow-Fast Dynamics",
    "text": "7.1 Slow-Fast Dynamics\nThe carrying capacity \\(k\\) can be interpreted as a slowly varying parameter in real ecosystems (e.g., due to seasonal changes or forest management). You can simulate this by gradually changing \\(k\\) over time in your app. This can lead to hysteresis effects, where the population does not return to its original state after \\(k\\) is restored. Experiment with this by modifying your Streamlit app to allow \\(k\\) to vary over time.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#equilibrium-analysis",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#equilibrium-analysis",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.1 Equilibrium Analysis",
    "text": "9.1 Equilibrium Analysis\nEquilibrium points satisfy:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) - \\frac{(x^*)^2}{1 + (x^*)^2} = 0\n\\]\nThis can be rewritten as:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) = \\frac{(x^*)^2}{1 + (x^*)^2}\n\\]\nThe left side represents birth rate (logistic growth), and the right side represents predation rate. Equilibria occur where these balance.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-stability-analysis",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#sec-stability-analysis",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.2 Stability Analysis",
    "text": "9.2 Stability Analysis\nThe stability of an equilibrium \\(x^*\\) is determined by the sign of the derivative:\n\\[\n\\frac{d}{dx}\\left(\\frac{dx}{dt}\\right)\\bigg|_{x=x^*}\n\\]\nIf this derivative is:\n\nNegative: the equilibrium is stable (attracting).\nPositive: the equilibrium is unstable (repelling).\nZero: higher-order analysis is needed.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "modules/numerical-integration/ode-1d-spruce-budworm.html#ecological-interpretation",
    "href": "modules/numerical-integration/ode-1d-spruce-budworm.html#ecological-interpretation",
    "title": "Session 1: 1D Ordinary Differential Equations",
    "section": "9.3 Ecological Interpretation",
    "text": "9.3 Ecological Interpretation\n\nLow equilibrium: Few budworms, controlled by predation.\nHigh equilibrium: Outbreak state, budworms overwhelm predators.\nMiddle equilibrium: Usually unstable, separates the two basins of attraction.\nHysteresis: The system can “jump” between states depending on history.\n\nThis behavior explains why spruce budworm populations can suddenly explode from low levels to outbreak proportions, and why simply reducing the outbreak may not return the forest to a healthy state.",
    "crumbs": [
      "Home",
      "Module 1 — Numerical Integration with Python",
      "Spruce Budworm Population Model"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-1-1d-odes-scipy-streamlit",
    "href": "syllabus.html#session-1-1d-odes-scipy-streamlit",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-2-2d-odes-nonlinear-oscillators",
    "href": "syllabus.html#session-2-2d-odes-nonlinear-oscillators",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Explore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-3-pdes-via-reactiondiffusion-systems",
    "href": "syllabus.html#session-3-pdes-via-reactiondiffusion-systems",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-4-coupled-odes-kuramoto-model",
    "href": "syllabus.html#session-4-coupled-odes-kuramoto-model",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Implement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-5-flocking-vicsek-model",
    "href": "syllabus.html#session-5-flocking-vicsek-model",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-6-networks-i-networkx-fundamentals",
    "href": "syllabus.html#session-6-networks-i-networkx-fundamentals",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-7-networks-ii-spreading-on-real-networks",
    "href": "syllabus.html#session-7-networks-ii-spreading-on-real-networks",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Simulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-8-cellular-automata-i-1d-ca",
    "href": "syllabus.html#session-8-cellular-automata-i-1d-ca",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Introduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-9-cellular-automata-ii-traffic-dynamics",
    "href": "syllabus.html#session-9-cellular-automata-ii-traffic-dynamics",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Apply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#session-10-final-project-support",
    "href": "syllabus.html#session-10-final-project-support",
    "title": "Applied Math Lab",
    "section": "",
    "text": "Wrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_structural_properties.html",
    "href": "sessions/s08_networks_complex/networkx_structural_properties.html",
    "title": "Network X - Structural Properties",
    "section": "",
    "text": "NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.\nThis notebook follows the “fundamentals” notebook and introduces the following concepts:\n\nClustering coefficient.\nNode centrality.\nRobustness of networks.\n\nThis tutorial is based on “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.. Please take a look at the folder references/networkx_indiana for more information.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\n\n\n\nThe clustering coefficient of a node is a measure of how well its neighbors are connected to each other. It is defined as:\n\\[\nC_i = \\frac{2e_i}{k_i(k_i - 1)}\n\\]\nwhere \\(e_i\\) is the number of edges between the neighbors of node \\(i\\), and \\(k_i\\) is the number of neighbors of node \\(i\\).\n\n# Initialize an empty graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n        (\"e\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Clustering coefficient of each node\nfor node in G.nodes():\n    print(f\"Clustering coefficient of '{node}': {nx.clustering(G, node)}\")\n\nClustering coefficient of 'a': 0.3333333333333333\nClustering coefficient of 'b': 1.0\nClustering coefficient of 'c': 0.6666666666666666\nClustering coefficient of 'd': 1.0\nClustering coefficient of 'e': 0\nClustering coefficient of 'x': 0.3333333333333333\nClustering coefficient of 'y': 1.0\nClustering coefficient of 'z': 1.0\n\n\nThe clustering coefficient of a graph is the average of the clustering coefficients of all its nodes.\n\n# Clustering coefficient of the whole graph\nprint(f\"Clustering coefficient of the graph: {nx.average_clustering(G)}\")\n\nClustering coefficient of the graph: 0.6666666666666667\n\n\nRelevance. The clustering coefficient is a measure of the extent to which a network is composed of tightly knit groups. It is a measure of the extent to which nodes tend to cluster together.\n\n\n\n\nThe degree centrality of a node is the fraction of nodes it is connected to. It is defined as:\n\\[\nC_D(i) = \\frac{k_i}{N - 1}\n\\]\nwhere \\(k_i\\) is the degree of node \\(i\\), and \\(N\\) is the total number of nodes in the graph.\n\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nd_centrality = nx.centrality.degree_centrality(G)\nd_centrality\n\n\n\n\n\n\n\n\n{'a': 0.5714285714285714,\n 'b': 0.2857142857142857,\n 'c': 0.42857142857142855,\n 'd': 0.2857142857142857,\n 'e': 0.2857142857142857,\n 'x': 0.42857142857142855,\n 'y': 0.2857142857142857,\n 'z': 0.2857142857142857}\n\n\nThe betweenness centrality of a node is the fraction of shortest paths between all pairs of nodes that pass through that node. It is defined as:\n\\[\nC_B(i) = \\sum_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}\n\\]\nwhere \\(\\sigma_{st}\\) is the total number of shortest paths between nodes \\(s\\) and \\(t\\), and \\(\\sigma_{st}(i)\\) is the number of those paths that pass through node \\(i\\).\n\nd_centrality = nx.centrality.betweenness_centrality(G)\nd_centrality\n\n{'a': 0.5952380952380952,\n 'b': 0.0,\n 'c': 0.023809523809523808,\n 'd': 0.0,\n 'e': 0.5714285714285714,\n 'x': 0.47619047619047616,\n 'y': 0.0,\n 'z': 0.0}\n\n\nIt is informative to plot the distribution of centrality values across all nodes in the graph.\n\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\nRelevance. Centrality measures are used to identify the most important nodes in a network. They are used to identify the most influential nodes in a network, the nodes that are most likely to spread information or disease, etc.\n\n\n\n\nLook at the Enron executive email graph.\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Basic information about the graph\nprint(G)\n\n# Visualize the graph\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\nExercise. Who are the most central nodes in the network according to degree centrality? Who are the most central nodes according to betweenness centrality? Plot the distribution of degree and betweenness centralities across all nodes.\nExercise. Are there communities of employees who mostly communicate with each other? If so, who are the most central employees in each community?\n\n# We can use Girvan-Newman algorithm to detect communities in a graph\n# This algorithm is based on edge betweenness\n# The algorithm returns an iterator over partitions of the graph\ngen_partitions = nx.community.girvan_newman(G)\n# Each partition is a tuple of sets of nodes\ncluster_partition = next(gen_partitions)\n\npos = nx.layout.spring_layout(G)\nnode_colors = []\nfor node in G.nodes():\n    for color, cluster in enumerate(cluster_partition):\n        if node in cluster:\n            node_colors.append(color)\n            break\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Predicted communities\")\nplt.show()\n\n# We can use modularity to evaluate the quality of the partition\n# A value of 0 means that the partition is random\n# A value of 1 means that the partition is perfect\nquality = nx.community.quality.modularity(G, cluster_partition)\nprint(\"Modularity:\", quality)\n\n\n\n\n\n\n\n\nModularity: 0.08203973421207882\n\n\nExercise. Does the network show a small-world or scale-free structure?\n\n\n\n\nTo test the robustness of a network, we can remove nodes or edges and see how the network changes. We can measure the size of the largest connected component as we remove nodes or edges.\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Basic information about the graph\nprint(G)\n\n# Visualize the graph\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\n\n\nTo simulate random failure, we remove nodes or edges at random. Every time we remove a node or edge, we measure the size of the largest connected component.\n\n# Store the original number of nodes\nnum_nodes = G.number_of_nodes()\n# Minimum number of nodes to keep\nmin_num_nodes = num_nodes // 2\n# Nodes to remove each time\nnum_nodes_to_remove = 2\n\n# Make a copy of the graph\nC: nx.Graph = G.copy()\n\n# Initialize a list to store the relative size of the core\nrandom_attack_core_proportions = []\nrandom_attack_nodes_removed = []\n\n# Remove nodes one by one\nwhile C.number_of_nodes() &gt; min_num_nodes:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / num_nodes\n    random_attack_core_proportions.append(core_proportion)\n    random_attack_nodes_removed.append(num_nodes - C.number_of_nodes())\n    # Remove one random node\n    nodes_to_remove = random.sample(list(C.nodes), num_nodes_to_remove)\n    C.remove_nodes_from(nodes_to_remove)\n\nplt.title(\"Random failure\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(random_attack_nodes_removed, random_attack_core_proportions, marker=\"o\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nDuring a targeted attack, we remove nodes or edges in order of decreasing centrality. Every time we remove a node or edge, we measure the size of the largest connected component.\n\n# Store the original number of nodes\nnum_nodes = G.number_of_nodes()\n# Minimum number of nodes to keep\nmin_num_nodes = num_nodes // 2\n# Nodes to remove each time\nnum_nodes_to_remove = 2\n\n# Make a copy of the graph\nC: nx.Graph = G.copy()\n\n# Initialize a list to store the relative size of the core\ntargeted_attack_core_proportions = []\ntargeted_attack_nodes_removed = []\n\n# Remove nodes one by one\nwhile C.number_of_nodes() &gt; min_num_nodes:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / num_nodes\n    targeted_attack_core_proportions.append(core_proportion)\n    targeted_attack_nodes_removed.append(num_nodes - C.number_of_nodes())\n    # Remove nodes with the highest degree\n    # First, we sort the nodes by their degree\n    nodes_to_remove = sorted(C.degree, key=lambda x: x[1], reverse=True)\n    # Then, we remove the first N nodes\n    nodes_to_remove = nodes_to_remove[:num_nodes_to_remove]\n    C.remove_nodes_from([node for node, _ in nodes_to_remove])\n\nplt.title(\"Targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(targeted_attack_nodes_removed, targeted_attack_core_proportions, marker=\"o\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n# Compare the two strategies\nplt.title(\"Core size comparison\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(\n    random_attack_nodes_removed,\n    random_attack_core_proportions,\n    label=\"Random attack\",\n    marker=\"o\",\n    markersize=5,\n)\nplt.plot(\n    targeted_attack_nodes_removed,\n    targeted_attack_core_proportions,\n    label=\"Targeted attack\",\n    marker=\"o\",\n    markersize=4,\n)\nplt.legend()\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_structural_properties.html#clustering-coefficient",
    "href": "sessions/s08_networks_complex/networkx_structural_properties.html#clustering-coefficient",
    "title": "Network X - Structural Properties",
    "section": "",
    "text": "The clustering coefficient of a node is a measure of how well its neighbors are connected to each other. It is defined as:\n\\[\nC_i = \\frac{2e_i}{k_i(k_i - 1)}\n\\]\nwhere \\(e_i\\) is the number of edges between the neighbors of node \\(i\\), and \\(k_i\\) is the number of neighbors of node \\(i\\).\n\n# Initialize an empty graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n        (\"e\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Clustering coefficient of each node\nfor node in G.nodes():\n    print(f\"Clustering coefficient of '{node}': {nx.clustering(G, node)}\")\n\nClustering coefficient of 'a': 0.3333333333333333\nClustering coefficient of 'b': 1.0\nClustering coefficient of 'c': 0.6666666666666666\nClustering coefficient of 'd': 1.0\nClustering coefficient of 'e': 0\nClustering coefficient of 'x': 0.3333333333333333\nClustering coefficient of 'y': 1.0\nClustering coefficient of 'z': 1.0\n\n\nThe clustering coefficient of a graph is the average of the clustering coefficients of all its nodes.\n\n# Clustering coefficient of the whole graph\nprint(f\"Clustering coefficient of the graph: {nx.average_clustering(G)}\")\n\nClustering coefficient of the graph: 0.6666666666666667\n\n\nRelevance. The clustering coefficient is a measure of the extent to which a network is composed of tightly knit groups. It is a measure of the extent to which nodes tend to cluster together."
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_structural_properties.html#centrality",
    "href": "sessions/s08_networks_complex/networkx_structural_properties.html#centrality",
    "title": "Network X - Structural Properties",
    "section": "",
    "text": "The degree centrality of a node is the fraction of nodes it is connected to. It is defined as:\n\\[\nC_D(i) = \\frac{k_i}{N - 1}\n\\]\nwhere \\(k_i\\) is the degree of node \\(i\\), and \\(N\\) is the total number of nodes in the graph.\n\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nd_centrality = nx.centrality.degree_centrality(G)\nd_centrality\n\n\n\n\n\n\n\n\n{'a': 0.5714285714285714,\n 'b': 0.2857142857142857,\n 'c': 0.42857142857142855,\n 'd': 0.2857142857142857,\n 'e': 0.2857142857142857,\n 'x': 0.42857142857142855,\n 'y': 0.2857142857142857,\n 'z': 0.2857142857142857}\n\n\nThe betweenness centrality of a node is the fraction of shortest paths between all pairs of nodes that pass through that node. It is defined as:\n\\[\nC_B(i) = \\sum_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}\n\\]\nwhere \\(\\sigma_{st}\\) is the total number of shortest paths between nodes \\(s\\) and \\(t\\), and \\(\\sigma_{st}(i)\\) is the number of those paths that pass through node \\(i\\).\n\nd_centrality = nx.centrality.betweenness_centrality(G)\nd_centrality\n\n{'a': 0.5952380952380952,\n 'b': 0.0,\n 'c': 0.023809523809523808,\n 'd': 0.0,\n 'e': 0.5714285714285714,\n 'x': 0.47619047619047616,\n 'y': 0.0,\n 'z': 0.0}\n\n\nIt is informative to plot the distribution of centrality values across all nodes in the graph.\n\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\nRelevance. Centrality measures are used to identify the most important nodes in a network. They are used to identify the most influential nodes in a network, the nodes that are most likely to spread information or disease, etc."
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_structural_properties.html#exercise-enron-email-network",
    "href": "sessions/s08_networks_complex/networkx_structural_properties.html#exercise-enron-email-network",
    "title": "Network X - Structural Properties",
    "section": "",
    "text": "Look at the Enron executive email graph.\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Basic information about the graph\nprint(G)\n\n# Visualize the graph\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\nExercise. Who are the most central nodes in the network according to degree centrality? Who are the most central nodes according to betweenness centrality? Plot the distribution of degree and betweenness centralities across all nodes.\nExercise. Are there communities of employees who mostly communicate with each other? If so, who are the most central employees in each community?\n\n# We can use Girvan-Newman algorithm to detect communities in a graph\n# This algorithm is based on edge betweenness\n# The algorithm returns an iterator over partitions of the graph\ngen_partitions = nx.community.girvan_newman(G)\n# Each partition is a tuple of sets of nodes\ncluster_partition = next(gen_partitions)\n\npos = nx.layout.spring_layout(G)\nnode_colors = []\nfor node in G.nodes():\n    for color, cluster in enumerate(cluster_partition):\n        if node in cluster:\n            node_colors.append(color)\n            break\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Predicted communities\")\nplt.show()\n\n# We can use modularity to evaluate the quality of the partition\n# A value of 0 means that the partition is random\n# A value of 1 means that the partition is perfect\nquality = nx.community.quality.modularity(G, cluster_partition)\nprint(\"Modularity:\", quality)\n\n\n\n\n\n\n\n\nModularity: 0.08203973421207882\n\n\nExercise. Does the network show a small-world or scale-free structure?"
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_structural_properties.html#robustness",
    "href": "sessions/s08_networks_complex/networkx_structural_properties.html#robustness",
    "title": "Network X - Structural Properties",
    "section": "",
    "text": "To test the robustness of a network, we can remove nodes or edges and see how the network changes. We can measure the size of the largest connected component as we remove nodes or edges.\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Basic information about the graph\nprint(G)\n\n# Visualize the graph\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\n\n\nTo simulate random failure, we remove nodes or edges at random. Every time we remove a node or edge, we measure the size of the largest connected component.\n\n# Store the original number of nodes\nnum_nodes = G.number_of_nodes()\n# Minimum number of nodes to keep\nmin_num_nodes = num_nodes // 2\n# Nodes to remove each time\nnum_nodes_to_remove = 2\n\n# Make a copy of the graph\nC: nx.Graph = G.copy()\n\n# Initialize a list to store the relative size of the core\nrandom_attack_core_proportions = []\nrandom_attack_nodes_removed = []\n\n# Remove nodes one by one\nwhile C.number_of_nodes() &gt; min_num_nodes:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / num_nodes\n    random_attack_core_proportions.append(core_proportion)\n    random_attack_nodes_removed.append(num_nodes - C.number_of_nodes())\n    # Remove one random node\n    nodes_to_remove = random.sample(list(C.nodes), num_nodes_to_remove)\n    C.remove_nodes_from(nodes_to_remove)\n\nplt.title(\"Random failure\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(random_attack_nodes_removed, random_attack_core_proportions, marker=\"o\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nDuring a targeted attack, we remove nodes or edges in order of decreasing centrality. Every time we remove a node or edge, we measure the size of the largest connected component.\n\n# Store the original number of nodes\nnum_nodes = G.number_of_nodes()\n# Minimum number of nodes to keep\nmin_num_nodes = num_nodes // 2\n# Nodes to remove each time\nnum_nodes_to_remove = 2\n\n# Make a copy of the graph\nC: nx.Graph = G.copy()\n\n# Initialize a list to store the relative size of the core\ntargeted_attack_core_proportions = []\ntargeted_attack_nodes_removed = []\n\n# Remove nodes one by one\nwhile C.number_of_nodes() &gt; min_num_nodes:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / num_nodes\n    targeted_attack_core_proportions.append(core_proportion)\n    targeted_attack_nodes_removed.append(num_nodes - C.number_of_nodes())\n    # Remove nodes with the highest degree\n    # First, we sort the nodes by their degree\n    nodes_to_remove = sorted(C.degree, key=lambda x: x[1], reverse=True)\n    # Then, we remove the first N nodes\n    nodes_to_remove = nodes_to_remove[:num_nodes_to_remove]\n    C.remove_nodes_from([node for node, _ in nodes_to_remove])\n\nplt.title(\"Targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(targeted_attack_nodes_removed, targeted_attack_core_proportions, marker=\"o\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n# Compare the two strategies\nplt.title(\"Core size comparison\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(\n    random_attack_nodes_removed,\n    random_attack_core_proportions,\n    label=\"Random attack\",\n    marker=\"o\",\n    markersize=5,\n)\nplt.plot(\n    targeted_attack_nodes_removed,\n    targeted_attack_core_proportions,\n    label=\"Targeted attack\",\n    marker=\"o\",\n    markersize=4,\n)\nplt.legend()\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s07_networks/networkx_models.html",
    "href": "sessions/s07_networks/networkx_models.html",
    "title": "NetworkX - Graph Models",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nContents:\n\nRandom network model\nSmall-World model\nPreferential attachment model\n\nFor each of the models presented in this tutorial, we present the algorithm, and the corresponding NetworkX code function to generate the model.\nNote: This notebook assumes you know the basics of Network X, that were shown in the “fundamentals” notebook. It will also use concepts from the “structural properties” notebook.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\nThe random network model, as formulated by Gilbert, has two parameters: the number of nodes \\(N\\), and the link probability \\(p\\). As in the book text, the algorithm for creating this network is as follows:\n\nSelect a pair of nodes, say i and j.\nGenerate a random number r between 0 and 1. If r &lt; p, then add a link between i and j.\nRepeat (1) and (2) for all pairs of nodes.\n\n\n# Gilbert random graph with n nodes and probability p of edge creation\nG_random = nx.gnp_random_graph(n=16, p=0.3)\n\nnx.draw(G_random, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_random))\nprint(\"Number of connected components:\", nx.number_connected_components(G_random))\nif nx.is_connected(G_random):\n    print(\"Average shortest path length:\", nx.average_shortest_path_length(G_random))\nelse:\n    print(\"Graph is not connected\")\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_random))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 1.775\nAverage clustering coefficient: 0.2418154761904762\n\n\nThe betweeness centrality of random networks is uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a random network is given by \\(\\langle k \\rangle = p(N-1)\\).\n\n# Plot the centrality distribution\nd_centrality = nx.degree_centrality(G_random)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_random.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nInstead of specifying the link probability \\(p\\), we can also generate a graph of \\(N\\) nodes with exactly \\(M\\) edges by using random.sample() to choose M of the possible edges generated with itertools.combinations():\n\n# Erdos-Renyi graph with n nodes and m edges\nG_ER = nx.gnm_random_graph(n=16, m=20)\n\nnx.draw(G_ER, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_ER))\nprint(\"Number of connected components:\", nx.number_connected_components(G_ER))\nif nx.is_connected(G_ER):\n    print(\"Average shortest path length:\", nx.average_shortest_path_length(G_ER))\nelse:\n    print(\"Graph is not connected\")\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_ER))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.6333333333333333\nAverage clustering coefficient: 0.11666666666666667\n\n\nThe betweeness centrality of random networks is uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a random network is given by \\(\\langle k \\rangle = p(N-1)\\).\n\nd_centrality = nx.degree_centrality(G_ER)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_ER.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe algorithm for generating a small-world network is as such:\n\nBegin with a ring of \\(N\\) nodes\nConnect each node to its \\(k\\) nearest neighbors (or \\(k-1\\) if k is odd).\nFor each edge \\((u, v)\\), with probability \\(p\\), replace edge \\((u, v)\\) with \\((u, w)\\) where \\(w\\) is not a neighbor of \\(u\\).\n\n\n# Watts-Strogatz small-world graph with n nodes, k neighbors, and probability p of rewiring\nG_SW = nx.watts_strogatz_graph(n=16, k=4, p=0.2)\n\nnx.draw(G_SW, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_SW))\nprint(\"Number of connected components:\", nx.number_connected_components(G_SW))\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G_SW))\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_SW))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.0166666666666666\nAverage clustering coefficient: 0.31250000000000006\n\n\nThe betweeness centrality of small-world networks is also uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a small-world network is given by \\(\\langle k \\rangle = 2k\\).\n\nd_centrality = nx.degree_centrality(G_SW)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_SW.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\nThe Barabási-Albert preferential attachment model has two parameters: the number of nodes \\(N\\), and the number of links added at each step \\(m\\). Given these parameters, the algorithm is as follows:\n\nStart with a clique of \\(m + 1\\) nodes.\nSelect \\(m\\) different nodes at random, weighted by their degree.\nAdd a new node \\(i\\) and link it with the \\(m\\) nodes from the previous step.\nRepeat 2-3 until there are N nodes in the graph.\n\n\n# Barabasi-Albert preferential attachment graph with n nodes and m edges\nG_BA = nx.barabasi_albert_graph(n=16, m=2)\n\nnx.draw(G_BA, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_BA))\nprint(\"Number of connected components:\", nx.number_connected_components(G_BA))\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G_BA))\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_BA))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.0166666666666666\nAverage clustering coefficient: 0.3369047619047619\n\n\n\nd_centrality = nx.degree_centrality(G_BA)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()"
  },
  {
    "objectID": "sessions/s07_networks/networkx_models.html#random-network-model",
    "href": "sessions/s07_networks/networkx_models.html#random-network-model",
    "title": "NetworkX - Graph Models",
    "section": "",
    "text": "The random network model, as formulated by Gilbert, has two parameters: the number of nodes \\(N\\), and the link probability \\(p\\). As in the book text, the algorithm for creating this network is as follows:\n\nSelect a pair of nodes, say i and j.\nGenerate a random number r between 0 and 1. If r &lt; p, then add a link between i and j.\nRepeat (1) and (2) for all pairs of nodes.\n\n\n# Gilbert random graph with n nodes and probability p of edge creation\nG_random = nx.gnp_random_graph(n=16, p=0.3)\n\nnx.draw(G_random, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_random))\nprint(\"Number of connected components:\", nx.number_connected_components(G_random))\nif nx.is_connected(G_random):\n    print(\"Average shortest path length:\", nx.average_shortest_path_length(G_random))\nelse:\n    print(\"Graph is not connected\")\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_random))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 1.775\nAverage clustering coefficient: 0.2418154761904762\n\n\nThe betweeness centrality of random networks is uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a random network is given by \\(\\langle k \\rangle = p(N-1)\\).\n\n# Plot the centrality distribution\nd_centrality = nx.degree_centrality(G_random)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_random.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nInstead of specifying the link probability \\(p\\), we can also generate a graph of \\(N\\) nodes with exactly \\(M\\) edges by using random.sample() to choose M of the possible edges generated with itertools.combinations():\n\n# Erdos-Renyi graph with n nodes and m edges\nG_ER = nx.gnm_random_graph(n=16, m=20)\n\nnx.draw(G_ER, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_ER))\nprint(\"Number of connected components:\", nx.number_connected_components(G_ER))\nif nx.is_connected(G_ER):\n    print(\"Average shortest path length:\", nx.average_shortest_path_length(G_ER))\nelse:\n    print(\"Graph is not connected\")\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_ER))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.6333333333333333\nAverage clustering coefficient: 0.11666666666666667\n\n\nThe betweeness centrality of random networks is uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a random network is given by \\(\\langle k \\rangle = p(N-1)\\).\n\nd_centrality = nx.degree_centrality(G_ER)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_ER.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()"
  },
  {
    "objectID": "sessions/s07_networks/networkx_models.html#small-world-model",
    "href": "sessions/s07_networks/networkx_models.html#small-world-model",
    "title": "NetworkX - Graph Models",
    "section": "",
    "text": "The algorithm for generating a small-world network is as such:\n\nBegin with a ring of \\(N\\) nodes\nConnect each node to its \\(k\\) nearest neighbors (or \\(k-1\\) if k is odd).\nFor each edge \\((u, v)\\), with probability \\(p\\), replace edge \\((u, v)\\) with \\((u, w)\\) where \\(w\\) is not a neighbor of \\(u\\).\n\n\n# Watts-Strogatz small-world graph with n nodes, k neighbors, and probability p of rewiring\nG_SW = nx.watts_strogatz_graph(n=16, k=4, p=0.2)\n\nnx.draw(G_SW, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_SW))\nprint(\"Number of connected components:\", nx.number_connected_components(G_SW))\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G_SW))\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_SW))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.0166666666666666\nAverage clustering coefficient: 0.31250000000000006\n\n\nThe betweeness centrality of small-world networks is also uniformly distributed, and the degree distribution follows a Poisson distribution. The average degree of a small-world network is given by \\(\\langle k \\rangle = 2k\\).\n\nd_centrality = nx.degree_centrality(G_SW)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# Plot the degree distribution\nd_degree = dict(G_SW.degree())\nls_degrees = list(d_degree.values())\nplt.hist(ls_degrees, bins=10)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Number of nodes\")\nplt.show()"
  },
  {
    "objectID": "sessions/s07_networks/networkx_models.html#preferential-attachment-model",
    "href": "sessions/s07_networks/networkx_models.html#preferential-attachment-model",
    "title": "NetworkX - Graph Models",
    "section": "",
    "text": "The Barabási-Albert preferential attachment model has two parameters: the number of nodes \\(N\\), and the number of links added at each step \\(m\\). Given these parameters, the algorithm is as follows:\n\nStart with a clique of \\(m + 1\\) nodes.\nSelect \\(m\\) different nodes at random, weighted by their degree.\nAdd a new node \\(i\\) and link it with the \\(m\\) nodes from the previous step.\nRepeat 2-3 until there are N nodes in the graph.\n\n\n# Barabasi-Albert preferential attachment graph with n nodes and m edges\nG_BA = nx.barabasi_albert_graph(n=16, m=2)\n\nnx.draw(G_BA, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\nprint(\"Is connected?\", nx.is_connected(G_BA))\nprint(\"Number of connected components:\", nx.number_connected_components(G_BA))\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G_BA))\nprint(\"Average clustering coefficient:\", nx.average_clustering(G_BA))\n\nIs connected? True\nNumber of connected components: 1\nAverage shortest path length: 2.0166666666666666\nAverage clustering coefficient: 0.3369047619047619\n\n\n\nd_centrality = nx.degree_centrality(G_BA)\nls_centralities = list(d_centrality.values())\nplt.hist(ls_centralities, bins=10, range=(0, 1))\nplt.xlabel(\"Degree centrality\")\nplt.ylabel(\"Number of nodes\")\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Math Modeling (Python)",
    "section": "",
    "text": "Welcome! This site collects the notes, code, and datasets for the Applied Math Lab.",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#create-an-environment",
    "href": "index.html#create-an-environment",
    "title": "Applied Math Modeling (Python)",
    "section": "4.1 Create an environment",
    "text": "4.1 Create an environment\nIf you use Conda:\nconda create --name amlab python=3.13\nconda activate amlab\nconda install --yes --file requirements.txt\nIf you prefer pip:\nWindows (PowerShell):\npython -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\npip install -r requirements.txt\nmacOS/Linux:\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#run-the-streamlit-app",
    "href": "index.html#run-the-streamlit-app",
    "title": "Applied Math Modeling (Python)",
    "section": "4.2 Run the Streamlit app",
    "text": "4.2 Run the Streamlit app\nstreamlit run ./streamlit/home.py",
    "crumbs": [
      "Home",
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "references/networkx_kaggle/3-networkx-basic-concepts.html",
    "href": "references/networkx_kaggle/3-networkx-basic-concepts.html",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\n\n\n\n\ngraph_karate = nx.karate_club_graph()\n\nnx.draw(graph_karate, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe degree of a node in a network is the number of edges that it is connected to. In a network with \\(N\\) nodes and \\(M\\) edges, the degree \\(k_i\\) of a node \\(i\\) is defined as:\n\\[ k*i = \\sum*{j=1}^M A\\_{ij} \\]\nwhere \\(A\\) is the adjacency matrix of the network, with \\(A_{ij} = 1\\) if there is an edge connecting nodes \\(i\\) and \\(j\\), and \\(A_{ij} = 0\\) otherwise.\nThe neighborhood of a node \\(i\\) is the set of nodes that are directly connected to \\(i\\) by an edge. The neighborhood of \\(i\\) is denoted as \\(N_i\\) and is defined as:\n\\[ N*i = \\{j \\mid A*{ij} = 1\\} \\]\nwhere \\(A\\) is the adjacency matrix of the network, with \\(A_{ij} = 1\\) if there is an edge connecting nodes \\(i\\) and \\(j\\), and \\(A_{ij} = 0\\) otherwise.\n\nnode = 2\nneighborhood = list(nx.neighbors(graph_karate, node))\nneighborhood\n\n[0, 1, 3, 7, 8, 9, 13, 27, 28, 32]\n\n\n\n# degree = # neighbor\nlen(neighborhood)\n\n10\n\n\n\n# Degree\ngraph_karate.degree(node)\n\n10\n\n\n\n# All degrees\ndict(graph_karate.degree)\n\n{0: 16,\n 1: 9,\n 2: 10,\n 3: 6,\n 4: 3,\n 5: 4,\n 6: 4,\n 7: 4,\n 8: 5,\n 9: 2,\n 10: 3,\n 11: 1,\n 12: 2,\n 13: 5,\n 14: 2,\n 15: 2,\n 16: 2,\n 17: 2,\n 18: 2,\n 19: 3,\n 20: 2,\n 21: 2,\n 22: 2,\n 23: 5,\n 24: 3,\n 25: 3,\n 26: 2,\n 27: 4,\n 28: 3,\n 29: 4,\n 30: 4,\n 31: 6,\n 32: 12,\n 33: 17}\n\n\n\n\n\nTriadic closure refers to the tendency for people who share connections in a social network to become connected, also known as the “friend of a friend” effect.\nOne measure of triadic closure in a network is the clustering coefficient, which quantifies the degree to which nodes tend to cluster together in triads. The clustering coefficient of a node is defined as the fraction of the node’s neighbors that are also neighbors of each other. The clustering coefficient of a network is the average clustering coefficient over all nodes in the network.\n\n\nThe clustering coefficient of a node \\(i\\) is given by:\n\\[C_i = \\frac{2e_i}{k_i(k_i-1)}\\]\nwhere \\(e_i\\) is the number of edges between the neighbors of node \\(i\\), and \\(k_i\\) is the degree of node \\(i\\) (i.e., the number of edges incident to \\(i\\)).\n\nnx.draw_networkx(graph_karate)\n\n\n\n\n\n\n\n\n\n# local clustring (if dominator is zero =&gt; zero)\nnx.clustering(graph_karate, 2)\n\n0.24444444444444444\n\n\n\n# list of Clustring Coefficients\nnx.clustering(graph_karate)\n\n{0: 0.15,\n 1: 0.3333333333333333,\n 2: 0.24444444444444444,\n 3: 0.6666666666666666,\n 4: 0.6666666666666666,\n 5: 0.5,\n 6: 0.5,\n 7: 1.0,\n 8: 0.5,\n 9: 0,\n 10: 0.6666666666666666,\n 11: 0,\n 12: 1.0,\n 13: 0.6,\n 14: 1.0,\n 15: 1.0,\n 16: 1.0,\n 17: 1.0,\n 18: 1.0,\n 19: 0.3333333333333333,\n 20: 1.0,\n 21: 1.0,\n 22: 1.0,\n 23: 0.4,\n 24: 0.3333333333333333,\n 25: 0.3333333333333333,\n 26: 1.0,\n 27: 0.16666666666666666,\n 28: 0.3333333333333333,\n 29: 0.6666666666666666,\n 30: 0.5,\n 31: 0.2,\n 32: 0.19696969696969696,\n 33: 0.11029411764705882}\n\n\n\n\nMany observed social networks are more clustered than would arise at random\nThe clustering coefficient of the network is the average of the clustering coefficients of all nodes:\n\\[C = \\frac{1}{N}\\sum_{i=1}^{N} C_i\\]\nwhere \\(N\\) is the total number of nodes in the network.\n\n# Average clustering\nnx.average_clustering(graph_karate)\n\n0.5706384782076823\n\n\n\n\n\n\nTransitivity is a property of a network that measures the likelihood that, if two nodes in the network share a common neighbor, they will also be directly connected to each other. In other words, it measures the tendency for “triangles” to form in the network.\nFormally, the transitivity of a network is defined as the ratio of the number of triangles in the network to the number of connected triples of nodes (i.e., triples of nodes that are directly connected to each other or share a common neighbor). In mathematical notation, the transitivity of a network is given by:\n\\[\nT = \\frac{3 \\times \\text{number of triangles}}{\\text{number of connected triples}}\n\\]\nA high transitivity indicates that nodes in the network tend to form clusters or communities, while a low transitivity indicates that the network is more of a random or decentralized structure. Transitivity is closely related to the concept of clustering coefficient, which measures the tendency for nodes to form local clusters or neighborhoods.\n\n# transitivity\n# transitivity weights nodes with large degree higher\nnx.transitivity(graph_karate)\n\n0.2556818181818182\n\n\n\n\n\n\nA path between two nodes \\(A\\) and \\(B\\) in a network is a sequence of nodes \\(A, X_1, X_2, ..., X_n, B\\) and a sequence of edges \\((A, X_1), (X_1, X_2), ..., (X_n, B)\\), where each node and edge in the sequence is adjacent to the previous and next node or edge in the sequence.\nThe length of a path is the number of edges in the path. A path with length 1 is an edge between two nodes, while a path with length 2 is a sequence of two edges and three nodes, and so on. The shortest path between two nodes is the path with the minimum length that connects them.\n\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\n\n# Generate all simple paths between nodes 1 and 3\npaths = nx.all_simple_paths(graph_karate, source=1, target=3)\n\n# Print the first 10 simple paths\nfor _ in range(10):\n    print(next(paths))\n\n[1, 0, 2, 3]\n[1, 0, 2, 7, 3]\n[1, 0, 2, 8, 30, 32, 14, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 15, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 18, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 20, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 22, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3]\n\n\n\npath1 = next(paths)\n# check if a path is valid in the graph\nis_valid = nx.is_simple_path(\n    graph_karate, path1\n)  # A simple path is a path that does not contain any repeated nodes.\nprint(\"Is valid path?\", is_valid)\n\nIs valid path? True\n\n\n\n# a False example\nnx.is_simple_path(graph_karate, [0, 8, 5])\n\nFalse\n\n\n\n# compute the edge list of a walk\nedge_list = [\n    (path1[i], path1[i + 1]) for i in range(len(path1) - 1)\n]  # len(Path1)-1=length of a path\nedge_list\n\n[(1, 0),\n (0, 2),\n (2, 8),\n (8, 30),\n (30, 32),\n (32, 23),\n (23, 25),\n (25, 31),\n (31, 24),\n (24, 27),\n (27, 33),\n (33, 13),\n (13, 3)]\n\n\n\n# compute the weight of a walk\nweight = sum(\n    graph_karate[u][v][\"weight\"] for u, v in edge_list if \"weight\" in graph_karate[u][v]\n)\nprint(\"Weight of walk:\", weight)\n\nWeight of walk: 52\n\n\n\n\n\n\n# Find all cycles in the graph\ncycles = nx.simple_cycles(graph_karate)\nlist(cycles)\n\n[[0, 4, 6],\n [0, 4, 6, 5],\n [0, 4, 6, 5, 10],\n [0, 4, 6, 16, 5],\n [0, 4, 6, 16, 5, 10],\n [0, 4, 10],\n [0, 4, 10, 5],\n [0, 4, 10, 5, 6],\n [0, 4, 10, 5, 16, 6],\n [0, 5, 6],\n [0, 5, 6, 4, 10],\n [0, 5, 10],\n [0, 5, 10, 4, 6],\n [0, 5, 16, 6],\n [0, 5, 16, 6, 4, 10],\n [0, 6, 4, 10],\n [0, 6, 5, 10],\n [0, 6, 16, 5, 10],\n [4, 6, 5, 10],\n [4, 6, 16, 5, 10],\n [16, 5, 6],\n [0, 1, 2],\n [0, 1, 2, 3],\n [0, 1, 2, 3, 7],\n [0, 1, 2, 3, 12],\n [0, 1, 2, 3, 13],\n [0, 1, 2, 3, 13, 33, 8],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 8],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 14, 32, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 8],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 15, 32, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 8],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 18, 32, 31],\n [0, 1, 2, 3, 13, 33, 19],\n [0, 1, 2, 3, 13, 33, 20, 32, 8],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 20, 32, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 8],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 22, 32, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 30, 8],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 8],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 31],\n [0, 1, 2, 3, 13, 33, 31],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 32, 8],\n [0, 1, 2, 3, 13, 33, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 32, 31],\n [0, 1, 2, 7],\n [0, 1, 2, 7, 3],\n [0, 1, 2, 7, 3, 12],\n [0, 1, 2, 7, 3, 13],\n [0, 1, 2, 7, 3, 13, 33, 8],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 19],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 31],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 31],\n [0, 1, 2, 8],\n [0, 1, 2, 8, 30, 32, 14, 33, 13],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 14, 33, 19],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 13],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 15, 33, 19],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 13],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 18, 33, 19],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 13],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 20, 33, 19],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 13],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 22, 33, 19],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 31],\n [0, 1, 2, 8, 30, 32, 31],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 33, 13],\n [0, 1, 2, 8, 30, 32, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 33, 19],\n [0, 1, 2, 8, 30, 32, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 31],\n [0, 1, 2, 8, 30, 33, 13],\n [0, 1, 2, 8, 30, 33, 13, 3],\n [0, 1, 2, 8, 30, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 31],\n [0, 1, 2, 8, 30, 33, 19],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 31],\n [0, 1, 2, 8, 30, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 28, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 32, 31],\n ...]\n\n\n\n\n\nA geodesic between two nodes \\(A\\) and \\(B\\) in a network is the shortest path that connects them. In other words, it is the path with the minimum number of edges that must be traversed to get from node \\(A\\) to node \\(B\\). The length of a geodesic is the number of edges in the path.\n\n# graph_karateeodesic = shortest path\nnx.shortest_path(graph_karate, 1, 2)\n\n[1, 2]\n\n\n\n# compute a shortest path between two nodes\npath = nx.shortest_path(graph_karate, source=1, target=3)\n\n# compute the corresponding edges of the path\nedges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n\n# draw the graph and the path\npos = nx.circular_layout(graph_karate)\nnx.draw(graph_karate, pos, with_labels=True)\nnx.draw_networkx_edges(graph_karate, pos, edgelist=edges, edge_color=\"r\", width=3)\n\n\n\n\n\n\n\n\n\n# graph_karateeodesic length\nnx.shortest_path_length(graph_karate, 1, 2)\n\n1\n\n\nFinding the Geodesic from node i to every other node is computationaly complex, so we need an effeicient algorithm to do so.\nHere we use breadth-first search:\n\n# breadth-first search algorithm\ngraph_tree = nx.bfs_tree(graph_karate, 1)\nnx.draw_networkx(graph_tree, with_labels=True)\nlist(graph_tree.edges())\n\n[(1, 0),\n (1, 2),\n (1, 3),\n (1, 7),\n (1, 13),\n (1, 17),\n (1, 19),\n (1, 21),\n (1, 30),\n (0, 4),\n (0, 5),\n (0, 6),\n (0, 8),\n (0, 10),\n (0, 11),\n (0, 12),\n (0, 31),\n (2, 9),\n (2, 27),\n (2, 28),\n (2, 32),\n (13, 33),\n (5, 16),\n (31, 24),\n (31, 25),\n (27, 23),\n (32, 14),\n (32, 15),\n (32, 18),\n (32, 20),\n (32, 22),\n (32, 29),\n (33, 26)]\n\n\n\n\n\n\n\n\n\n\n# all shortest path\nnx.shortest_path_length(graph_karate, 1)  # outputs a dictionary\n\n{1: 0,\n 0: 1,\n 2: 1,\n 3: 1,\n 7: 1,\n 13: 1,\n 17: 1,\n 19: 1,\n 21: 1,\n 30: 1,\n 4: 2,\n 5: 2,\n 6: 2,\n 8: 2,\n 10: 2,\n 11: 2,\n 12: 2,\n 31: 2,\n 9: 2,\n 27: 2,\n 28: 2,\n 32: 2,\n 33: 2,\n 16: 3,\n 24: 3,\n 25: 3,\n 23: 3,\n 14: 3,\n 15: 3,\n 18: 3,\n 20: 3,\n 22: 3,\n 29: 3,\n 26: 3}\n\n\n\n# Average shortest path\nnx.average_shortest_path_length(graph_karate)\n\n2.408199643493761\n\n\n\n\n\nThe eccentricity of a node \\(u\\) in a network is the maximum distance between \\(u\\) and any other node in the network. In other words, it is the maximum length of the shortest path between \\(u\\) and any other node. The eccentricity of a network is the maximum eccentricity of any node in the network.\n\n# Eccentricity\n# the largest distance between n and all ohter nodes:\nnx.eccentricity(graph_karate)\n\n{0: 3,\n 1: 3,\n 2: 3,\n 3: 3,\n 4: 4,\n 5: 4,\n 6: 4,\n 7: 4,\n 8: 3,\n 9: 4,\n 10: 4,\n 11: 4,\n 12: 4,\n 13: 3,\n 14: 5,\n 15: 5,\n 16: 5,\n 17: 4,\n 18: 5,\n 19: 3,\n 20: 5,\n 21: 4,\n 22: 5,\n 23: 5,\n 24: 4,\n 25: 4,\n 26: 5,\n 27: 4,\n 28: 4,\n 29: 5,\n 30: 4,\n 31: 3,\n 32: 4,\n 33: 4}\n\n\n\n# Diameter: max Eccentricity between two nodes in whole network (max max)\nnx.diameter(graph_karate)\n\n5\n\n\n\n# Diameter is max eccentricity\nmax(nx.eccentricity(graph_karate).values())\n\n5\n\n\n\n# radius: min Eccentricity between two nodes in whole network (min max)\nnx.radius(graph_karate)\n\n3\n\n\n\n# radius is min eccentricity\nmin(nx.eccentricity(graph_karate).values())\n\n3\n\n\n\n# periphery\n# Eccentricity=diameter\nnx.periphery(graph_karate)\n\n[14, 15, 16, 18, 20, 22, 23, 26, 29]\n\n\n\n# the center of a graph : Eccentricity=radius\nnx.center(graph_karate)\n\n[0, 1, 2, 3, 8, 13, 19, 31]\n\n\n\n\n\n\n\nNetworkX provides several built-in network datasets that can be used for testing and experimentation. These datasets are available in the NetworkX library itself and can be loaded using functions that start with the prefix nx. followed by the name of the dataset.\nHere are some examples of the built-in network datasets in NetworkX:\n\nnx.karate_club_graph() - Returns the Zachary’s Karate Club network, a social network of a karate club, where each node represents a member of the club, and each edge represents a friendly relationship between members.\nnx.les_miserables_graph() - Returns a network of characters in the novel “Les Miserables” by Victor Hugo, where each node represents a character in the novel, and each edge represents a co-occurrence of two characters in a chapter.\nnx.davis_southern_women_graph() - Returns a network of the social interactions between women in a southern US town in the 1930s, where each node represents a woman, and each edge represents a social relation between two women.\n\nThese are just a few examples of the built-in network datasets in NetworkX. You can find more information about the available datasets and their usage in the NetworkX documentation.\n\n# An example\ngraph_families = nx.florentine_families_graph()\nnx.draw(graph_families, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nThe Karate Club graph is a social network representing friendships among 34 members of a karate club, as observed by Wayne W. Zachary in 1977. Each node in the graph represents a member of the club, and each edge represents a friendship between two members. The graph has 34 nodes and 78 edges.\nThe Karate Club is a well-known example in social network analysis and has been used to study various network properties, such as community structure and centrality measures. The graph is characterized by a split in the club into two factions, led by the club instructor (node 0) and one of the members (node 33), respectively. This split was caused by a dispute between the two leaders, which eventually led to the formation of two separate karate clubs.\n\n# Karate Club\ngraph_karate = nx.karate_club_graph()\ngraph_karate = nx.convert_node_labels_to_integers(graph_karate, first_label=1)\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\nthe club instructor (node 0) and one of the members (node 33) representation\n\n# Set the positions of the nodes using the Kamada-Kawai layout\npos = nx.kamada_kawai_layout(graph_karate)\n\n# Draw the graph with red nodes for node 0 (club instructor) and node 33 (member) : they are now 1 and 34\nred_nodes = [1, 34]\nnode_colors = [\"red\" if node in red_nodes else \"blue\" for node in graph_karate.nodes()]\nnx.draw_networkx_nodes(graph_karate, pos, node_color=node_colors)\nnx.draw_networkx_edges(graph_karate, pos)\n\n# Draw the labels for the nodes\nnx.draw_networkx_labels(graph_karate, pos)\n\n# Show the graph\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# disconnection based on random selection\nwhile nx.is_connected(graph_karate):\n    # delete an edge\n    i = random.choice(list(nx.nodes(graph_karate)))\n    j = random.choice(list(nx.nodes(graph_karate)))\n    if graph_karate.has_edge(i, j):\n        graph_karate.remove_edge(i, j)\nnx.draw_networkx(graph_karate)\n\n\n\n\n\n\n\n\n\n# connectivity\n# connected components\nnx.number_connected_components(graph_karate)\n\n2\n\n\n\nsorted(nx.connected_components(graph_karate))\n\n[{1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  19,\n  20,\n  21,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33,\n  34},\n {18}]\n\n\n\n# which component  each node belongs?\nnx.node_connected_component(graph_karate, 1)\n\n{1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9,\n 10,\n 11,\n 12,\n 13,\n 14,\n 15,\n 16,\n 17,\n 19,\n 20,\n 21,\n 22,\n 23,\n 24,\n 25,\n 26,\n 27,\n 28,\n 29,\n 30,\n 31,\n 32,\n 33,\n 34}\n\n\n\n\nweakly connected = replacing all directed edges with undirected edges produces a conneceted undirected graph\nstrongly connected = with directions\n\n# create an empty directed graph\ngraph_directed = nx.DiGraph()\n\n# add nodes to the graph\ngraph_directed.add_nodes_from(\n    [\"Alice\", \"Bob\", \"Charlie\", \"Dave\", \"Eve\", \"Adam\", \"Sarah\"]\n)\n\n# add directed edges to the graph\ngraph_directed.add_edge(\"Alice\", \"Bob\")\ngraph_directed.add_edge(\"Bob\", \"Charlie\")\ngraph_directed.add_edge(\"Dave\", \"Eve\")\ngraph_directed.add_edge(\"Alice\", \"Eve\")\ngraph_directed.add_edge(\"Eve\", \"Alice\")\ngraph_directed.add_edge(\"Adam\", \"Sarah\")\n# graph_directed.add_edge('Adam','Bob')\n\n# draw the graph\nnx.draw(graph_directed, with_labels=True)\n\n# show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# weakly connected\nnx.is_weakly_connected(graph_directed)\n\nFalse\n\n\n\n# strongly connected\nnx.is_strongly_connected(graph_directed)\n\nFalse\n\n\n\n# weakly connected components\nsorted(nx.weakly_connected_components(graph_directed))\n\n[{'Alice', 'Bob', 'Charlie', 'Dave', 'Eve'}, {'Adam', 'Sarah'}]\n\n\n\n# strongly connected components\nsorted(nx.strongly_connected_components(graph_directed))\n\n[{'Charlie'}, {'Bob'}, {'Alice', 'Eve'}, {'Dave'}, {'Sarah'}, {'Adam'}]\n\n\n\n\n\n\n\nnetwork robustness is the ability of a network to maintain its general structral properties when it faces failure or attacks\ntypes of attack: removal of nodes or edges\nRobustness = maintain connectivity\nexamples: airport closure, internet router failures, power line failure\n\n\nThe Erdős-Rényi random graph model is a classic random graph model that generates a graph with a fixed number of nodes, where each pair of nodes is connected with a probability p.\n\n# create an Erdős-Rényi random network\n\nn = 10  # number of nodes\np = 0.6  # probability of edge creation\ngraph_er = nx.erdos_renyi_graph(n, p)\n\n# draw the graph\nnx.draw(graph_er, with_labels=True)\n\n\n\n\n\n\n\n\nNode connectivity: Minimum number of nodes needed to disconnect a graph or pair of nodes.\nEdge connectivity: Minimum number of edges needed to disconnect a graph or pair of nodes.\nGraphs with large node and edge connectivity are more robust to the loss of nodes and edges.\n\n# what is the smallest number of nodes that can be romoved from graph in order to disconnect it?\nnx.node_connectivity(graph_er)\n\n4\n\n\n\n# which nodes?(the smallest set of nodes that needs to be removed to disconnect the graph)\nnx.minimum_node_cut(graph_er)\n\n{0, 1, 4, 7}\n\n\n\n# what is the smallest number of edges that can be romoved from graph in order to disconnect it?\nnx.edge_connectivity(graph_er)\n\n4\n\n\n\n# which edge(s)?\nnx.minimum_edge_cut(graph_er)\n\n{(1, 7), (5, 7), (6, 7), (9, 7)}\n\n\n\n\n\n\n\n# all paths from i to j\nsorted(nx.all_simple_paths(graph_er, 1, 2))\n\n[[1, 0, 2],\n [1, 0, 3, 2],\n [1, 0, 3, 4, 8, 2],\n [1, 0, 3, 4, 8, 5, 2],\n [1, 0, 3, 4, 8, 5, 6, 2],\n [1, 0, 3, 4, 8, 5, 7, 6, 2],\n [1, 0, 3, 4, 8, 6, 2],\n [1, 0, 3, 4, 8, 6, 5, 2],\n [1, 0, 3, 4, 8, 6, 7, 5, 2],\n [1, 0, 3, 4, 9, 7, 5, 2],\n [1, 0, 3, 4, 9, 7, 5, 6, 2],\n [1, 0, 3, 4, 9, 7, 5, 6, 8, 2],\n [1, 0, 3, 4, 9, 7, 5, 8, 2],\n [1, 0, 3, 4, 9, 7, 5, 8, 6, 2],\n [1, 0, 3, 4, 9, 7, 6, 2],\n [1, 0, 3, 4, 9, 7, 6, 5, 2],\n [1, 0, 3, 4, 9, 7, 6, 5, 8, 2],\n [1, 0, 3, 4, 9, 7, 6, 8, 2],\n [1, 0, 3, 4, 9, 7, 6, 8, 5, 2],\n [1, 0, 3, 5, 2],\n [1, 0, 3, 5, 6, 2],\n [1, 0, 3, 5, 6, 7, 9, 4, 8, 2],\n [1, 0, 3, 5, 6, 8, 2],\n [1, 0, 3, 5, 7, 6, 2],\n [1, 0, 3, 5, 7, 6, 8, 2],\n [1, 0, 3, 5, 7, 9, 4, 8, 2],\n [1, 0, 3, 5, 7, 9, 4, 8, 6, 2],\n [1, 0, 3, 5, 8, 2],\n [1, 0, 3, 5, 8, 4, 9, 7, 6, 2],\n [1, 0, 3, 5, 8, 6, 2],\n [1, 0, 3, 6, 2],\n [1, 0, 3, 6, 5, 2],\n [1, 0, 3, 6, 5, 7, 9, 4, 8, 2],\n [1, 0, 3, 6, 5, 8, 2],\n [1, 0, 3, 6, 7, 5, 2],\n [1, 0, 3, 6, 7, 5, 8, 2],\n [1, 0, 3, 6, 7, 9, 4, 8, 2],\n [1, 0, 3, 6, 7, 9, 4, 8, 5, 2],\n [1, 0, 3, 6, 8, 2],\n [1, 0, 3, 6, 8, 4, 9, 7, 5, 2],\n [1, 0, 3, 6, 8, 5, 2],\n [1, 0, 3, 8, 2],\n [1, 0, 3, 8, 4, 9, 7, 5, 2],\n [1, 0, 3, 8, 4, 9, 7, 5, 6, 2],\n [1, 0, 3, 8, 4, 9, 7, 6, 2],\n [1, 0, 3, 8, 4, 9, 7, 6, 5, 2],\n [1, 0, 3, 8, 5, 2],\n [1, 0, 3, 8, 5, 6, 2],\n [1, 0, 3, 8, 5, 7, 6, 2],\n [1, 0, 3, 8, 6, 2],\n [1, 0, 3, 8, 6, 5, 2],\n [1, 0, 3, 8, 6, 7, 5, 2],\n [1, 0, 5, 2],\n [1, 0, 5, 3, 2],\n [1, 0, 5, 3, 4, 8, 2],\n [1, 0, 5, 3, 4, 8, 6, 2],\n [1, 0, 5, 3, 4, 9, 7, 6, 2],\n [1, 0, 5, 3, 4, 9, 7, 6, 8, 2],\n [1, 0, 5, 3, 6, 2],\n [1, 0, 5, 3, 6, 7, 9, 4, 8, 2],\n [1, 0, 5, 3, 6, 8, 2],\n [1, 0, 5, 3, 8, 2],\n [1, 0, 5, 3, 8, 4, 9, 7, 6, 2],\n [1, 0, 5, 3, 8, 6, 2],\n [1, 0, 5, 6, 2],\n [1, 0, 5, 6, 3, 2],\n [1, 0, 5, 6, 3, 4, 8, 2],\n [1, 0, 5, 6, 3, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 3, 2],\n [1, 0, 5, 6, 7, 9, 4, 3, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 8, 3, 2],\n [1, 0, 5, 6, 8, 2],\n [1, 0, 5, 6, 8, 3, 2],\n [1, 0, 5, 6, 8, 4, 3, 2],\n [1, 0, 5, 7, 6, 2],\n [1, 0, 5, 7, 6, 3, 2],\n [1, 0, 5, 7, 6, 3, 4, 8, 2],\n [1, 0, 5, 7, 6, 3, 8, 2],\n [1, 0, 5, 7, 6, 8, 2],\n [1, 0, 5, 7, 6, 8, 3, 2],\n [1, 0, 5, 7, 6, 8, 4, 3, 2],\n [1, 0, 5, 7, 9, 4, 3, 2],\n [1, 0, 5, 7, 9, 4, 3, 6, 2],\n [1, 0, 5, 7, 9, 4, 3, 6, 8, 2],\n [1, 0, 5, 7, 9, 4, 3, 8, 2],\n [1, 0, 5, 7, 9, 4, 3, 8, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 2],\n [1, 0, 5, 7, 9, 4, 8, 3, 2],\n [1, 0, 5, 7, 9, 4, 8, 3, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 6, 3, 2],\n [1, 0, 5, 8, 2],\n [1, 0, 5, 8, 3, 2],\n [1, 0, 5, 8, 3, 4, 9, 7, 6, 2],\n [1, 0, 5, 8, 3, 6, 2],\n [1, 0, 5, 8, 4, 3, 2],\n [1, 0, 5, 8, 4, 3, 6, 2],\n [1, 0, 5, 8, 4, 9, 7, 6, 2],\n [1, 0, 5, 8, 4, 9, 7, 6, 3, 2],\n [1, 0, 5, 8, 6, 2],\n [1, 0, 5, 8, 6, 3, 2],\n [1, 0, 5, 8, 6, 7, 9, 4, 3, 2],\n [1, 0, 6, 2],\n [1, 0, 6, 3, 2],\n [1, 0, 6, 3, 4, 8, 2],\n [1, 0, 6, 3, 4, 8, 5, 2],\n [1, 0, 6, 3, 4, 9, 7, 5, 2],\n [1, 0, 6, 3, 4, 9, 7, 5, 8, 2],\n [1, 0, 6, 3, 5, 2],\n [1, 0, 6, 3, 5, 7, 9, 4, 8, 2],\n [1, 0, 6, 3, 5, 8, 2],\n [1, 0, 6, 3, 8, 2],\n [1, 0, 6, 3, 8, 4, 9, 7, 5, 2],\n [1, 0, 6, 3, 8, 5, 2],\n [1, 0, 6, 5, 2],\n [1, 0, 6, 5, 3, 2],\n [1, 0, 6, 5, 3, 4, 8, 2],\n [1, 0, 6, 5, 3, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 3, 2],\n [1, 0, 6, 5, 7, 9, 4, 3, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 8, 3, 2],\n [1, 0, 6, 5, 8, 2],\n [1, 0, 6, 5, 8, 3, 2],\n [1, 0, 6, 5, 8, 4, 3, 2],\n [1, 0, 6, 7, 5, 2],\n [1, 0, 6, 7, 5, 3, 2],\n [1, 0, 6, 7, 5, 3, 4, 8, 2],\n [1, 0, 6, 7, 5, 3, 8, 2],\n [1, 0, 6, 7, 5, 8, 2],\n [1, 0, 6, 7, 5, 8, 3, 2],\n [1, 0, 6, 7, 5, 8, 4, 3, 2],\n [1, 0, 6, 7, 9, 4, 3, 2],\n [1, 0, 6, 7, 9, 4, 3, 5, 2],\n [1, 0, 6, 7, 9, 4, 3, 5, 8, 2],\n [1, 0, 6, 7, 9, 4, 3, 8, 2],\n [1, 0, 6, 7, 9, 4, 3, 8, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 2],\n [1, 0, 6, 7, 9, 4, 8, 3, 2],\n [1, 0, 6, 7, 9, 4, 8, 3, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 5, 3, 2],\n [1, 0, 6, 8, 2],\n [1, 0, 6, 8, 3, 2],\n [1, 0, 6, 8, 3, 4, 9, 7, 5, 2],\n [1, 0, 6, 8, 3, 5, 2],\n [1, 0, 6, 8, 4, 3, 2],\n [1, 0, 6, 8, 4, 3, 5, 2],\n [1, 0, 6, 8, 4, 9, 7, 5, 2],\n [1, 0, 6, 8, 4, 9, 7, 5, 3, 2],\n [1, 0, 6, 8, 5, 2],\n [1, 0, 6, 8, 5, 3, 2],\n [1, 0, 6, 8, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 2],\n [1, 0, 8, 3, 2],\n [1, 0, 8, 3, 4, 9, 7, 5, 2],\n [1, 0, 8, 3, 4, 9, 7, 5, 6, 2],\n [1, 0, 8, 3, 4, 9, 7, 6, 2],\n [1, 0, 8, 3, 4, 9, 7, 6, 5, 2],\n [1, 0, 8, 3, 5, 2],\n [1, 0, 8, 3, 5, 6, 2],\n [1, 0, 8, 3, 5, 7, 6, 2],\n [1, 0, 8, 3, 6, 2],\n [1, 0, 8, 3, 6, 5, 2],\n [1, 0, 8, 3, 6, 7, 5, 2],\n [1, 0, 8, 4, 3, 2],\n [1, 0, 8, 4, 3, 5, 2],\n [1, 0, 8, 4, 3, 5, 6, 2],\n [1, 0, 8, 4, 3, 5, 7, 6, 2],\n [1, 0, 8, 4, 3, 6, 2],\n [1, 0, 8, 4, 3, 6, 5, 2],\n [1, 0, 8, 4, 3, 6, 7, 5, 2],\n [1, 0, 8, 4, 9, 7, 5, 2],\n [1, 0, 8, 4, 9, 7, 5, 3, 2],\n [1, 0, 8, 4, 9, 7, 5, 3, 6, 2],\n [1, 0, 8, 4, 9, 7, 5, 6, 2],\n [1, 0, 8, 4, 9, 7, 5, 6, 3, 2],\n [1, 0, 8, 4, 9, 7, 6, 2],\n [1, 0, 8, 4, 9, 7, 6, 3, 2],\n [1, 0, 8, 4, 9, 7, 6, 3, 5, 2],\n [1, 0, 8, 4, 9, 7, 6, 5, 2],\n [1, 0, 8, 4, 9, 7, 6, 5, 3, 2],\n [1, 0, 8, 5, 2],\n [1, 0, 8, 5, 3, 2],\n [1, 0, 8, 5, 3, 4, 9, 7, 6, 2],\n [1, 0, 8, 5, 3, 6, 2],\n [1, 0, 8, 5, 6, 2],\n [1, 0, 8, 5, 6, 3, 2],\n [1, 0, 8, 5, 6, 7, 9, 4, 3, 2],\n [1, 0, 8, 5, 7, 6, 2],\n [1, 0, 8, 5, 7, 6, 3, 2],\n [1, 0, 8, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 5, 7, 9, 4, 3, 6, 2],\n [1, 0, 8, 6, 2],\n [1, 0, 8, 6, 3, 2],\n [1, 0, 8, 6, 3, 4, 9, 7, 5, 2],\n [1, 0, 8, 6, 3, 5, 2],\n [1, 0, 8, 6, 5, 2],\n [1, 0, 8, 6, 5, 3, 2],\n [1, 0, 8, 6, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 6, 7, 5, 2],\n [1, 0, 8, 6, 7, 5, 3, 2],\n [1, 0, 8, 6, 7, 9, 4, 3, 2],\n [1, 0, 8, 6, 7, 9, 4, 3, 5, 2],\n [1, 0, 9, 4, 3, 2],\n [1, 0, 9, 4, 3, 5, 2],\n [1, 0, 9, 4, 3, 5, 6, 2],\n [1, 0, 9, 4, 3, 5, 6, 8, 2],\n [1, 0, 9, 4, 3, 5, 7, 6, 2],\n [1, 0, 9, 4, 3, 5, 7, 6, 8, 2],\n [1, 0, 9, 4, 3, 5, 8, 2],\n [1, 0, 9, 4, 3, 5, 8, 6, 2],\n [1, 0, 9, 4, 3, 6, 2],\n [1, 0, 9, 4, 3, 6, 5, 2],\n [1, 0, 9, 4, 3, 6, 5, 8, 2],\n [1, 0, 9, 4, 3, 6, 7, 5, 2],\n [1, 0, 9, 4, 3, 6, 7, 5, 8, 2],\n [1, 0, 9, 4, 3, 6, 8, 2],\n [1, 0, 9, 4, 3, 6, 8, 5, 2],\n [1, 0, 9, 4, 3, 8, 2],\n [1, 0, 9, 4, 3, 8, 5, 2],\n [1, 0, 9, 4, 3, 8, 5, 6, 2],\n [1, 0, 9, 4, 3, 8, 5, 7, 6, 2],\n [1, 0, 9, 4, 3, 8, 6, 2],\n [1, 0, 9, 4, 3, 8, 6, 5, 2],\n [1, 0, 9, 4, 3, 8, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 2],\n [1, 0, 9, 4, 8, 3, 2],\n [1, 0, 9, 4, 8, 3, 5, 2],\n [1, 0, 9, 4, 8, 3, 5, 6, 2],\n [1, 0, 9, 4, 8, 3, 5, 7, 6, 2],\n [1, 0, 9, 4, 8, 3, 6, 2],\n [1, 0, 9, 4, 8, 3, 6, 5, 2],\n [1, 0, 9, 4, 8, 3, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 5, 2],\n [1, 0, 9, 4, 8, 5, 3, 2],\n [1, 0, 9, 4, 8, 5, 3, 6, 2],\n [1, 0, 9, 4, 8, 5, 6, 2],\n [1, 0, 9, 4, 8, 5, 6, 3, 2],\n [1, 0, 9, 4, 8, 5, 7, 6, 2],\n [1, 0, 9, 4, 8, 5, 7, 6, 3, 2],\n [1, 0, 9, 4, 8, 6, 2],\n [1, 0, 9, 4, 8, 6, 3, 2],\n [1, 0, 9, 4, 8, 6, 3, 5, 2],\n [1, 0, 9, 4, 8, 6, 5, 2],\n [1, 0, 9, 4, 8, 6, 5, 3, 2],\n [1, 0, 9, 4, 8, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 6, 7, 5, 3, 2],\n [1, 0, 9, 7, 5, 2],\n [1, 0, 9, 7, 5, 3, 2],\n [1, 0, 9, 7, 5, 3, 4, 8, 2],\n [1, 0, 9, 7, 5, 3, 4, 8, 6, 2],\n [1, 0, 9, 7, 5, 3, 6, 2],\n [1, 0, 9, 7, 5, 3, 6, 8, 2],\n [1, 0, 9, 7, 5, 3, 8, 2],\n [1, 0, 9, 7, 5, 3, 8, 6, 2],\n [1, 0, 9, 7, 5, 6, 2],\n [1, 0, 9, 7, 5, 6, 3, 2],\n [1, 0, 9, 7, 5, 6, 3, 4, 8, 2],\n [1, 0, 9, 7, 5, 6, 3, 8, 2],\n [1, 0, 9, 7, 5, 6, 8, 2],\n [1, 0, 9, 7, 5, 6, 8, 3, 2],\n [1, 0, 9, 7, 5, 6, 8, 4, 3, 2],\n [1, 0, 9, 7, 5, 8, 2],\n [1, 0, 9, 7, 5, 8, 3, 2],\n [1, 0, 9, 7, 5, 8, 3, 6, 2],\n [1, 0, 9, 7, 5, 8, 4, 3, 2],\n [1, 0, 9, 7, 5, 8, 4, 3, 6, 2],\n [1, 0, 9, 7, 5, 8, 6, 2],\n [1, 0, 9, 7, 5, 8, 6, 3, 2],\n [1, 0, 9, 7, 6, 2],\n [1, 0, 9, 7, 6, 3, 2],\n [1, 0, 9, 7, 6, 3, 4, 8, 2],\n [1, 0, 9, 7, 6, 3, 4, 8, 5, 2],\n [1, 0, 9, 7, 6, 3, 5, 2],\n [1, 0, 9, 7, 6, 3, 5, 8, 2],\n [1, 0, 9, 7, 6, 3, 8, 2],\n [1, 0, 9, 7, 6, 3, 8, 5, 2],\n [1, 0, 9, 7, 6, 5, 2],\n [1, 0, 9, 7, 6, 5, 3, 2],\n [1, 0, 9, 7, 6, 5, 3, 4, 8, 2],\n [1, 0, 9, 7, 6, 5, 3, 8, 2],\n [1, 0, 9, 7, 6, 5, 8, 2],\n [1, 0, 9, 7, 6, 5, 8, 3, 2],\n [1, 0, 9, 7, 6, 5, 8, 4, 3, 2],\n [1, 0, 9, 7, 6, 8, 2],\n [1, 0, 9, 7, 6, 8, 3, 2],\n [1, 0, 9, 7, 6, 8, 3, 5, 2],\n [1, 0, 9, 7, 6, 8, 4, 3, 2],\n [1, 0, 9, 7, 6, 8, 4, 3, 5, 2],\n [1, 0, 9, 7, 6, 8, 5, 2],\n [1, 0, 9, 7, 6, 8, 5, 3, 2],\n [1, 2],\n [1, 3, 0, 2],\n [1, 3, 0, 5, 2],\n [1, 3, 0, 5, 6, 2],\n [1, 3, 0, 5, 6, 7, 9, 4, 8, 2],\n [1, 3, 0, 5, 6, 8, 2],\n [1, 3, 0, 5, 7, 6, 2],\n [1, 3, 0, 5, 7, 6, 8, 2],\n [1, 3, 0, 5, 7, 9, 4, 8, 2],\n [1, 3, 0, 5, 7, 9, 4, 8, 6, 2],\n [1, 3, 0, 5, 8, 2],\n [1, 3, 0, 5, 8, 4, 9, 7, 6, 2],\n [1, 3, 0, 5, 8, 6, 2],\n [1, 3, 0, 6, 2],\n [1, 3, 0, 6, 5, 2],\n [1, 3, 0, 6, 5, 7, 9, 4, 8, 2],\n [1, 3, 0, 6, 5, 8, 2],\n [1, 3, 0, 6, 7, 5, 2],\n [1, 3, 0, 6, 7, 5, 8, 2],\n [1, 3, 0, 6, 7, 9, 4, 8, 2],\n [1, 3, 0, 6, 7, 9, 4, 8, 5, 2],\n [1, 3, 0, 6, 8, 2],\n [1, 3, 0, 6, 8, 4, 9, 7, 5, 2],\n [1, 3, 0, 6, 8, 5, 2],\n [1, 3, 0, 8, 2],\n [1, 3, 0, 8, 4, 9, 7, 5, 2],\n [1, 3, 0, 8, 4, 9, 7, 5, 6, 2],\n [1, 3, 0, 8, 4, 9, 7, 6, 2],\n [1, 3, 0, 8, 4, 9, 7, 6, 5, 2],\n [1, 3, 0, 8, 5, 2],\n [1, 3, 0, 8, 5, 6, 2],\n [1, 3, 0, 8, 5, 7, 6, 2],\n [1, 3, 0, 8, 6, 2],\n [1, 3, 0, 8, 6, 5, 2],\n [1, 3, 0, 8, 6, 7, 5, 2],\n [1, 3, 0, 9, 4, 8, 2],\n [1, 3, 0, 9, 4, 8, 5, 2],\n [1, 3, 0, 9, 4, 8, 5, 6, 2],\n [1, 3, 0, 9, 4, 8, 5, 7, 6, 2],\n [1, 3, 0, 9, 4, 8, 6, 2],\n [1, 3, 0, 9, 4, 8, 6, 5, 2],\n [1, 3, 0, 9, 4, 8, 6, 7, 5, 2],\n [1, 3, 0, 9, 7, 5, 2],\n [1, 3, 0, 9, 7, 5, 6, 2],\n [1, 3, 0, 9, 7, 5, 6, 8, 2],\n [1, 3, 0, 9, 7, 5, 8, 2],\n [1, 3, 0, 9, 7, 5, 8, 6, 2],\n [1, 3, 0, 9, 7, 6, 2],\n [1, 3, 0, 9, 7, 6, 5, 2],\n [1, 3, 0, 9, 7, 6, 5, 8, 2],\n [1, 3, 0, 9, 7, 6, 8, 2],\n [1, 3, 0, 9, 7, 6, 8, 5, 2],\n [1, 3, 2],\n [1, 3, 4, 8, 0, 2],\n [1, 3, 4, 8, 0, 5, 2],\n [1, 3, 4, 8, 0, 5, 6, 2],\n [1, 3, 4, 8, 0, 5, 7, 6, 2],\n [1, 3, 4, 8, 0, 6, 2],\n [1, 3, 4, 8, 0, 6, 5, 2],\n [1, 3, 4, 8, 0, 6, 7, 5, 2],\n [1, 3, 4, 8, 0, 9, 7, 5, 2],\n [1, 3, 4, 8, 0, 9, 7, 5, 6, 2],\n [1, 3, 4, 8, 0, 9, 7, 6, 2],\n [1, 3, 4, 8, 0, 9, 7, 6, 5, 2],\n [1, 3, 4, 8, 2],\n [1, 3, 4, 8, 5, 0, 2],\n [1, 3, 4, 8, 5, 0, 6, 2],\n [1, 3, 4, 8, 5, 0, 9, 7, 6, 2],\n [1, 3, 4, 8, 5, 2],\n [1, 3, 4, 8, 5, 6, 0, 2],\n [1, 3, 4, 8, 5, 6, 2],\n [1, 3, 4, 8, 5, 6, 7, 9, 0, 2],\n [1, 3, 4, 8, 5, 7, 6, 0, 2],\n [1, 3, 4, 8, 5, 7, 6, 2],\n [1, 3, 4, 8, 5, 7, 9, 0, 2],\n [1, 3, 4, 8, 5, 7, 9, 0, 6, 2],\n [1, 3, 4, 8, 6, 0, 2],\n [1, 3, 4, 8, 6, 0, 5, 2],\n [1, 3, 4, 8, 6, 0, 9, 7, 5, 2],\n [1, 3, 4, 8, 6, 2],\n [1, 3, 4, 8, 6, 5, 0, 2],\n [1, 3, 4, 8, 6, 5, 2],\n [1, 3, 4, 8, 6, 5, 7, 9, 0, 2],\n [1, 3, 4, 8, 6, 7, 5, 0, 2],\n [1, 3, 4, 8, 6, 7, 5, 2],\n [1, 3, 4, 8, 6, 7, 9, 0, 2],\n [1, 3, 4, 8, 6, 7, 9, 0, 5, 2],\n [1, 3, 4, 9, 0, 2],\n [1, 3, 4, 9, 0, 5, 2],\n [1, 3, 4, 9, 0, 5, 6, 2],\n [1, 3, 4, 9, 0, 5, 6, 8, 2],\n [1, 3, 4, 9, 0, 5, 7, 6, 2],\n [1, 3, 4, 9, 0, 5, 7, 6, 8, 2],\n [1, 3, 4, 9, 0, 5, 8, 2],\n [1, 3, 4, 9, 0, 5, 8, 6, 2],\n [1, 3, 4, 9, 0, 6, 2],\n [1, 3, 4, 9, 0, 6, 5, 2],\n [1, 3, 4, 9, 0, 6, 5, 8, 2],\n [1, 3, 4, 9, 0, 6, 7, 5, 2],\n [1, 3, 4, 9, 0, 6, 7, 5, 8, 2],\n [1, 3, 4, 9, 0, 6, 8, 2],\n [1, 3, 4, 9, 0, 6, 8, 5, 2],\n [1, 3, 4, 9, 0, 8, 2],\n [1, 3, 4, 9, 0, 8, 5, 2],\n [1, 3, 4, 9, 0, 8, 5, 6, 2],\n [1, 3, 4, 9, 0, 8, 5, 7, 6, 2],\n [1, 3, 4, 9, 0, 8, 6, 2],\n [1, 3, 4, 9, 0, 8, 6, 5, 2],\n [1, 3, 4, 9, 0, 8, 6, 7, 5, 2],\n [1, 3, 4, 9, 7, 5, 0, 2],\n [1, 3, 4, 9, 7, 5, 0, 6, 2],\n [1, 3, 4, 9, 7, 5, 0, 6, 8, 2],\n [1, 3, 4, 9, 7, 5, 0, 8, 2],\n [1, 3, 4, 9, 7, 5, 0, 8, 6, 2],\n [1, 3, 4, 9, 7, 5, 2],\n [1, 3, 4, 9, 7, 5, 6, 0, 2],\n [1, 3, 4, 9, 7, 5, 6, 0, 8, 2],\n [1, 3, 4, 9, 7, 5, 6, 2],\n [1, 3, 4, 9, 7, 5, 6, 8, 0, 2],\n [1, 3, 4, 9, 7, 5, 6, 8, 2],\n [1, 3, 4, 9, 7, 5, 8, 0, 2],\n [1, 3, 4, 9, 7, 5, 8, 0, 6, 2],\n [1, 3, 4, 9, 7, 5, 8, 2],\n [1, 3, 4, 9, 7, 5, 8, 6, 0, 2],\n [1, 3, 4, 9, 7, 5, 8, 6, 2],\n [1, 3, 4, 9, 7, 6, 0, 2],\n [1, 3, 4, 9, 7, 6, 0, 5, 2],\n [1, 3, 4, 9, 7, 6, 0, 5, 8, 2],\n [1, 3, 4, 9, 7, 6, 0, 8, 2],\n [1, 3, 4, 9, 7, 6, 0, 8, 5, 2],\n [1, 3, 4, 9, 7, 6, 2],\n [1, 3, 4, 9, 7, 6, 5, 0, 2],\n [1, 3, 4, 9, 7, 6, 5, 0, 8, 2],\n [1, 3, 4, 9, 7, 6, 5, 2],\n [1, 3, 4, 9, 7, 6, 5, 8, 0, 2],\n [1, 3, 4, 9, 7, 6, 5, 8, 2],\n [1, 3, 4, 9, 7, 6, 8, 0, 2],\n [1, 3, 4, 9, 7, 6, 8, 0, 5, 2],\n [1, 3, 4, 9, 7, 6, 8, 2],\n [1, 3, 4, 9, 7, 6, 8, 5, 0, 2],\n [1, 3, 4, 9, 7, 6, 8, 5, 2],\n [1, 3, 5, 0, 2],\n [1, 3, 5, 0, 6, 2],\n [1, 3, 5, 0, 6, 7, 9, 4, 8, 2],\n [1, 3, 5, 0, 6, 8, 2],\n [1, 3, 5, 0, 8, 2],\n [1, 3, 5, 0, 8, 4, 9, 7, 6, 2],\n [1, 3, 5, 0, 8, 6, 2],\n [1, 3, 5, 0, 9, 4, 8, 2],\n [1, 3, 5, 0, 9, 4, 8, 6, 2],\n [1, 3, 5, 0, 9, 7, 6, 2],\n [1, 3, 5, 0, 9, 7, 6, 8, 2],\n [1, 3, 5, 2],\n [1, 3, 5, 6, 0, 2],\n [1, 3, 5, 6, 0, 8, 2],\n [1, 3, 5, 6, 0, 9, 4, 8, 2],\n [1, 3, 5, 6, 2],\n [1, 3, 5, 6, 7, 9, 0, 2],\n [1, 3, 5, 6, 7, 9, 0, 8, 2],\n [1, 3, 5, 6, 7, 9, 4, 8, 0, 2],\n [1, 3, 5, 6, 7, 9, 4, 8, 2],\n [1, 3, 5, 6, 8, 0, 2],\n [1, 3, 5, 6, 8, 2],\n [1, 3, 5, 6, 8, 4, 9, 0, 2],\n [1, 3, 5, 7, 6, 0, 2],\n [1, 3, 5, 7, 6, 0, 8, 2],\n [1, 3, 5, 7, 6, 0, 9, 4, 8, 2],\n [1, 3, 5, 7, 6, 2],\n [1, 3, 5, 7, 6, 8, 0, 2],\n [1, 3, 5, 7, 6, 8, 2],\n [1, 3, 5, 7, 6, 8, 4, 9, 0, 2],\n [1, 3, 5, 7, 9, 0, 2],\n [1, 3, 5, 7, 9, 0, 6, 2],\n [1, 3, 5, 7, 9, 0, 6, 8, 2],\n [1, 3, 5, 7, 9, 0, 8, 2],\n [1, 3, 5, 7, 9, 0, 8, 6, 2],\n [1, 3, 5, 7, 9, 4, 8, 0, 2],\n [1, 3, 5, 7, 9, 4, 8, 0, 6, 2],\n [1, 3, 5, 7, 9, 4, 8, 2],\n [1, 3, 5, 7, 9, 4, 8, 6, 0, 2],\n [1, 3, 5, 7, 9, 4, 8, 6, 2],\n [1, 3, 5, 8, 0, 2],\n [1, 3, 5, 8, 0, 6, 2],\n [1, 3, 5, 8, 0, 9, 7, 6, 2],\n [1, 3, 5, 8, 2],\n [1, 3, 5, 8, 4, 9, 0, 2],\n [1, 3, 5, 8, 4, 9, 0, 6, 2],\n [1, 3, 5, 8, 4, 9, 7, 6, 0, 2],\n [1, 3, 5, 8, 4, 9, 7, 6, 2],\n [1, 3, 5, 8, 6, 0, 2],\n [1, 3, 5, 8, 6, 2],\n [1, 3, 5, 8, 6, 7, 9, 0, 2],\n [1, 3, 6, 0, 2],\n [1, 3, 6, 0, 5, 2],\n [1, 3, 6, 0, 5, 7, 9, 4, 8, 2],\n [1, 3, 6, 0, 5, 8, 2],\n [1, 3, 6, 0, 8, 2],\n [1, 3, 6, 0, 8, 4, 9, 7, 5, 2],\n [1, 3, 6, 0, 8, 5, 2],\n [1, 3, 6, 0, 9, 4, 8, 2],\n [1, 3, 6, 0, 9, 4, 8, 5, 2],\n [1, 3, 6, 0, 9, 7, 5, 2],\n [1, 3, 6, 0, 9, 7, 5, 8, 2],\n [1, 3, 6, 2],\n [1, 3, 6, 5, 0, 2],\n [1, 3, 6, 5, 0, 8, 2],\n [1, 3, 6, 5, 0, 9, 4, 8, 2],\n [1, 3, 6, 5, 2],\n [1, 3, 6, 5, 7, 9, 0, 2],\n [1, 3, 6, 5, 7, 9, 0, 8, 2],\n [1, 3, 6, 5, 7, 9, 4, 8, 0, 2],\n [1, 3, 6, 5, 7, 9, 4, 8, 2],\n [1, 3, 6, 5, 8, 0, 2],\n [1, 3, 6, 5, 8, 2],\n [1, 3, 6, 5, 8, 4, 9, 0, 2],\n [1, 3, 6, 7, 5, 0, 2],\n [1, 3, 6, 7, 5, 0, 8, 2],\n [1, 3, 6, 7, 5, 0, 9, 4, 8, 2],\n [1, 3, 6, 7, 5, 2],\n [1, 3, 6, 7, 5, 8, 0, 2],\n [1, 3, 6, 7, 5, 8, 2],\n [1, 3, 6, 7, 5, 8, 4, 9, 0, 2],\n [1, 3, 6, 7, 9, 0, 2],\n [1, 3, 6, 7, 9, 0, 5, 2],\n [1, 3, 6, 7, 9, 0, 5, 8, 2],\n [1, 3, 6, 7, 9, 0, 8, 2],\n [1, 3, 6, 7, 9, 0, 8, 5, 2],\n [1, 3, 6, 7, 9, 4, 8, 0, 2],\n [1, 3, 6, 7, 9, 4, 8, 0, 5, 2],\n [1, 3, 6, 7, 9, 4, 8, 2],\n [1, 3, 6, 7, 9, 4, 8, 5, 0, 2],\n [1, 3, 6, 7, 9, 4, 8, 5, 2],\n [1, 3, 6, 8, 0, 2],\n [1, 3, 6, 8, 0, 5, 2],\n [1, 3, 6, 8, 0, 9, 7, 5, 2],\n [1, 3, 6, 8, 2],\n [1, 3, 6, 8, 4, 9, 0, 2],\n [1, 3, 6, 8, 4, 9, 0, 5, 2],\n [1, 3, 6, 8, 4, 9, 7, 5, 0, 2],\n [1, 3, 6, 8, 4, 9, 7, 5, 2],\n [1, 3, 6, 8, 5, 0, 2],\n [1, 3, 6, 8, 5, 2],\n [1, 3, 6, 8, 5, 7, 9, 0, 2],\n [1, 3, 8, 0, 2],\n [1, 3, 8, 0, 5, 2],\n [1, 3, 8, 0, 5, 6, 2],\n [1, 3, 8, 0, 5, 7, 6, 2],\n [1, 3, 8, 0, 6, 2],\n [1, 3, 8, 0, 6, 5, 2],\n [1, 3, 8, 0, 6, 7, 5, 2],\n [1, 3, 8, 0, 9, 7, 5, 2],\n [1, 3, 8, 0, 9, 7, 5, 6, 2],\n [1, 3, 8, 0, 9, 7, 6, 2],\n [1, 3, 8, 0, 9, 7, 6, 5, 2],\n [1, 3, 8, 2],\n [1, 3, 8, 4, 9, 0, 2],\n [1, 3, 8, 4, 9, 0, 5, 2],\n [1, 3, 8, 4, 9, 0, 5, 6, 2],\n [1, 3, 8, 4, 9, 0, 5, 7, 6, 2],\n [1, 3, 8, 4, 9, 0, 6, 2],\n [1, 3, 8, 4, 9, 0, 6, 5, 2],\n [1, 3, 8, 4, 9, 0, 6, 7, 5, 2],\n [1, 3, 8, 4, 9, 7, 5, 0, 2],\n [1, 3, 8, 4, 9, 7, 5, 0, 6, 2],\n [1, 3, 8, 4, 9, 7, 5, 2],\n [1, 3, 8, 4, 9, 7, 5, 6, 0, 2],\n [1, 3, 8, 4, 9, 7, 5, 6, 2],\n [1, 3, 8, 4, 9, 7, 6, 0, 2],\n [1, 3, 8, 4, 9, 7, 6, 0, 5, 2],\n [1, 3, 8, 4, 9, 7, 6, 2],\n [1, 3, 8, 4, 9, 7, 6, 5, 0, 2],\n [1, 3, 8, 4, 9, 7, 6, 5, 2],\n [1, 3, 8, 5, 0, 2],\n [1, 3, 8, 5, 0, 6, 2],\n [1, 3, 8, 5, 0, 9, 7, 6, 2],\n [1, 3, 8, 5, 2],\n [1, 3, 8, 5, 6, 0, 2],\n [1, 3, 8, 5, 6, 2],\n [1, 3, 8, 5, 6, 7, 9, 0, 2],\n [1, 3, 8, 5, 7, 6, 0, 2],\n [1, 3, 8, 5, 7, 6, 2],\n [1, 3, 8, 5, 7, 9, 0, 2],\n [1, 3, 8, 5, 7, 9, 0, 6, 2],\n [1, 3, 8, 6, 0, 2],\n [1, 3, 8, 6, 0, 5, 2],\n [1, 3, 8, 6, 0, 9, 7, 5, 2],\n [1, 3, 8, 6, 2],\n [1, 3, 8, 6, 5, 0, 2],\n [1, 3, 8, 6, 5, 2],\n [1, 3, 8, 6, 5, 7, 9, 0, 2],\n [1, 3, 8, 6, 7, 5, 0, 2],\n [1, 3, 8, 6, 7, 5, 2],\n [1, 3, 8, 6, 7, 9, 0, 2],\n [1, 3, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 3, 0, 2],\n [1, 4, 3, 0, 5, 2],\n [1, 4, 3, 0, 5, 6, 2],\n [1, 4, 3, 0, 5, 6, 8, 2],\n [1, 4, 3, 0, 5, 7, 6, 2],\n [1, 4, 3, 0, 5, 7, 6, 8, 2],\n [1, 4, 3, 0, 5, 8, 2],\n [1, 4, 3, 0, 5, 8, 6, 2],\n [1, 4, 3, 0, 6, 2],\n [1, 4, 3, 0, 6, 5, 2],\n [1, 4, 3, 0, 6, 5, 8, 2],\n [1, 4, 3, 0, 6, 7, 5, 2],\n [1, 4, 3, 0, 6, 7, 5, 8, 2],\n [1, 4, 3, 0, 6, 8, 2],\n [1, 4, 3, 0, 6, 8, 5, 2],\n [1, 4, 3, 0, 8, 2],\n [1, 4, 3, 0, 8, 5, 2],\n [1, 4, 3, 0, 8, 5, 6, 2],\n [1, 4, 3, 0, 8, 5, 7, 6, 2],\n [1, 4, 3, 0, 8, 6, 2],\n [1, 4, 3, 0, 8, 6, 5, 2],\n [1, 4, 3, 0, 8, 6, 7, 5, 2],\n [1, 4, 3, 0, 9, 7, 5, 2],\n [1, 4, 3, 0, 9, 7, 5, 6, 2],\n [1, 4, 3, 0, 9, 7, 5, 6, 8, 2],\n [1, 4, 3, 0, 9, 7, 5, 8, 2],\n [1, 4, 3, 0, 9, 7, 5, 8, 6, 2],\n [1, 4, 3, 0, 9, 7, 6, 2],\n [1, 4, 3, 0, 9, 7, 6, 5, 2],\n [1, 4, 3, 0, 9, 7, 6, 5, 8, 2],\n [1, 4, 3, 0, 9, 7, 6, 8, 2],\n [1, 4, 3, 0, 9, 7, 6, 8, 5, 2],\n [1, 4, 3, 2],\n [1, 4, 3, 5, 0, 2],\n [1, 4, 3, 5, 0, 6, 2],\n [1, 4, 3, 5, 0, 6, 8, 2],\n [1, 4, 3, 5, 0, 8, 2],\n [1, 4, 3, 5, 0, 8, 6, 2],\n [1, 4, 3, 5, 0, 9, 7, 6, 2],\n [1, 4, 3, 5, 0, 9, 7, 6, 8, 2],\n [1, 4, 3, 5, 2],\n [1, 4, 3, 5, 6, 0, 2],\n [1, 4, 3, 5, 6, 0, 8, 2],\n [1, 4, 3, 5, 6, 2],\n [1, 4, 3, 5, 6, 7, 9, 0, 2],\n [1, 4, 3, 5, 6, 7, 9, 0, 8, 2],\n [1, 4, 3, 5, 6, 8, 0, 2],\n [1, 4, 3, 5, 6, 8, 2],\n [1, 4, 3, 5, 7, 6, 0, 2],\n [1, 4, 3, 5, 7, 6, 0, 8, 2],\n [1, 4, 3, 5, 7, 6, 2],\n [1, 4, 3, 5, 7, 6, 8, 0, 2],\n [1, 4, 3, 5, 7, 6, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 2],\n [1, 4, 3, 5, 7, 9, 0, 6, 2],\n [1, 4, 3, 5, 7, 9, 0, 6, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 8, 6, 2],\n [1, 4, 3, 5, 8, 0, 2],\n [1, 4, 3, 5, 8, 0, 6, 2],\n [1, 4, 3, 5, 8, 0, 9, 7, 6, 2],\n [1, 4, 3, 5, 8, 2],\n [1, 4, 3, 5, 8, 6, 0, 2],\n [1, 4, 3, 5, 8, 6, 2],\n [1, 4, 3, 5, 8, 6, 7, 9, 0, 2],\n [1, 4, 3, 6, 0, 2],\n [1, 4, 3, 6, 0, 5, 2],\n [1, 4, 3, 6, 0, 5, 8, 2],\n [1, 4, 3, 6, 0, 8, 2],\n [1, 4, 3, 6, 0, 8, 5, 2],\n [1, 4, 3, 6, 0, 9, 7, 5, 2],\n [1, 4, 3, 6, 0, 9, 7, 5, 8, 2],\n [1, 4, 3, 6, 2],\n [1, 4, 3, 6, 5, 0, 2],\n [1, 4, 3, 6, 5, 0, 8, 2],\n [1, 4, 3, 6, 5, 2],\n [1, 4, 3, 6, 5, 7, 9, 0, 2],\n [1, 4, 3, 6, 5, 7, 9, 0, 8, 2],\n [1, 4, 3, 6, 5, 8, 0, 2],\n [1, 4, 3, 6, 5, 8, 2],\n [1, 4, 3, 6, 7, 5, 0, 2],\n [1, 4, 3, 6, 7, 5, 0, 8, 2],\n [1, 4, 3, 6, 7, 5, 2],\n [1, 4, 3, 6, 7, 5, 8, 0, 2],\n [1, 4, 3, 6, 7, 5, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 2],\n [1, 4, 3, 6, 7, 9, 0, 5, 2],\n [1, 4, 3, 6, 7, 9, 0, 5, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 8, 5, 2],\n [1, 4, 3, 6, 8, 0, 2],\n [1, 4, 3, 6, 8, 0, 5, 2],\n [1, 4, 3, 6, 8, 0, 9, 7, 5, 2],\n [1, 4, 3, 6, 8, 2],\n [1, 4, 3, 6, 8, 5, 0, 2],\n [1, 4, 3, 6, 8, 5, 2],\n [1, 4, 3, 6, 8, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 0, 2],\n [1, 4, 3, 8, 0, 5, 2],\n [1, 4, 3, 8, 0, 5, 6, 2],\n [1, 4, 3, 8, 0, 5, 7, 6, 2],\n [1, 4, 3, 8, 0, 6, 2],\n [1, 4, 3, 8, 0, 6, 5, 2],\n [1, 4, 3, 8, 0, 6, 7, 5, 2],\n [1, 4, 3, 8, 0, 9, 7, 5, 2],\n [1, 4, 3, 8, 0, 9, 7, 5, 6, 2],\n [1, 4, 3, 8, 0, 9, 7, 6, 2],\n [1, 4, 3, 8, 0, 9, 7, 6, 5, 2],\n [1, 4, 3, 8, 2],\n [1, 4, 3, 8, 5, 0, 2],\n [1, 4, 3, 8, 5, 0, 6, 2],\n [1, 4, 3, 8, 5, 0, 9, 7, 6, 2],\n [1, 4, 3, 8, 5, 2],\n [1, 4, 3, 8, 5, 6, 0, 2],\n [1, 4, 3, 8, 5, 6, 2],\n [1, 4, 3, 8, 5, 6, 7, 9, 0, 2],\n [1, 4, 3, 8, 5, 7, 6, 0, 2],\n [1, 4, 3, 8, 5, 7, 6, 2],\n [1, 4, 3, 8, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 5, 7, 9, 0, 6, 2],\n [1, 4, 3, 8, 6, 0, 2],\n [1, 4, 3, 8, 6, 0, 5, 2],\n [1, 4, 3, 8, 6, 0, 9, 7, 5, 2],\n [1, 4, 3, 8, 6, 2],\n [1, 4, 3, 8, 6, 5, 0, 2],\n [1, 4, 3, 8, 6, 5, 2],\n [1, 4, 3, 8, 6, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 6, 7, 5, 0, 2],\n [1, 4, 3, 8, 6, 7, 5, 2],\n [1, 4, 3, 8, 6, 7, 9, 0, 2],\n [1, 4, 3, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 0, 2],\n [1, 4, 8, 0, 3, 2],\n [1, 4, 8, 0, 3, 5, 2],\n [1, 4, 8, 0, 3, 5, 6, 2],\n [1, 4, 8, 0, 3, 5, 7, 6, 2],\n [1, 4, 8, 0, 3, 6, 2],\n [1, 4, 8, 0, 3, 6, 5, 2],\n [1, 4, 8, 0, 3, 6, 7, 5, 2],\n [1, 4, 8, 0, 5, 2],\n [1, 4, 8, 0, 5, 3, 2],\n [1, 4, 8, 0, 5, 3, 6, 2],\n [1, 4, 8, 0, 5, 6, 2],\n [1, 4, 8, 0, 5, 6, 3, 2],\n [1, 4, 8, 0, 5, 7, 6, 2],\n [1, 4, 8, 0, 5, 7, 6, 3, 2],\n [1, 4, 8, 0, 6, 2],\n [1, 4, 8, 0, 6, 3, 2],\n [1, 4, 8, 0, 6, 3, 5, 2],\n [1, 4, 8, 0, 6, 5, 2],\n [1, 4, 8, 0, 6, 5, 3, 2],\n [1, 4, 8, 0, 6, 7, 5, 2],\n [1, 4, 8, 0, 6, 7, 5, 3, 2],\n [1, 4, 8, 0, 9, 7, 5, 2],\n [1, 4, 8, 0, 9, 7, 5, 3, 2],\n [1, 4, 8, 0, 9, 7, 5, 3, 6, 2],\n [1, 4, 8, 0, 9, 7, 5, 6, 2],\n [1, 4, 8, 0, 9, 7, 5, 6, 3, 2],\n [1, 4, 8, 0, 9, 7, 6, 2],\n [1, 4, 8, 0, 9, 7, 6, 3, 2],\n [1, 4, 8, 0, 9, 7, 6, 3, 5, 2],\n [1, 4, 8, 0, 9, 7, 6, 5, 2],\n [1, 4, 8, 0, 9, 7, 6, 5, 3, 2],\n [1, 4, 8, 2],\n [1, 4, 8, 3, 0, 2],\n [1, 4, 8, 3, 0, 5, 2],\n [1, 4, 8, 3, 0, 5, 6, 2],\n [1, 4, 8, 3, 0, 5, 7, 6, 2],\n [1, 4, 8, 3, 0, 6, 2],\n [1, 4, 8, 3, 0, 6, 5, 2],\n [1, 4, 8, 3, 0, 6, 7, 5, 2],\n [1, 4, 8, 3, 0, 9, 7, 5, 2],\n [1, 4, 8, 3, 0, 9, 7, 5, 6, 2],\n [1, 4, 8, 3, 0, 9, 7, 6, 2],\n [1, 4, 8, 3, 0, 9, 7, 6, 5, 2],\n [1, 4, 8, 3, 2],\n [1, 4, 8, 3, 5, 0, 2],\n [1, 4, 8, 3, 5, 0, 6, 2],\n [1, 4, 8, 3, 5, 0, 9, 7, 6, 2],\n [1, 4, 8, 3, 5, 2],\n [1, 4, 8, 3, 5, 6, 0, 2],\n [1, 4, 8, 3, 5, 6, 2],\n [1, 4, 8, 3, 5, 6, 7, 9, 0, 2],\n [1, 4, 8, 3, 5, 7, 6, 0, 2],\n [1, 4, 8, 3, 5, 7, 6, 2],\n [1, 4, 8, 3, 5, 7, 9, 0, 2],\n [1, 4, 8, 3, 5, 7, 9, 0, 6, 2],\n [1, 4, 8, 3, 6, 0, 2],\n [1, 4, 8, 3, 6, 0, 5, 2],\n [1, 4, 8, 3, 6, 0, 9, 7, 5, 2],\n [1, 4, 8, 3, 6, 2],\n [1, 4, 8, 3, 6, 5, 0, 2],\n [1, 4, 8, 3, 6, 5, 2],\n [1, 4, 8, 3, 6, 5, 7, 9, 0, 2],\n [1, 4, 8, 3, 6, 7, 5, 0, 2],\n [1, 4, 8, 3, 6, 7, 5, 2],\n [1, 4, 8, 3, 6, 7, 9, 0, 2],\n [1, 4, 8, 3, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 5, 0, 2],\n [1, 4, 8, 5, 0, 3, 2],\n [1, 4, 8, 5, 0, 3, 6, 2],\n [1, 4, 8, 5, 0, 6, 2],\n [1, 4, 8, 5, 0, 6, 3, 2],\n [1, 4, 8, 5, 0, 9, 7, 6, 2],\n [1, 4, 8, 5, 0, 9, 7, 6, 3, 2],\n [1, 4, 8, 5, 2],\n [1, 4, 8, 5, 3, 0, 2],\n [1, 4, 8, 5, 3, 0, 6, 2],\n [1, 4, 8, 5, 3, 0, 9, 7, 6, 2],\n [1, 4, 8, 5, 3, 2],\n [1, 4, 8, 5, 3, 6, 0, 2],\n [1, 4, 8, 5, 3, 6, 2],\n [1, 4, 8, 5, 3, 6, 7, 9, 0, 2],\n [1, 4, 8, 5, 6, 0, 2],\n [1, 4, 8, 5, 6, 0, 3, 2],\n [1, 4, 8, 5, 6, 2],\n [1, 4, 8, 5, 6, 3, 0, 2],\n [1, 4, 8, 5, 6, 3, 2],\n [1, 4, 8, 5, 6, 7, 9, 0, 2],\n [1, 4, 8, 5, 6, 7, 9, 0, 3, 2],\n [1, 4, 8, 5, 7, 6, 0, 2],\n [1, 4, 8, 5, 7, 6, 0, 3, 2],\n [1, 4, 8, 5, 7, 6, 2],\n [1, 4, 8, 5, 7, 6, 3, 0, 2],\n [1, 4, 8, 5, 7, 6, 3, 2],\n [1, 4, 8, 5, 7, 9, 0, 2],\n [1, 4, 8, 5, 7, 9, 0, 3, 2],\n [1, 4, 8, 5, 7, 9, 0, 3, 6, 2],\n [1, 4, 8, 5, 7, 9, 0, 6, 2],\n [1, 4, 8, 5, 7, 9, 0, 6, 3, 2],\n [1, 4, 8, 6, 0, 2],\n [1, 4, 8, 6, 0, 3, 2],\n [1, 4, 8, 6, 0, 3, 5, 2],\n [1, 4, 8, 6, 0, 5, 2],\n [1, 4, 8, 6, 0, 5, 3, 2],\n [1, 4, 8, 6, 0, 9, 7, 5, 2],\n [1, 4, 8, 6, 0, 9, 7, 5, 3, 2],\n [1, 4, 8, 6, 2],\n [1, 4, 8, 6, 3, 0, 2],\n [1, 4, 8, 6, 3, 0, 5, 2],\n [1, 4, 8, 6, 3, 0, 9, 7, 5, 2],\n [1, 4, 8, 6, 3, 2],\n [1, 4, 8, 6, 3, 5, 0, 2],\n [1, 4, 8, 6, 3, 5, 2],\n [1, 4, 8, 6, 3, 5, 7, 9, 0, 2],\n [1, 4, 8, 6, 5, 0, 2],\n [1, 4, 8, 6, 5, 0, 3, 2],\n [1, 4, 8, 6, 5, 2],\n [1, 4, 8, 6, 5, 3, 0, 2],\n [1, 4, 8, 6, 5, 3, 2],\n [1, 4, 8, 6, 5, 7, 9, 0, 2],\n [1, 4, 8, 6, 5, 7, 9, 0, 3, 2],\n [1, 4, 8, 6, 7, 5, 0, 2],\n [1, 4, 8, 6, 7, 5, 0, 3, 2],\n [1, 4, 8, 6, 7, 5, 2],\n [1, 4, 8, 6, 7, 5, 3, 0, 2],\n [1, 4, 8, 6, 7, 5, 3, 2],\n [1, 4, 8, 6, 7, 9, 0, 2],\n [1, 4, 8, 6, 7, 9, 0, 3, 2],\n [1, 4, 8, 6, 7, 9, 0, 3, 5, 2],\n [1, 4, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 6, 7, 9, 0, 5, 3, 2],\n [1, 4, 9, 0, 2],\n [1, 4, 9, 0, 3, 2],\n [1, 4, 9, 0, 3, 5, 2],\n [1, 4, 9, 0, 3, 5, 6, 2],\n [1, 4, 9, 0, 3, 5, 6, 8, 2],\n [1, 4, 9, 0, 3, 5, 7, 6, 2],\n [1, 4, 9, 0, 3, 5, 7, 6, 8, 2],\n [1, 4, 9, 0, 3, 5, 8, 2],\n [1, 4, 9, 0, 3, 5, 8, 6, 2],\n [1, 4, 9, 0, 3, 6, 2],\n [1, 4, 9, 0, 3, 6, 5, 2],\n [1, 4, 9, 0, 3, 6, 5, 8, 2],\n [1, 4, 9, 0, 3, 6, 7, 5, 2],\n [1, 4, 9, 0, 3, 6, 7, 5, 8, 2],\n [1, 4, 9, 0, 3, 6, 8, 2],\n [1, 4, 9, 0, 3, 6, 8, 5, 2],\n [1, 4, 9, 0, 3, 8, 2],\n [1, 4, 9, 0, 3, 8, 5, 2],\n [1, 4, 9, 0, 3, 8, 5, 6, 2],\n [1, 4, 9, 0, 3, 8, 5, 7, 6, 2],\n [1, 4, 9, 0, 3, 8, 6, 2],\n [1, 4, 9, 0, 3, 8, 6, 5, 2],\n [1, 4, 9, 0, 3, 8, 6, 7, 5, 2],\n [1, 4, 9, 0, 5, 2],\n [1, 4, 9, 0, 5, 3, 2],\n [1, 4, 9, 0, 5, 3, 6, 2],\n [1, 4, 9, 0, 5, 3, 6, 8, 2],\n [1, 4, 9, 0, 5, 3, 8, 2],\n [1, 4, 9, 0, 5, 3, 8, 6, 2],\n [1, 4, 9, 0, 5, 6, 2],\n [1, 4, 9, 0, 5, 6, 3, 2],\n [1, 4, 9, 0, 5, 6, 3, 8, 2],\n [1, 4, 9, 0, 5, 6, 8, 2],\n [1, 4, 9, 0, 5, 6, 8, 3, 2],\n [1, 4, 9, 0, 5, 7, 6, 2],\n [1, 4, 9, 0, 5, 7, 6, 3, 2],\n [1, 4, 9, 0, 5, 7, 6, 3, 8, 2],\n [1, 4, 9, 0, 5, 7, 6, 8, 2],\n [1, 4, 9, 0, 5, 7, 6, 8, 3, 2],\n [1, 4, 9, 0, 5, 8, 2],\n [1, 4, 9, 0, 5, 8, 3, 2],\n [1, 4, 9, 0, 5, 8, 3, 6, 2],\n [1, 4, 9, 0, 5, 8, 6, 2],\n [1, 4, 9, 0, 5, 8, 6, 3, 2],\n [1, 4, 9, 0, 6, 2],\n [1, 4, 9, 0, 6, 3, 2],\n [1, 4, 9, 0, 6, 3, 5, 2],\n [1, 4, 9, 0, 6, 3, 5, 8, 2],\n [1, 4, 9, 0, 6, 3, 8, 2],\n [1, 4, 9, 0, 6, 3, 8, 5, 2],\n [1, 4, 9, 0, 6, 5, 2],\n [1, 4, 9, 0, 6, 5, 3, 2],\n [1, 4, 9, 0, 6, 5, 3, 8, 2],\n [1, 4, 9, 0, 6, 5, 8, 2],\n [1, 4, 9, 0, 6, 5, 8, 3, 2],\n [1, 4, 9, 0, 6, 7, 5, 2],\n [1, 4, 9, 0, 6, 7, 5, 3, 2],\n [1, 4, 9, 0, 6, 7, 5, 3, 8, 2],\n [1, 4, 9, 0, 6, 7, 5, 8, 2],\n [1, 4, 9, 0, 6, 7, 5, 8, 3, 2],\n [1, 4, 9, 0, 6, 8, 2],\n [1, 4, 9, 0, 6, 8, 3, 2],\n [1, 4, 9, 0, 6, 8, 3, 5, 2],\n [1, 4, 9, 0, 6, 8, 5, 2],\n [1, 4, 9, 0, 6, 8, 5, 3, 2],\n [1, 4, 9, 0, 8, 2],\n [1, 4, 9, 0, 8, 3, 2],\n [1, 4, 9, 0, 8, 3, 5, 2],\n [1, 4, 9, 0, 8, 3, 5, 6, 2],\n [1, 4, 9, 0, 8, 3, 5, 7, 6, 2],\n [1, 4, 9, 0, 8, 3, 6, 2],\n [1, 4, 9, 0, 8, 3, 6, 5, 2],\n [1, 4, 9, 0, 8, 3, 6, 7, 5, 2],\n [1, 4, 9, 0, 8, 5, 2],\n [1, 4, 9, 0, 8, 5, 3, 2],\n [1, 4, 9, 0, 8, 5, 3, 6, 2],\n [1, 4, 9, 0, 8, 5, 6, 2],\n [1, 4, 9, 0, 8, 5, 6, 3, 2],\n [1, 4, 9, 0, 8, 5, 7, 6, 2],\n [1, 4, 9, 0, 8, 5, 7, 6, 3, 2],\n [1, 4, 9, 0, 8, 6, 2],\n [1, 4, 9, 0, 8, 6, 3, 2],\n [1, 4, 9, 0, 8, 6, 3, 5, 2],\n [1, 4, 9, 0, 8, 6, 5, 2],\n [1, 4, 9, 0, 8, 6, 5, 3, 2],\n [1, 4, 9, 0, 8, 6, 7, 5, 2],\n [1, 4, 9, 0, 8, 6, 7, 5, 3, 2],\n [1, 4, 9, 7, 5, 0, 2],\n [1, 4, 9, 7, 5, 0, 3, 2],\n [1, 4, 9, 7, 5, 0, 3, 6, 2],\n [1, 4, 9, 7, 5, 0, 3, 6, 8, 2],\n [1, 4, 9, 7, 5, 0, 3, 8, 2],\n [1, 4, 9, 7, 5, 0, 3, 8, 6, 2],\n [1, 4, 9, 7, 5, 0, 6, 2],\n [1, 4, 9, 7, 5, 0, 6, 3, 2],\n [1, 4, 9, 7, 5, 0, 6, 3, 8, 2],\n [1, 4, 9, 7, 5, 0, 6, 8, 2],\n [1, 4, 9, 7, 5, 0, 6, 8, 3, 2],\n [1, 4, 9, 7, 5, 0, 8, 2],\n [1, 4, 9, 7, 5, 0, 8, 3, 2],\n [1, 4, 9, 7, 5, 0, 8, 3, 6, 2],\n [1, 4, 9, 7, 5, 0, 8, 6, 2],\n [1, 4, 9, 7, 5, 0, 8, 6, 3, 2],\n [1, 4, 9, 7, 5, 2],\n [1, 4, 9, 7, 5, 3, 0, 2],\n [1, 4, 9, 7, 5, 3, 0, 6, 2],\n [1, 4, 9, 7, 5, 3, 0, 6, 8, 2],\n [1, 4, 9, 7, 5, 3, 0, 8, 2],\n [1, 4, 9, 7, 5, 3, 0, 8, 6, 2],\n [1, 4, 9, 7, 5, 3, 2],\n [1, 4, 9, 7, 5, 3, 6, 0, 2],\n [1, 4, 9, 7, 5, 3, 6, 0, 8, 2],\n [1, 4, 9, 7, 5, 3, 6, 2],\n [1, 4, 9, 7, 5, 3, 6, 8, 0, 2],\n [1, 4, 9, 7, 5, 3, 6, 8, 2],\n [1, 4, 9, 7, 5, 3, 8, 0, 2],\n [1, 4, 9, 7, 5, 3, 8, 0, 6, 2],\n [1, 4, 9, 7, 5, 3, 8, 2],\n [1, 4, 9, 7, 5, 3, 8, 6, 0, 2],\n [1, 4, 9, 7, 5, 3, 8, 6, 2],\n [1, 4, 9, 7, 5, 6, 0, 2],\n [1, 4, 9, 7, 5, 6, 0, 3, 2],\n [1, 4, 9, 7, 5, 6, 0, 3, 8, 2],\n [1, 4, 9, 7, 5, 6, 0, 8, 2],\n [1, 4, 9, 7, 5, 6, 0, 8, 3, 2],\n [1, 4, 9, 7, 5, 6, 2],\n [1, 4, 9, 7, 5, 6, 3, 0, 2],\n [1, 4, 9, 7, 5, 6, 3, 0, 8, 2],\n [1, 4, 9, 7, 5, 6, 3, 2],\n [1, 4, 9, 7, 5, 6, 3, 8, 0, 2],\n [1, 4, 9, 7, 5, 6, 3, 8, 2],\n [1, 4, 9, 7, 5, 6, 8, 0, 2],\n [1, 4, 9, 7, 5, 6, 8, 0, 3, 2],\n [1, 4, 9, 7, 5, 6, 8, 2],\n [1, 4, 9, 7, 5, 6, 8, 3, 0, 2],\n [1, 4, 9, 7, 5, 6, 8, 3, 2],\n [1, 4, 9, 7, 5, 8, 0, 2],\n [1, 4, 9, 7, 5, 8, 0, 3, 2],\n [1, 4, 9, 7, 5, 8, 0, 3, 6, 2],\n [1, 4, 9, 7, 5, 8, 0, 6, 2],\n [1, 4, 9, 7, 5, 8, 0, 6, 3, 2],\n [1, 4, 9, 7, 5, 8, 2],\n [1, 4, 9, 7, 5, 8, 3, 0, 2],\n [1, 4, 9, 7, 5, 8, 3, 0, 6, 2],\n [1, 4, 9, 7, 5, 8, 3, 2],\n [1, 4, 9, 7, 5, 8, 3, 6, 0, 2],\n [1, 4, 9, 7, 5, 8, 3, 6, 2],\n [1, 4, 9, 7, 5, 8, 6, 0, 2],\n [1, 4, 9, 7, 5, 8, 6, 0, 3, 2],\n [1, 4, 9, 7, 5, 8, 6, 2],\n [1, 4, 9, 7, 5, 8, 6, 3, 0, 2],\n ...]\n\n\n\n# Node Connectivity: from i to j\n# If we wanted to block the message from i to j by removing nodes from the network, how many\n# nodes would we need to remove?\nnx.node_connectivity(graph_er, 1, 2)\n\n6\n\n\n\n# Which nodes?(the set of nodes we must remove in order to block msg from i to j)\n# {} when two nodes are connected!\nnx.minimum_node_cut(graph_er, 1, 2)\n\n{}\n\n\n\n\nIf we wanted to block the message from i to j by removing edges from the network, how many edges would we need to remove?\n\nnx.edge_connectivity(graph_er, 1, 2)\n\n6\n\n\n\n# Which edges?\nnx.minimum_edge_cut(graph_er, 1, 2)\n\n{(0, 2), (1, 2), (3, 2), (5, 2), (6, 2), (8, 2)}"
  },
  {
    "objectID": "references/networkx_kaggle/3-networkx-basic-concepts.html#installing-networkx",
    "href": "references/networkx_kaggle/3-networkx-basic-concepts.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random"
  },
  {
    "objectID": "references/networkx_kaggle/3-networkx-basic-concepts.html#basic-concepts",
    "href": "references/networkx_kaggle/3-networkx-basic-concepts.html#basic-concepts",
    "title": "NetworkX",
    "section": "",
    "text": "graph_karate = nx.karate_club_graph()\n\nnx.draw(graph_karate, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe degree of a node in a network is the number of edges that it is connected to. In a network with \\(N\\) nodes and \\(M\\) edges, the degree \\(k_i\\) of a node \\(i\\) is defined as:\n\\[ k*i = \\sum*{j=1}^M A\\_{ij} \\]\nwhere \\(A\\) is the adjacency matrix of the network, with \\(A_{ij} = 1\\) if there is an edge connecting nodes \\(i\\) and \\(j\\), and \\(A_{ij} = 0\\) otherwise.\nThe neighborhood of a node \\(i\\) is the set of nodes that are directly connected to \\(i\\) by an edge. The neighborhood of \\(i\\) is denoted as \\(N_i\\) and is defined as:\n\\[ N*i = \\{j \\mid A*{ij} = 1\\} \\]\nwhere \\(A\\) is the adjacency matrix of the network, with \\(A_{ij} = 1\\) if there is an edge connecting nodes \\(i\\) and \\(j\\), and \\(A_{ij} = 0\\) otherwise.\n\nnode = 2\nneighborhood = list(nx.neighbors(graph_karate, node))\nneighborhood\n\n[0, 1, 3, 7, 8, 9, 13, 27, 28, 32]\n\n\n\n# degree = # neighbor\nlen(neighborhood)\n\n10\n\n\n\n# Degree\ngraph_karate.degree(node)\n\n10\n\n\n\n# All degrees\ndict(graph_karate.degree)\n\n{0: 16,\n 1: 9,\n 2: 10,\n 3: 6,\n 4: 3,\n 5: 4,\n 6: 4,\n 7: 4,\n 8: 5,\n 9: 2,\n 10: 3,\n 11: 1,\n 12: 2,\n 13: 5,\n 14: 2,\n 15: 2,\n 16: 2,\n 17: 2,\n 18: 2,\n 19: 3,\n 20: 2,\n 21: 2,\n 22: 2,\n 23: 5,\n 24: 3,\n 25: 3,\n 26: 2,\n 27: 4,\n 28: 3,\n 29: 4,\n 30: 4,\n 31: 6,\n 32: 12,\n 33: 17}\n\n\n\n\n\nTriadic closure refers to the tendency for people who share connections in a social network to become connected, also known as the “friend of a friend” effect.\nOne measure of triadic closure in a network is the clustering coefficient, which quantifies the degree to which nodes tend to cluster together in triads. The clustering coefficient of a node is defined as the fraction of the node’s neighbors that are also neighbors of each other. The clustering coefficient of a network is the average clustering coefficient over all nodes in the network.\n\n\nThe clustering coefficient of a node \\(i\\) is given by:\n\\[C_i = \\frac{2e_i}{k_i(k_i-1)}\\]\nwhere \\(e_i\\) is the number of edges between the neighbors of node \\(i\\), and \\(k_i\\) is the degree of node \\(i\\) (i.e., the number of edges incident to \\(i\\)).\n\nnx.draw_networkx(graph_karate)\n\n\n\n\n\n\n\n\n\n# local clustring (if dominator is zero =&gt; zero)\nnx.clustering(graph_karate, 2)\n\n0.24444444444444444\n\n\n\n# list of Clustring Coefficients\nnx.clustering(graph_karate)\n\n{0: 0.15,\n 1: 0.3333333333333333,\n 2: 0.24444444444444444,\n 3: 0.6666666666666666,\n 4: 0.6666666666666666,\n 5: 0.5,\n 6: 0.5,\n 7: 1.0,\n 8: 0.5,\n 9: 0,\n 10: 0.6666666666666666,\n 11: 0,\n 12: 1.0,\n 13: 0.6,\n 14: 1.0,\n 15: 1.0,\n 16: 1.0,\n 17: 1.0,\n 18: 1.0,\n 19: 0.3333333333333333,\n 20: 1.0,\n 21: 1.0,\n 22: 1.0,\n 23: 0.4,\n 24: 0.3333333333333333,\n 25: 0.3333333333333333,\n 26: 1.0,\n 27: 0.16666666666666666,\n 28: 0.3333333333333333,\n 29: 0.6666666666666666,\n 30: 0.5,\n 31: 0.2,\n 32: 0.19696969696969696,\n 33: 0.11029411764705882}\n\n\n\n\nMany observed social networks are more clustered than would arise at random\nThe clustering coefficient of the network is the average of the clustering coefficients of all nodes:\n\\[C = \\frac{1}{N}\\sum_{i=1}^{N} C_i\\]\nwhere \\(N\\) is the total number of nodes in the network.\n\n# Average clustering\nnx.average_clustering(graph_karate)\n\n0.5706384782076823\n\n\n\n\n\n\nTransitivity is a property of a network that measures the likelihood that, if two nodes in the network share a common neighbor, they will also be directly connected to each other. In other words, it measures the tendency for “triangles” to form in the network.\nFormally, the transitivity of a network is defined as the ratio of the number of triangles in the network to the number of connected triples of nodes (i.e., triples of nodes that are directly connected to each other or share a common neighbor). In mathematical notation, the transitivity of a network is given by:\n\\[\nT = \\frac{3 \\times \\text{number of triangles}}{\\text{number of connected triples}}\n\\]\nA high transitivity indicates that nodes in the network tend to form clusters or communities, while a low transitivity indicates that the network is more of a random or decentralized structure. Transitivity is closely related to the concept of clustering coefficient, which measures the tendency for nodes to form local clusters or neighborhoods.\n\n# transitivity\n# transitivity weights nodes with large degree higher\nnx.transitivity(graph_karate)\n\n0.2556818181818182\n\n\n\n\n\n\nA path between two nodes \\(A\\) and \\(B\\) in a network is a sequence of nodes \\(A, X_1, X_2, ..., X_n, B\\) and a sequence of edges \\((A, X_1), (X_1, X_2), ..., (X_n, B)\\), where each node and edge in the sequence is adjacent to the previous and next node or edge in the sequence.\nThe length of a path is the number of edges in the path. A path with length 1 is an edge between two nodes, while a path with length 2 is a sequence of two edges and three nodes, and so on. The shortest path between two nodes is the path with the minimum length that connects them.\n\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\n\n# Generate all simple paths between nodes 1 and 3\npaths = nx.all_simple_paths(graph_karate, source=1, target=3)\n\n# Print the first 10 simple paths\nfor _ in range(10):\n    print(next(paths))\n\n[1, 0, 2, 3]\n[1, 0, 2, 7, 3]\n[1, 0, 2, 8, 30, 32, 14, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 15, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 18, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 20, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 22, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3]\n[1, 0, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3]\n\n\n\npath1 = next(paths)\n# check if a path is valid in the graph\nis_valid = nx.is_simple_path(\n    graph_karate, path1\n)  # A simple path is a path that does not contain any repeated nodes.\nprint(\"Is valid path?\", is_valid)\n\nIs valid path? True\n\n\n\n# a False example\nnx.is_simple_path(graph_karate, [0, 8, 5])\n\nFalse\n\n\n\n# compute the edge list of a walk\nedge_list = [\n    (path1[i], path1[i + 1]) for i in range(len(path1) - 1)\n]  # len(Path1)-1=length of a path\nedge_list\n\n[(1, 0),\n (0, 2),\n (2, 8),\n (8, 30),\n (30, 32),\n (32, 23),\n (23, 25),\n (25, 31),\n (31, 24),\n (24, 27),\n (27, 33),\n (33, 13),\n (13, 3)]\n\n\n\n# compute the weight of a walk\nweight = sum(\n    graph_karate[u][v][\"weight\"] for u, v in edge_list if \"weight\" in graph_karate[u][v]\n)\nprint(\"Weight of walk:\", weight)\n\nWeight of walk: 52\n\n\n\n\n\n\n# Find all cycles in the graph\ncycles = nx.simple_cycles(graph_karate)\nlist(cycles)\n\n[[0, 4, 6],\n [0, 4, 6, 5],\n [0, 4, 6, 5, 10],\n [0, 4, 6, 16, 5],\n [0, 4, 6, 16, 5, 10],\n [0, 4, 10],\n [0, 4, 10, 5],\n [0, 4, 10, 5, 6],\n [0, 4, 10, 5, 16, 6],\n [0, 5, 6],\n [0, 5, 6, 4, 10],\n [0, 5, 10],\n [0, 5, 10, 4, 6],\n [0, 5, 16, 6],\n [0, 5, 16, 6, 4, 10],\n [0, 6, 4, 10],\n [0, 6, 5, 10],\n [0, 6, 16, 5, 10],\n [4, 6, 5, 10],\n [4, 6, 16, 5, 10],\n [16, 5, 6],\n [0, 1, 2],\n [0, 1, 2, 3],\n [0, 1, 2, 3, 7],\n [0, 1, 2, 3, 12],\n [0, 1, 2, 3, 13],\n [0, 1, 2, 3, 13, 33, 8],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 30, 32, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 8, 32, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 8],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 14, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 14, 32, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 8],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 15, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 15, 32, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 8],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 18, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 18, 32, 31],\n [0, 1, 2, 3, 13, 33, 19],\n [0, 1, 2, 3, 13, 33, 20, 32, 8],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 20, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 20, 32, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 8],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 22, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 22, 32, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 26, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 28, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 23, 32, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 29, 32, 31],\n [0, 1, 2, 3, 13, 33, 30, 8],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 8, 32, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 8],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 30, 32, 31],\n [0, 1, 2, 3, 13, 33, 31],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 31, 32, 8],\n [0, 1, 2, 3, 13, 33, 31, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 32, 8],\n [0, 1, 2, 3, 13, 33, 32, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 3, 13, 33, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 3, 13, 33, 32, 30, 8],\n [0, 1, 2, 3, 13, 33, 32, 31],\n [0, 1, 2, 7],\n [0, 1, 2, 7, 3],\n [0, 1, 2, 7, 3, 12],\n [0, 1, 2, 7, 3, 13],\n [0, 1, 2, 7, 3, 13, 33, 8],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 30, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 8, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 14, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 15, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 18, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 19],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 20, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 22, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 26, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 28, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 25, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 27, 24, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 23, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 29, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 8, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 30, 32, 31],\n [0, 1, 2, 7, 3, 13, 33, 31],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 29, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 25, 24, 27, 23, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 31, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 7, 3, 13, 33, 32, 30, 8],\n [0, 1, 2, 7, 3, 13, 33, 32, 31],\n [0, 1, 2, 8],\n [0, 1, 2, 8, 30, 32, 14, 33, 13],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 14, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 14, 33, 19],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 14, 33, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 13],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 15, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 15, 33, 19],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 15, 33, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 13],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 18, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 18, 33, 19],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 18, 33, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 13],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 20, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 20, 33, 19],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 20, 33, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 13],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 22, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 22, 33, 19],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 22, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 26, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 29, 33, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 23, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 23, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 25, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 24, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 27, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 23, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 26, 33, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 29, 33, 31],\n [0, 1, 2, 8, 30, 32, 31],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 25, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 26, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 29, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 23, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 25, 24, 27, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 28, 33, 19],\n [0, 1, 2, 8, 30, 32, 31, 33, 13],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 31, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 31, 33, 19],\n [0, 1, 2, 8, 30, 32, 33, 13],\n [0, 1, 2, 8, 30, 32, 33, 13, 3],\n [0, 1, 2, 8, 30, 32, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 32, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 32, 33, 19],\n [0, 1, 2, 8, 30, 32, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 28, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 32, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 32, 33, 31],\n [0, 1, 2, 8, 30, 33, 13],\n [0, 1, 2, 8, 30, 33, 13, 3],\n [0, 1, 2, 8, 30, 33, 13, 3, 7],\n [0, 1, 2, 8, 30, 33, 13, 3, 12],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 14, 32, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 15, 32, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 18, 32, 31],\n [0, 1, 2, 8, 30, 33, 19],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 20, 32, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 22, 32, 31],\n [0, 1, 2, 8, 30, 33, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 26, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 23, 29, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 23, 32, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 28, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 25, 24, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 25, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 27, 24, 25, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 27, 24, 31],\n [0, 1, 2, 8, 30, 33, 29, 23, 32, 31],\n ...]\n\n\n\n\n\nA geodesic between two nodes \\(A\\) and \\(B\\) in a network is the shortest path that connects them. In other words, it is the path with the minimum number of edges that must be traversed to get from node \\(A\\) to node \\(B\\). The length of a geodesic is the number of edges in the path.\n\n# graph_karateeodesic = shortest path\nnx.shortest_path(graph_karate, 1, 2)\n\n[1, 2]\n\n\n\n# compute a shortest path between two nodes\npath = nx.shortest_path(graph_karate, source=1, target=3)\n\n# compute the corresponding edges of the path\nedges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]\n\n# draw the graph and the path\npos = nx.circular_layout(graph_karate)\nnx.draw(graph_karate, pos, with_labels=True)\nnx.draw_networkx_edges(graph_karate, pos, edgelist=edges, edge_color=\"r\", width=3)\n\n\n\n\n\n\n\n\n\n# graph_karateeodesic length\nnx.shortest_path_length(graph_karate, 1, 2)\n\n1\n\n\nFinding the Geodesic from node i to every other node is computationaly complex, so we need an effeicient algorithm to do so.\nHere we use breadth-first search:\n\n# breadth-first search algorithm\ngraph_tree = nx.bfs_tree(graph_karate, 1)\nnx.draw_networkx(graph_tree, with_labels=True)\nlist(graph_tree.edges())\n\n[(1, 0),\n (1, 2),\n (1, 3),\n (1, 7),\n (1, 13),\n (1, 17),\n (1, 19),\n (1, 21),\n (1, 30),\n (0, 4),\n (0, 5),\n (0, 6),\n (0, 8),\n (0, 10),\n (0, 11),\n (0, 12),\n (0, 31),\n (2, 9),\n (2, 27),\n (2, 28),\n (2, 32),\n (13, 33),\n (5, 16),\n (31, 24),\n (31, 25),\n (27, 23),\n (32, 14),\n (32, 15),\n (32, 18),\n (32, 20),\n (32, 22),\n (32, 29),\n (33, 26)]\n\n\n\n\n\n\n\n\n\n\n# all shortest path\nnx.shortest_path_length(graph_karate, 1)  # outputs a dictionary\n\n{1: 0,\n 0: 1,\n 2: 1,\n 3: 1,\n 7: 1,\n 13: 1,\n 17: 1,\n 19: 1,\n 21: 1,\n 30: 1,\n 4: 2,\n 5: 2,\n 6: 2,\n 8: 2,\n 10: 2,\n 11: 2,\n 12: 2,\n 31: 2,\n 9: 2,\n 27: 2,\n 28: 2,\n 32: 2,\n 33: 2,\n 16: 3,\n 24: 3,\n 25: 3,\n 23: 3,\n 14: 3,\n 15: 3,\n 18: 3,\n 20: 3,\n 22: 3,\n 29: 3,\n 26: 3}\n\n\n\n# Average shortest path\nnx.average_shortest_path_length(graph_karate)\n\n2.408199643493761\n\n\n\n\n\nThe eccentricity of a node \\(u\\) in a network is the maximum distance between \\(u\\) and any other node in the network. In other words, it is the maximum length of the shortest path between \\(u\\) and any other node. The eccentricity of a network is the maximum eccentricity of any node in the network.\n\n# Eccentricity\n# the largest distance between n and all ohter nodes:\nnx.eccentricity(graph_karate)\n\n{0: 3,\n 1: 3,\n 2: 3,\n 3: 3,\n 4: 4,\n 5: 4,\n 6: 4,\n 7: 4,\n 8: 3,\n 9: 4,\n 10: 4,\n 11: 4,\n 12: 4,\n 13: 3,\n 14: 5,\n 15: 5,\n 16: 5,\n 17: 4,\n 18: 5,\n 19: 3,\n 20: 5,\n 21: 4,\n 22: 5,\n 23: 5,\n 24: 4,\n 25: 4,\n 26: 5,\n 27: 4,\n 28: 4,\n 29: 5,\n 30: 4,\n 31: 3,\n 32: 4,\n 33: 4}\n\n\n\n# Diameter: max Eccentricity between two nodes in whole network (max max)\nnx.diameter(graph_karate)\n\n5\n\n\n\n# Diameter is max eccentricity\nmax(nx.eccentricity(graph_karate).values())\n\n5\n\n\n\n# radius: min Eccentricity between two nodes in whole network (min max)\nnx.radius(graph_karate)\n\n3\n\n\n\n# radius is min eccentricity\nmin(nx.eccentricity(graph_karate).values())\n\n3\n\n\n\n# periphery\n# Eccentricity=diameter\nnx.periphery(graph_karate)\n\n[14, 15, 16, 18, 20, 22, 23, 26, 29]\n\n\n\n# the center of a graph : Eccentricity=radius\nnx.center(graph_karate)\n\n[0, 1, 2, 3, 8, 13, 19, 31]\n\n\n\n\n\n\n\nNetworkX provides several built-in network datasets that can be used for testing and experimentation. These datasets are available in the NetworkX library itself and can be loaded using functions that start with the prefix nx. followed by the name of the dataset.\nHere are some examples of the built-in network datasets in NetworkX:\n\nnx.karate_club_graph() - Returns the Zachary’s Karate Club network, a social network of a karate club, where each node represents a member of the club, and each edge represents a friendly relationship between members.\nnx.les_miserables_graph() - Returns a network of characters in the novel “Les Miserables” by Victor Hugo, where each node represents a character in the novel, and each edge represents a co-occurrence of two characters in a chapter.\nnx.davis_southern_women_graph() - Returns a network of the social interactions between women in a southern US town in the 1930s, where each node represents a woman, and each edge represents a social relation between two women.\n\nThese are just a few examples of the built-in network datasets in NetworkX. You can find more information about the available datasets and their usage in the NetworkX documentation.\n\n# An example\ngraph_families = nx.florentine_families_graph()\nnx.draw(graph_families, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nThe Karate Club graph is a social network representing friendships among 34 members of a karate club, as observed by Wayne W. Zachary in 1977. Each node in the graph represents a member of the club, and each edge represents a friendship between two members. The graph has 34 nodes and 78 edges.\nThe Karate Club is a well-known example in social network analysis and has been used to study various network properties, such as community structure and centrality measures. The graph is characterized by a split in the club into two factions, led by the club instructor (node 0) and one of the members (node 33), respectively. This split was caused by a dispute between the two leaders, which eventually led to the formation of two separate karate clubs.\n\n# Karate Club\ngraph_karate = nx.karate_club_graph()\ngraph_karate = nx.convert_node_labels_to_integers(graph_karate, first_label=1)\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\nthe club instructor (node 0) and one of the members (node 33) representation\n\n# Set the positions of the nodes using the Kamada-Kawai layout\npos = nx.kamada_kawai_layout(graph_karate)\n\n# Draw the graph with red nodes for node 0 (club instructor) and node 33 (member) : they are now 1 and 34\nred_nodes = [1, 34]\nnode_colors = [\"red\" if node in red_nodes else \"blue\" for node in graph_karate.nodes()]\nnx.draw_networkx_nodes(graph_karate, pos, node_color=node_colors)\nnx.draw_networkx_edges(graph_karate, pos)\n\n# Draw the labels for the nodes\nnx.draw_networkx_labels(graph_karate, pos)\n\n# Show the graph\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# disconnection based on random selection\nwhile nx.is_connected(graph_karate):\n    # delete an edge\n    i = random.choice(list(nx.nodes(graph_karate)))\n    j = random.choice(list(nx.nodes(graph_karate)))\n    if graph_karate.has_edge(i, j):\n        graph_karate.remove_edge(i, j)\nnx.draw_networkx(graph_karate)\n\n\n\n\n\n\n\n\n\n# connectivity\n# connected components\nnx.number_connected_components(graph_karate)\n\n2\n\n\n\nsorted(nx.connected_components(graph_karate))\n\n[{1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  19,\n  20,\n  21,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33,\n  34},\n {18}]\n\n\n\n# which component  each node belongs?\nnx.node_connected_component(graph_karate, 1)\n\n{1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9,\n 10,\n 11,\n 12,\n 13,\n 14,\n 15,\n 16,\n 17,\n 19,\n 20,\n 21,\n 22,\n 23,\n 24,\n 25,\n 26,\n 27,\n 28,\n 29,\n 30,\n 31,\n 32,\n 33,\n 34}\n\n\n\n\nweakly connected = replacing all directed edges with undirected edges produces a conneceted undirected graph\nstrongly connected = with directions\n\n# create an empty directed graph\ngraph_directed = nx.DiGraph()\n\n# add nodes to the graph\ngraph_directed.add_nodes_from(\n    [\"Alice\", \"Bob\", \"Charlie\", \"Dave\", \"Eve\", \"Adam\", \"Sarah\"]\n)\n\n# add directed edges to the graph\ngraph_directed.add_edge(\"Alice\", \"Bob\")\ngraph_directed.add_edge(\"Bob\", \"Charlie\")\ngraph_directed.add_edge(\"Dave\", \"Eve\")\ngraph_directed.add_edge(\"Alice\", \"Eve\")\ngraph_directed.add_edge(\"Eve\", \"Alice\")\ngraph_directed.add_edge(\"Adam\", \"Sarah\")\n# graph_directed.add_edge('Adam','Bob')\n\n# draw the graph\nnx.draw(graph_directed, with_labels=True)\n\n# show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# weakly connected\nnx.is_weakly_connected(graph_directed)\n\nFalse\n\n\n\n# strongly connected\nnx.is_strongly_connected(graph_directed)\n\nFalse\n\n\n\n# weakly connected components\nsorted(nx.weakly_connected_components(graph_directed))\n\n[{'Alice', 'Bob', 'Charlie', 'Dave', 'Eve'}, {'Adam', 'Sarah'}]\n\n\n\n# strongly connected components\nsorted(nx.strongly_connected_components(graph_directed))\n\n[{'Charlie'}, {'Bob'}, {'Alice', 'Eve'}, {'Dave'}, {'Sarah'}, {'Adam'}]\n\n\n\n\n\n\n\nnetwork robustness is the ability of a network to maintain its general structral properties when it faces failure or attacks\ntypes of attack: removal of nodes or edges\nRobustness = maintain connectivity\nexamples: airport closure, internet router failures, power line failure\n\n\nThe Erdős-Rényi random graph model is a classic random graph model that generates a graph with a fixed number of nodes, where each pair of nodes is connected with a probability p.\n\n# create an Erdős-Rényi random network\n\nn = 10  # number of nodes\np = 0.6  # probability of edge creation\ngraph_er = nx.erdos_renyi_graph(n, p)\n\n# draw the graph\nnx.draw(graph_er, with_labels=True)\n\n\n\n\n\n\n\n\nNode connectivity: Minimum number of nodes needed to disconnect a graph or pair of nodes.\nEdge connectivity: Minimum number of edges needed to disconnect a graph or pair of nodes.\nGraphs with large node and edge connectivity are more robust to the loss of nodes and edges.\n\n# what is the smallest number of nodes that can be romoved from graph in order to disconnect it?\nnx.node_connectivity(graph_er)\n\n4\n\n\n\n# which nodes?(the smallest set of nodes that needs to be removed to disconnect the graph)\nnx.minimum_node_cut(graph_er)\n\n{0, 1, 4, 7}\n\n\n\n# what is the smallest number of edges that can be romoved from graph in order to disconnect it?\nnx.edge_connectivity(graph_er)\n\n4\n\n\n\n# which edge(s)?\nnx.minimum_edge_cut(graph_er)\n\n{(1, 7), (5, 7), (6, 7), (9, 7)}\n\n\n\n\n\n\n\n# all paths from i to j\nsorted(nx.all_simple_paths(graph_er, 1, 2))\n\n[[1, 0, 2],\n [1, 0, 3, 2],\n [1, 0, 3, 4, 8, 2],\n [1, 0, 3, 4, 8, 5, 2],\n [1, 0, 3, 4, 8, 5, 6, 2],\n [1, 0, 3, 4, 8, 5, 7, 6, 2],\n [1, 0, 3, 4, 8, 6, 2],\n [1, 0, 3, 4, 8, 6, 5, 2],\n [1, 0, 3, 4, 8, 6, 7, 5, 2],\n [1, 0, 3, 4, 9, 7, 5, 2],\n [1, 0, 3, 4, 9, 7, 5, 6, 2],\n [1, 0, 3, 4, 9, 7, 5, 6, 8, 2],\n [1, 0, 3, 4, 9, 7, 5, 8, 2],\n [1, 0, 3, 4, 9, 7, 5, 8, 6, 2],\n [1, 0, 3, 4, 9, 7, 6, 2],\n [1, 0, 3, 4, 9, 7, 6, 5, 2],\n [1, 0, 3, 4, 9, 7, 6, 5, 8, 2],\n [1, 0, 3, 4, 9, 7, 6, 8, 2],\n [1, 0, 3, 4, 9, 7, 6, 8, 5, 2],\n [1, 0, 3, 5, 2],\n [1, 0, 3, 5, 6, 2],\n [1, 0, 3, 5, 6, 7, 9, 4, 8, 2],\n [1, 0, 3, 5, 6, 8, 2],\n [1, 0, 3, 5, 7, 6, 2],\n [1, 0, 3, 5, 7, 6, 8, 2],\n [1, 0, 3, 5, 7, 9, 4, 8, 2],\n [1, 0, 3, 5, 7, 9, 4, 8, 6, 2],\n [1, 0, 3, 5, 8, 2],\n [1, 0, 3, 5, 8, 4, 9, 7, 6, 2],\n [1, 0, 3, 5, 8, 6, 2],\n [1, 0, 3, 6, 2],\n [1, 0, 3, 6, 5, 2],\n [1, 0, 3, 6, 5, 7, 9, 4, 8, 2],\n [1, 0, 3, 6, 5, 8, 2],\n [1, 0, 3, 6, 7, 5, 2],\n [1, 0, 3, 6, 7, 5, 8, 2],\n [1, 0, 3, 6, 7, 9, 4, 8, 2],\n [1, 0, 3, 6, 7, 9, 4, 8, 5, 2],\n [1, 0, 3, 6, 8, 2],\n [1, 0, 3, 6, 8, 4, 9, 7, 5, 2],\n [1, 0, 3, 6, 8, 5, 2],\n [1, 0, 3, 8, 2],\n [1, 0, 3, 8, 4, 9, 7, 5, 2],\n [1, 0, 3, 8, 4, 9, 7, 5, 6, 2],\n [1, 0, 3, 8, 4, 9, 7, 6, 2],\n [1, 0, 3, 8, 4, 9, 7, 6, 5, 2],\n [1, 0, 3, 8, 5, 2],\n [1, 0, 3, 8, 5, 6, 2],\n [1, 0, 3, 8, 5, 7, 6, 2],\n [1, 0, 3, 8, 6, 2],\n [1, 0, 3, 8, 6, 5, 2],\n [1, 0, 3, 8, 6, 7, 5, 2],\n [1, 0, 5, 2],\n [1, 0, 5, 3, 2],\n [1, 0, 5, 3, 4, 8, 2],\n [1, 0, 5, 3, 4, 8, 6, 2],\n [1, 0, 5, 3, 4, 9, 7, 6, 2],\n [1, 0, 5, 3, 4, 9, 7, 6, 8, 2],\n [1, 0, 5, 3, 6, 2],\n [1, 0, 5, 3, 6, 7, 9, 4, 8, 2],\n [1, 0, 5, 3, 6, 8, 2],\n [1, 0, 5, 3, 8, 2],\n [1, 0, 5, 3, 8, 4, 9, 7, 6, 2],\n [1, 0, 5, 3, 8, 6, 2],\n [1, 0, 5, 6, 2],\n [1, 0, 5, 6, 3, 2],\n [1, 0, 5, 6, 3, 4, 8, 2],\n [1, 0, 5, 6, 3, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 3, 2],\n [1, 0, 5, 6, 7, 9, 4, 3, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 8, 2],\n [1, 0, 5, 6, 7, 9, 4, 8, 3, 2],\n [1, 0, 5, 6, 8, 2],\n [1, 0, 5, 6, 8, 3, 2],\n [1, 0, 5, 6, 8, 4, 3, 2],\n [1, 0, 5, 7, 6, 2],\n [1, 0, 5, 7, 6, 3, 2],\n [1, 0, 5, 7, 6, 3, 4, 8, 2],\n [1, 0, 5, 7, 6, 3, 8, 2],\n [1, 0, 5, 7, 6, 8, 2],\n [1, 0, 5, 7, 6, 8, 3, 2],\n [1, 0, 5, 7, 6, 8, 4, 3, 2],\n [1, 0, 5, 7, 9, 4, 3, 2],\n [1, 0, 5, 7, 9, 4, 3, 6, 2],\n [1, 0, 5, 7, 9, 4, 3, 6, 8, 2],\n [1, 0, 5, 7, 9, 4, 3, 8, 2],\n [1, 0, 5, 7, 9, 4, 3, 8, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 2],\n [1, 0, 5, 7, 9, 4, 8, 3, 2],\n [1, 0, 5, 7, 9, 4, 8, 3, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 6, 2],\n [1, 0, 5, 7, 9, 4, 8, 6, 3, 2],\n [1, 0, 5, 8, 2],\n [1, 0, 5, 8, 3, 2],\n [1, 0, 5, 8, 3, 4, 9, 7, 6, 2],\n [1, 0, 5, 8, 3, 6, 2],\n [1, 0, 5, 8, 4, 3, 2],\n [1, 0, 5, 8, 4, 3, 6, 2],\n [1, 0, 5, 8, 4, 9, 7, 6, 2],\n [1, 0, 5, 8, 4, 9, 7, 6, 3, 2],\n [1, 0, 5, 8, 6, 2],\n [1, 0, 5, 8, 6, 3, 2],\n [1, 0, 5, 8, 6, 7, 9, 4, 3, 2],\n [1, 0, 6, 2],\n [1, 0, 6, 3, 2],\n [1, 0, 6, 3, 4, 8, 2],\n [1, 0, 6, 3, 4, 8, 5, 2],\n [1, 0, 6, 3, 4, 9, 7, 5, 2],\n [1, 0, 6, 3, 4, 9, 7, 5, 8, 2],\n [1, 0, 6, 3, 5, 2],\n [1, 0, 6, 3, 5, 7, 9, 4, 8, 2],\n [1, 0, 6, 3, 5, 8, 2],\n [1, 0, 6, 3, 8, 2],\n [1, 0, 6, 3, 8, 4, 9, 7, 5, 2],\n [1, 0, 6, 3, 8, 5, 2],\n [1, 0, 6, 5, 2],\n [1, 0, 6, 5, 3, 2],\n [1, 0, 6, 5, 3, 4, 8, 2],\n [1, 0, 6, 5, 3, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 3, 2],\n [1, 0, 6, 5, 7, 9, 4, 3, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 8, 2],\n [1, 0, 6, 5, 7, 9, 4, 8, 3, 2],\n [1, 0, 6, 5, 8, 2],\n [1, 0, 6, 5, 8, 3, 2],\n [1, 0, 6, 5, 8, 4, 3, 2],\n [1, 0, 6, 7, 5, 2],\n [1, 0, 6, 7, 5, 3, 2],\n [1, 0, 6, 7, 5, 3, 4, 8, 2],\n [1, 0, 6, 7, 5, 3, 8, 2],\n [1, 0, 6, 7, 5, 8, 2],\n [1, 0, 6, 7, 5, 8, 3, 2],\n [1, 0, 6, 7, 5, 8, 4, 3, 2],\n [1, 0, 6, 7, 9, 4, 3, 2],\n [1, 0, 6, 7, 9, 4, 3, 5, 2],\n [1, 0, 6, 7, 9, 4, 3, 5, 8, 2],\n [1, 0, 6, 7, 9, 4, 3, 8, 2],\n [1, 0, 6, 7, 9, 4, 3, 8, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 2],\n [1, 0, 6, 7, 9, 4, 8, 3, 2],\n [1, 0, 6, 7, 9, 4, 8, 3, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 5, 2],\n [1, 0, 6, 7, 9, 4, 8, 5, 3, 2],\n [1, 0, 6, 8, 2],\n [1, 0, 6, 8, 3, 2],\n [1, 0, 6, 8, 3, 4, 9, 7, 5, 2],\n [1, 0, 6, 8, 3, 5, 2],\n [1, 0, 6, 8, 4, 3, 2],\n [1, 0, 6, 8, 4, 3, 5, 2],\n [1, 0, 6, 8, 4, 9, 7, 5, 2],\n [1, 0, 6, 8, 4, 9, 7, 5, 3, 2],\n [1, 0, 6, 8, 5, 2],\n [1, 0, 6, 8, 5, 3, 2],\n [1, 0, 6, 8, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 2],\n [1, 0, 8, 3, 2],\n [1, 0, 8, 3, 4, 9, 7, 5, 2],\n [1, 0, 8, 3, 4, 9, 7, 5, 6, 2],\n [1, 0, 8, 3, 4, 9, 7, 6, 2],\n [1, 0, 8, 3, 4, 9, 7, 6, 5, 2],\n [1, 0, 8, 3, 5, 2],\n [1, 0, 8, 3, 5, 6, 2],\n [1, 0, 8, 3, 5, 7, 6, 2],\n [1, 0, 8, 3, 6, 2],\n [1, 0, 8, 3, 6, 5, 2],\n [1, 0, 8, 3, 6, 7, 5, 2],\n [1, 0, 8, 4, 3, 2],\n [1, 0, 8, 4, 3, 5, 2],\n [1, 0, 8, 4, 3, 5, 6, 2],\n [1, 0, 8, 4, 3, 5, 7, 6, 2],\n [1, 0, 8, 4, 3, 6, 2],\n [1, 0, 8, 4, 3, 6, 5, 2],\n [1, 0, 8, 4, 3, 6, 7, 5, 2],\n [1, 0, 8, 4, 9, 7, 5, 2],\n [1, 0, 8, 4, 9, 7, 5, 3, 2],\n [1, 0, 8, 4, 9, 7, 5, 3, 6, 2],\n [1, 0, 8, 4, 9, 7, 5, 6, 2],\n [1, 0, 8, 4, 9, 7, 5, 6, 3, 2],\n [1, 0, 8, 4, 9, 7, 6, 2],\n [1, 0, 8, 4, 9, 7, 6, 3, 2],\n [1, 0, 8, 4, 9, 7, 6, 3, 5, 2],\n [1, 0, 8, 4, 9, 7, 6, 5, 2],\n [1, 0, 8, 4, 9, 7, 6, 5, 3, 2],\n [1, 0, 8, 5, 2],\n [1, 0, 8, 5, 3, 2],\n [1, 0, 8, 5, 3, 4, 9, 7, 6, 2],\n [1, 0, 8, 5, 3, 6, 2],\n [1, 0, 8, 5, 6, 2],\n [1, 0, 8, 5, 6, 3, 2],\n [1, 0, 8, 5, 6, 7, 9, 4, 3, 2],\n [1, 0, 8, 5, 7, 6, 2],\n [1, 0, 8, 5, 7, 6, 3, 2],\n [1, 0, 8, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 5, 7, 9, 4, 3, 6, 2],\n [1, 0, 8, 6, 2],\n [1, 0, 8, 6, 3, 2],\n [1, 0, 8, 6, 3, 4, 9, 7, 5, 2],\n [1, 0, 8, 6, 3, 5, 2],\n [1, 0, 8, 6, 5, 2],\n [1, 0, 8, 6, 5, 3, 2],\n [1, 0, 8, 6, 5, 7, 9, 4, 3, 2],\n [1, 0, 8, 6, 7, 5, 2],\n [1, 0, 8, 6, 7, 5, 3, 2],\n [1, 0, 8, 6, 7, 9, 4, 3, 2],\n [1, 0, 8, 6, 7, 9, 4, 3, 5, 2],\n [1, 0, 9, 4, 3, 2],\n [1, 0, 9, 4, 3, 5, 2],\n [1, 0, 9, 4, 3, 5, 6, 2],\n [1, 0, 9, 4, 3, 5, 6, 8, 2],\n [1, 0, 9, 4, 3, 5, 7, 6, 2],\n [1, 0, 9, 4, 3, 5, 7, 6, 8, 2],\n [1, 0, 9, 4, 3, 5, 8, 2],\n [1, 0, 9, 4, 3, 5, 8, 6, 2],\n [1, 0, 9, 4, 3, 6, 2],\n [1, 0, 9, 4, 3, 6, 5, 2],\n [1, 0, 9, 4, 3, 6, 5, 8, 2],\n [1, 0, 9, 4, 3, 6, 7, 5, 2],\n [1, 0, 9, 4, 3, 6, 7, 5, 8, 2],\n [1, 0, 9, 4, 3, 6, 8, 2],\n [1, 0, 9, 4, 3, 6, 8, 5, 2],\n [1, 0, 9, 4, 3, 8, 2],\n [1, 0, 9, 4, 3, 8, 5, 2],\n [1, 0, 9, 4, 3, 8, 5, 6, 2],\n [1, 0, 9, 4, 3, 8, 5, 7, 6, 2],\n [1, 0, 9, 4, 3, 8, 6, 2],\n [1, 0, 9, 4, 3, 8, 6, 5, 2],\n [1, 0, 9, 4, 3, 8, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 2],\n [1, 0, 9, 4, 8, 3, 2],\n [1, 0, 9, 4, 8, 3, 5, 2],\n [1, 0, 9, 4, 8, 3, 5, 6, 2],\n [1, 0, 9, 4, 8, 3, 5, 7, 6, 2],\n [1, 0, 9, 4, 8, 3, 6, 2],\n [1, 0, 9, 4, 8, 3, 6, 5, 2],\n [1, 0, 9, 4, 8, 3, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 5, 2],\n [1, 0, 9, 4, 8, 5, 3, 2],\n [1, 0, 9, 4, 8, 5, 3, 6, 2],\n [1, 0, 9, 4, 8, 5, 6, 2],\n [1, 0, 9, 4, 8, 5, 6, 3, 2],\n [1, 0, 9, 4, 8, 5, 7, 6, 2],\n [1, 0, 9, 4, 8, 5, 7, 6, 3, 2],\n [1, 0, 9, 4, 8, 6, 2],\n [1, 0, 9, 4, 8, 6, 3, 2],\n [1, 0, 9, 4, 8, 6, 3, 5, 2],\n [1, 0, 9, 4, 8, 6, 5, 2],\n [1, 0, 9, 4, 8, 6, 5, 3, 2],\n [1, 0, 9, 4, 8, 6, 7, 5, 2],\n [1, 0, 9, 4, 8, 6, 7, 5, 3, 2],\n [1, 0, 9, 7, 5, 2],\n [1, 0, 9, 7, 5, 3, 2],\n [1, 0, 9, 7, 5, 3, 4, 8, 2],\n [1, 0, 9, 7, 5, 3, 4, 8, 6, 2],\n [1, 0, 9, 7, 5, 3, 6, 2],\n [1, 0, 9, 7, 5, 3, 6, 8, 2],\n [1, 0, 9, 7, 5, 3, 8, 2],\n [1, 0, 9, 7, 5, 3, 8, 6, 2],\n [1, 0, 9, 7, 5, 6, 2],\n [1, 0, 9, 7, 5, 6, 3, 2],\n [1, 0, 9, 7, 5, 6, 3, 4, 8, 2],\n [1, 0, 9, 7, 5, 6, 3, 8, 2],\n [1, 0, 9, 7, 5, 6, 8, 2],\n [1, 0, 9, 7, 5, 6, 8, 3, 2],\n [1, 0, 9, 7, 5, 6, 8, 4, 3, 2],\n [1, 0, 9, 7, 5, 8, 2],\n [1, 0, 9, 7, 5, 8, 3, 2],\n [1, 0, 9, 7, 5, 8, 3, 6, 2],\n [1, 0, 9, 7, 5, 8, 4, 3, 2],\n [1, 0, 9, 7, 5, 8, 4, 3, 6, 2],\n [1, 0, 9, 7, 5, 8, 6, 2],\n [1, 0, 9, 7, 5, 8, 6, 3, 2],\n [1, 0, 9, 7, 6, 2],\n [1, 0, 9, 7, 6, 3, 2],\n [1, 0, 9, 7, 6, 3, 4, 8, 2],\n [1, 0, 9, 7, 6, 3, 4, 8, 5, 2],\n [1, 0, 9, 7, 6, 3, 5, 2],\n [1, 0, 9, 7, 6, 3, 5, 8, 2],\n [1, 0, 9, 7, 6, 3, 8, 2],\n [1, 0, 9, 7, 6, 3, 8, 5, 2],\n [1, 0, 9, 7, 6, 5, 2],\n [1, 0, 9, 7, 6, 5, 3, 2],\n [1, 0, 9, 7, 6, 5, 3, 4, 8, 2],\n [1, 0, 9, 7, 6, 5, 3, 8, 2],\n [1, 0, 9, 7, 6, 5, 8, 2],\n [1, 0, 9, 7, 6, 5, 8, 3, 2],\n [1, 0, 9, 7, 6, 5, 8, 4, 3, 2],\n [1, 0, 9, 7, 6, 8, 2],\n [1, 0, 9, 7, 6, 8, 3, 2],\n [1, 0, 9, 7, 6, 8, 3, 5, 2],\n [1, 0, 9, 7, 6, 8, 4, 3, 2],\n [1, 0, 9, 7, 6, 8, 4, 3, 5, 2],\n [1, 0, 9, 7, 6, 8, 5, 2],\n [1, 0, 9, 7, 6, 8, 5, 3, 2],\n [1, 2],\n [1, 3, 0, 2],\n [1, 3, 0, 5, 2],\n [1, 3, 0, 5, 6, 2],\n [1, 3, 0, 5, 6, 7, 9, 4, 8, 2],\n [1, 3, 0, 5, 6, 8, 2],\n [1, 3, 0, 5, 7, 6, 2],\n [1, 3, 0, 5, 7, 6, 8, 2],\n [1, 3, 0, 5, 7, 9, 4, 8, 2],\n [1, 3, 0, 5, 7, 9, 4, 8, 6, 2],\n [1, 3, 0, 5, 8, 2],\n [1, 3, 0, 5, 8, 4, 9, 7, 6, 2],\n [1, 3, 0, 5, 8, 6, 2],\n [1, 3, 0, 6, 2],\n [1, 3, 0, 6, 5, 2],\n [1, 3, 0, 6, 5, 7, 9, 4, 8, 2],\n [1, 3, 0, 6, 5, 8, 2],\n [1, 3, 0, 6, 7, 5, 2],\n [1, 3, 0, 6, 7, 5, 8, 2],\n [1, 3, 0, 6, 7, 9, 4, 8, 2],\n [1, 3, 0, 6, 7, 9, 4, 8, 5, 2],\n [1, 3, 0, 6, 8, 2],\n [1, 3, 0, 6, 8, 4, 9, 7, 5, 2],\n [1, 3, 0, 6, 8, 5, 2],\n [1, 3, 0, 8, 2],\n [1, 3, 0, 8, 4, 9, 7, 5, 2],\n [1, 3, 0, 8, 4, 9, 7, 5, 6, 2],\n [1, 3, 0, 8, 4, 9, 7, 6, 2],\n [1, 3, 0, 8, 4, 9, 7, 6, 5, 2],\n [1, 3, 0, 8, 5, 2],\n [1, 3, 0, 8, 5, 6, 2],\n [1, 3, 0, 8, 5, 7, 6, 2],\n [1, 3, 0, 8, 6, 2],\n [1, 3, 0, 8, 6, 5, 2],\n [1, 3, 0, 8, 6, 7, 5, 2],\n [1, 3, 0, 9, 4, 8, 2],\n [1, 3, 0, 9, 4, 8, 5, 2],\n [1, 3, 0, 9, 4, 8, 5, 6, 2],\n [1, 3, 0, 9, 4, 8, 5, 7, 6, 2],\n [1, 3, 0, 9, 4, 8, 6, 2],\n [1, 3, 0, 9, 4, 8, 6, 5, 2],\n [1, 3, 0, 9, 4, 8, 6, 7, 5, 2],\n [1, 3, 0, 9, 7, 5, 2],\n [1, 3, 0, 9, 7, 5, 6, 2],\n [1, 3, 0, 9, 7, 5, 6, 8, 2],\n [1, 3, 0, 9, 7, 5, 8, 2],\n [1, 3, 0, 9, 7, 5, 8, 6, 2],\n [1, 3, 0, 9, 7, 6, 2],\n [1, 3, 0, 9, 7, 6, 5, 2],\n [1, 3, 0, 9, 7, 6, 5, 8, 2],\n [1, 3, 0, 9, 7, 6, 8, 2],\n [1, 3, 0, 9, 7, 6, 8, 5, 2],\n [1, 3, 2],\n [1, 3, 4, 8, 0, 2],\n [1, 3, 4, 8, 0, 5, 2],\n [1, 3, 4, 8, 0, 5, 6, 2],\n [1, 3, 4, 8, 0, 5, 7, 6, 2],\n [1, 3, 4, 8, 0, 6, 2],\n [1, 3, 4, 8, 0, 6, 5, 2],\n [1, 3, 4, 8, 0, 6, 7, 5, 2],\n [1, 3, 4, 8, 0, 9, 7, 5, 2],\n [1, 3, 4, 8, 0, 9, 7, 5, 6, 2],\n [1, 3, 4, 8, 0, 9, 7, 6, 2],\n [1, 3, 4, 8, 0, 9, 7, 6, 5, 2],\n [1, 3, 4, 8, 2],\n [1, 3, 4, 8, 5, 0, 2],\n [1, 3, 4, 8, 5, 0, 6, 2],\n [1, 3, 4, 8, 5, 0, 9, 7, 6, 2],\n [1, 3, 4, 8, 5, 2],\n [1, 3, 4, 8, 5, 6, 0, 2],\n [1, 3, 4, 8, 5, 6, 2],\n [1, 3, 4, 8, 5, 6, 7, 9, 0, 2],\n [1, 3, 4, 8, 5, 7, 6, 0, 2],\n [1, 3, 4, 8, 5, 7, 6, 2],\n [1, 3, 4, 8, 5, 7, 9, 0, 2],\n [1, 3, 4, 8, 5, 7, 9, 0, 6, 2],\n [1, 3, 4, 8, 6, 0, 2],\n [1, 3, 4, 8, 6, 0, 5, 2],\n [1, 3, 4, 8, 6, 0, 9, 7, 5, 2],\n [1, 3, 4, 8, 6, 2],\n [1, 3, 4, 8, 6, 5, 0, 2],\n [1, 3, 4, 8, 6, 5, 2],\n [1, 3, 4, 8, 6, 5, 7, 9, 0, 2],\n [1, 3, 4, 8, 6, 7, 5, 0, 2],\n [1, 3, 4, 8, 6, 7, 5, 2],\n [1, 3, 4, 8, 6, 7, 9, 0, 2],\n [1, 3, 4, 8, 6, 7, 9, 0, 5, 2],\n [1, 3, 4, 9, 0, 2],\n [1, 3, 4, 9, 0, 5, 2],\n [1, 3, 4, 9, 0, 5, 6, 2],\n [1, 3, 4, 9, 0, 5, 6, 8, 2],\n [1, 3, 4, 9, 0, 5, 7, 6, 2],\n [1, 3, 4, 9, 0, 5, 7, 6, 8, 2],\n [1, 3, 4, 9, 0, 5, 8, 2],\n [1, 3, 4, 9, 0, 5, 8, 6, 2],\n [1, 3, 4, 9, 0, 6, 2],\n [1, 3, 4, 9, 0, 6, 5, 2],\n [1, 3, 4, 9, 0, 6, 5, 8, 2],\n [1, 3, 4, 9, 0, 6, 7, 5, 2],\n [1, 3, 4, 9, 0, 6, 7, 5, 8, 2],\n [1, 3, 4, 9, 0, 6, 8, 2],\n [1, 3, 4, 9, 0, 6, 8, 5, 2],\n [1, 3, 4, 9, 0, 8, 2],\n [1, 3, 4, 9, 0, 8, 5, 2],\n [1, 3, 4, 9, 0, 8, 5, 6, 2],\n [1, 3, 4, 9, 0, 8, 5, 7, 6, 2],\n [1, 3, 4, 9, 0, 8, 6, 2],\n [1, 3, 4, 9, 0, 8, 6, 5, 2],\n [1, 3, 4, 9, 0, 8, 6, 7, 5, 2],\n [1, 3, 4, 9, 7, 5, 0, 2],\n [1, 3, 4, 9, 7, 5, 0, 6, 2],\n [1, 3, 4, 9, 7, 5, 0, 6, 8, 2],\n [1, 3, 4, 9, 7, 5, 0, 8, 2],\n [1, 3, 4, 9, 7, 5, 0, 8, 6, 2],\n [1, 3, 4, 9, 7, 5, 2],\n [1, 3, 4, 9, 7, 5, 6, 0, 2],\n [1, 3, 4, 9, 7, 5, 6, 0, 8, 2],\n [1, 3, 4, 9, 7, 5, 6, 2],\n [1, 3, 4, 9, 7, 5, 6, 8, 0, 2],\n [1, 3, 4, 9, 7, 5, 6, 8, 2],\n [1, 3, 4, 9, 7, 5, 8, 0, 2],\n [1, 3, 4, 9, 7, 5, 8, 0, 6, 2],\n [1, 3, 4, 9, 7, 5, 8, 2],\n [1, 3, 4, 9, 7, 5, 8, 6, 0, 2],\n [1, 3, 4, 9, 7, 5, 8, 6, 2],\n [1, 3, 4, 9, 7, 6, 0, 2],\n [1, 3, 4, 9, 7, 6, 0, 5, 2],\n [1, 3, 4, 9, 7, 6, 0, 5, 8, 2],\n [1, 3, 4, 9, 7, 6, 0, 8, 2],\n [1, 3, 4, 9, 7, 6, 0, 8, 5, 2],\n [1, 3, 4, 9, 7, 6, 2],\n [1, 3, 4, 9, 7, 6, 5, 0, 2],\n [1, 3, 4, 9, 7, 6, 5, 0, 8, 2],\n [1, 3, 4, 9, 7, 6, 5, 2],\n [1, 3, 4, 9, 7, 6, 5, 8, 0, 2],\n [1, 3, 4, 9, 7, 6, 5, 8, 2],\n [1, 3, 4, 9, 7, 6, 8, 0, 2],\n [1, 3, 4, 9, 7, 6, 8, 0, 5, 2],\n [1, 3, 4, 9, 7, 6, 8, 2],\n [1, 3, 4, 9, 7, 6, 8, 5, 0, 2],\n [1, 3, 4, 9, 7, 6, 8, 5, 2],\n [1, 3, 5, 0, 2],\n [1, 3, 5, 0, 6, 2],\n [1, 3, 5, 0, 6, 7, 9, 4, 8, 2],\n [1, 3, 5, 0, 6, 8, 2],\n [1, 3, 5, 0, 8, 2],\n [1, 3, 5, 0, 8, 4, 9, 7, 6, 2],\n [1, 3, 5, 0, 8, 6, 2],\n [1, 3, 5, 0, 9, 4, 8, 2],\n [1, 3, 5, 0, 9, 4, 8, 6, 2],\n [1, 3, 5, 0, 9, 7, 6, 2],\n [1, 3, 5, 0, 9, 7, 6, 8, 2],\n [1, 3, 5, 2],\n [1, 3, 5, 6, 0, 2],\n [1, 3, 5, 6, 0, 8, 2],\n [1, 3, 5, 6, 0, 9, 4, 8, 2],\n [1, 3, 5, 6, 2],\n [1, 3, 5, 6, 7, 9, 0, 2],\n [1, 3, 5, 6, 7, 9, 0, 8, 2],\n [1, 3, 5, 6, 7, 9, 4, 8, 0, 2],\n [1, 3, 5, 6, 7, 9, 4, 8, 2],\n [1, 3, 5, 6, 8, 0, 2],\n [1, 3, 5, 6, 8, 2],\n [1, 3, 5, 6, 8, 4, 9, 0, 2],\n [1, 3, 5, 7, 6, 0, 2],\n [1, 3, 5, 7, 6, 0, 8, 2],\n [1, 3, 5, 7, 6, 0, 9, 4, 8, 2],\n [1, 3, 5, 7, 6, 2],\n [1, 3, 5, 7, 6, 8, 0, 2],\n [1, 3, 5, 7, 6, 8, 2],\n [1, 3, 5, 7, 6, 8, 4, 9, 0, 2],\n [1, 3, 5, 7, 9, 0, 2],\n [1, 3, 5, 7, 9, 0, 6, 2],\n [1, 3, 5, 7, 9, 0, 6, 8, 2],\n [1, 3, 5, 7, 9, 0, 8, 2],\n [1, 3, 5, 7, 9, 0, 8, 6, 2],\n [1, 3, 5, 7, 9, 4, 8, 0, 2],\n [1, 3, 5, 7, 9, 4, 8, 0, 6, 2],\n [1, 3, 5, 7, 9, 4, 8, 2],\n [1, 3, 5, 7, 9, 4, 8, 6, 0, 2],\n [1, 3, 5, 7, 9, 4, 8, 6, 2],\n [1, 3, 5, 8, 0, 2],\n [1, 3, 5, 8, 0, 6, 2],\n [1, 3, 5, 8, 0, 9, 7, 6, 2],\n [1, 3, 5, 8, 2],\n [1, 3, 5, 8, 4, 9, 0, 2],\n [1, 3, 5, 8, 4, 9, 0, 6, 2],\n [1, 3, 5, 8, 4, 9, 7, 6, 0, 2],\n [1, 3, 5, 8, 4, 9, 7, 6, 2],\n [1, 3, 5, 8, 6, 0, 2],\n [1, 3, 5, 8, 6, 2],\n [1, 3, 5, 8, 6, 7, 9, 0, 2],\n [1, 3, 6, 0, 2],\n [1, 3, 6, 0, 5, 2],\n [1, 3, 6, 0, 5, 7, 9, 4, 8, 2],\n [1, 3, 6, 0, 5, 8, 2],\n [1, 3, 6, 0, 8, 2],\n [1, 3, 6, 0, 8, 4, 9, 7, 5, 2],\n [1, 3, 6, 0, 8, 5, 2],\n [1, 3, 6, 0, 9, 4, 8, 2],\n [1, 3, 6, 0, 9, 4, 8, 5, 2],\n [1, 3, 6, 0, 9, 7, 5, 2],\n [1, 3, 6, 0, 9, 7, 5, 8, 2],\n [1, 3, 6, 2],\n [1, 3, 6, 5, 0, 2],\n [1, 3, 6, 5, 0, 8, 2],\n [1, 3, 6, 5, 0, 9, 4, 8, 2],\n [1, 3, 6, 5, 2],\n [1, 3, 6, 5, 7, 9, 0, 2],\n [1, 3, 6, 5, 7, 9, 0, 8, 2],\n [1, 3, 6, 5, 7, 9, 4, 8, 0, 2],\n [1, 3, 6, 5, 7, 9, 4, 8, 2],\n [1, 3, 6, 5, 8, 0, 2],\n [1, 3, 6, 5, 8, 2],\n [1, 3, 6, 5, 8, 4, 9, 0, 2],\n [1, 3, 6, 7, 5, 0, 2],\n [1, 3, 6, 7, 5, 0, 8, 2],\n [1, 3, 6, 7, 5, 0, 9, 4, 8, 2],\n [1, 3, 6, 7, 5, 2],\n [1, 3, 6, 7, 5, 8, 0, 2],\n [1, 3, 6, 7, 5, 8, 2],\n [1, 3, 6, 7, 5, 8, 4, 9, 0, 2],\n [1, 3, 6, 7, 9, 0, 2],\n [1, 3, 6, 7, 9, 0, 5, 2],\n [1, 3, 6, 7, 9, 0, 5, 8, 2],\n [1, 3, 6, 7, 9, 0, 8, 2],\n [1, 3, 6, 7, 9, 0, 8, 5, 2],\n [1, 3, 6, 7, 9, 4, 8, 0, 2],\n [1, 3, 6, 7, 9, 4, 8, 0, 5, 2],\n [1, 3, 6, 7, 9, 4, 8, 2],\n [1, 3, 6, 7, 9, 4, 8, 5, 0, 2],\n [1, 3, 6, 7, 9, 4, 8, 5, 2],\n [1, 3, 6, 8, 0, 2],\n [1, 3, 6, 8, 0, 5, 2],\n [1, 3, 6, 8, 0, 9, 7, 5, 2],\n [1, 3, 6, 8, 2],\n [1, 3, 6, 8, 4, 9, 0, 2],\n [1, 3, 6, 8, 4, 9, 0, 5, 2],\n [1, 3, 6, 8, 4, 9, 7, 5, 0, 2],\n [1, 3, 6, 8, 4, 9, 7, 5, 2],\n [1, 3, 6, 8, 5, 0, 2],\n [1, 3, 6, 8, 5, 2],\n [1, 3, 6, 8, 5, 7, 9, 0, 2],\n [1, 3, 8, 0, 2],\n [1, 3, 8, 0, 5, 2],\n [1, 3, 8, 0, 5, 6, 2],\n [1, 3, 8, 0, 5, 7, 6, 2],\n [1, 3, 8, 0, 6, 2],\n [1, 3, 8, 0, 6, 5, 2],\n [1, 3, 8, 0, 6, 7, 5, 2],\n [1, 3, 8, 0, 9, 7, 5, 2],\n [1, 3, 8, 0, 9, 7, 5, 6, 2],\n [1, 3, 8, 0, 9, 7, 6, 2],\n [1, 3, 8, 0, 9, 7, 6, 5, 2],\n [1, 3, 8, 2],\n [1, 3, 8, 4, 9, 0, 2],\n [1, 3, 8, 4, 9, 0, 5, 2],\n [1, 3, 8, 4, 9, 0, 5, 6, 2],\n [1, 3, 8, 4, 9, 0, 5, 7, 6, 2],\n [1, 3, 8, 4, 9, 0, 6, 2],\n [1, 3, 8, 4, 9, 0, 6, 5, 2],\n [1, 3, 8, 4, 9, 0, 6, 7, 5, 2],\n [1, 3, 8, 4, 9, 7, 5, 0, 2],\n [1, 3, 8, 4, 9, 7, 5, 0, 6, 2],\n [1, 3, 8, 4, 9, 7, 5, 2],\n [1, 3, 8, 4, 9, 7, 5, 6, 0, 2],\n [1, 3, 8, 4, 9, 7, 5, 6, 2],\n [1, 3, 8, 4, 9, 7, 6, 0, 2],\n [1, 3, 8, 4, 9, 7, 6, 0, 5, 2],\n [1, 3, 8, 4, 9, 7, 6, 2],\n [1, 3, 8, 4, 9, 7, 6, 5, 0, 2],\n [1, 3, 8, 4, 9, 7, 6, 5, 2],\n [1, 3, 8, 5, 0, 2],\n [1, 3, 8, 5, 0, 6, 2],\n [1, 3, 8, 5, 0, 9, 7, 6, 2],\n [1, 3, 8, 5, 2],\n [1, 3, 8, 5, 6, 0, 2],\n [1, 3, 8, 5, 6, 2],\n [1, 3, 8, 5, 6, 7, 9, 0, 2],\n [1, 3, 8, 5, 7, 6, 0, 2],\n [1, 3, 8, 5, 7, 6, 2],\n [1, 3, 8, 5, 7, 9, 0, 2],\n [1, 3, 8, 5, 7, 9, 0, 6, 2],\n [1, 3, 8, 6, 0, 2],\n [1, 3, 8, 6, 0, 5, 2],\n [1, 3, 8, 6, 0, 9, 7, 5, 2],\n [1, 3, 8, 6, 2],\n [1, 3, 8, 6, 5, 0, 2],\n [1, 3, 8, 6, 5, 2],\n [1, 3, 8, 6, 5, 7, 9, 0, 2],\n [1, 3, 8, 6, 7, 5, 0, 2],\n [1, 3, 8, 6, 7, 5, 2],\n [1, 3, 8, 6, 7, 9, 0, 2],\n [1, 3, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 3, 0, 2],\n [1, 4, 3, 0, 5, 2],\n [1, 4, 3, 0, 5, 6, 2],\n [1, 4, 3, 0, 5, 6, 8, 2],\n [1, 4, 3, 0, 5, 7, 6, 2],\n [1, 4, 3, 0, 5, 7, 6, 8, 2],\n [1, 4, 3, 0, 5, 8, 2],\n [1, 4, 3, 0, 5, 8, 6, 2],\n [1, 4, 3, 0, 6, 2],\n [1, 4, 3, 0, 6, 5, 2],\n [1, 4, 3, 0, 6, 5, 8, 2],\n [1, 4, 3, 0, 6, 7, 5, 2],\n [1, 4, 3, 0, 6, 7, 5, 8, 2],\n [1, 4, 3, 0, 6, 8, 2],\n [1, 4, 3, 0, 6, 8, 5, 2],\n [1, 4, 3, 0, 8, 2],\n [1, 4, 3, 0, 8, 5, 2],\n [1, 4, 3, 0, 8, 5, 6, 2],\n [1, 4, 3, 0, 8, 5, 7, 6, 2],\n [1, 4, 3, 0, 8, 6, 2],\n [1, 4, 3, 0, 8, 6, 5, 2],\n [1, 4, 3, 0, 8, 6, 7, 5, 2],\n [1, 4, 3, 0, 9, 7, 5, 2],\n [1, 4, 3, 0, 9, 7, 5, 6, 2],\n [1, 4, 3, 0, 9, 7, 5, 6, 8, 2],\n [1, 4, 3, 0, 9, 7, 5, 8, 2],\n [1, 4, 3, 0, 9, 7, 5, 8, 6, 2],\n [1, 4, 3, 0, 9, 7, 6, 2],\n [1, 4, 3, 0, 9, 7, 6, 5, 2],\n [1, 4, 3, 0, 9, 7, 6, 5, 8, 2],\n [1, 4, 3, 0, 9, 7, 6, 8, 2],\n [1, 4, 3, 0, 9, 7, 6, 8, 5, 2],\n [1, 4, 3, 2],\n [1, 4, 3, 5, 0, 2],\n [1, 4, 3, 5, 0, 6, 2],\n [1, 4, 3, 5, 0, 6, 8, 2],\n [1, 4, 3, 5, 0, 8, 2],\n [1, 4, 3, 5, 0, 8, 6, 2],\n [1, 4, 3, 5, 0, 9, 7, 6, 2],\n [1, 4, 3, 5, 0, 9, 7, 6, 8, 2],\n [1, 4, 3, 5, 2],\n [1, 4, 3, 5, 6, 0, 2],\n [1, 4, 3, 5, 6, 0, 8, 2],\n [1, 4, 3, 5, 6, 2],\n [1, 4, 3, 5, 6, 7, 9, 0, 2],\n [1, 4, 3, 5, 6, 7, 9, 0, 8, 2],\n [1, 4, 3, 5, 6, 8, 0, 2],\n [1, 4, 3, 5, 6, 8, 2],\n [1, 4, 3, 5, 7, 6, 0, 2],\n [1, 4, 3, 5, 7, 6, 0, 8, 2],\n [1, 4, 3, 5, 7, 6, 2],\n [1, 4, 3, 5, 7, 6, 8, 0, 2],\n [1, 4, 3, 5, 7, 6, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 2],\n [1, 4, 3, 5, 7, 9, 0, 6, 2],\n [1, 4, 3, 5, 7, 9, 0, 6, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 8, 2],\n [1, 4, 3, 5, 7, 9, 0, 8, 6, 2],\n [1, 4, 3, 5, 8, 0, 2],\n [1, 4, 3, 5, 8, 0, 6, 2],\n [1, 4, 3, 5, 8, 0, 9, 7, 6, 2],\n [1, 4, 3, 5, 8, 2],\n [1, 4, 3, 5, 8, 6, 0, 2],\n [1, 4, 3, 5, 8, 6, 2],\n [1, 4, 3, 5, 8, 6, 7, 9, 0, 2],\n [1, 4, 3, 6, 0, 2],\n [1, 4, 3, 6, 0, 5, 2],\n [1, 4, 3, 6, 0, 5, 8, 2],\n [1, 4, 3, 6, 0, 8, 2],\n [1, 4, 3, 6, 0, 8, 5, 2],\n [1, 4, 3, 6, 0, 9, 7, 5, 2],\n [1, 4, 3, 6, 0, 9, 7, 5, 8, 2],\n [1, 4, 3, 6, 2],\n [1, 4, 3, 6, 5, 0, 2],\n [1, 4, 3, 6, 5, 0, 8, 2],\n [1, 4, 3, 6, 5, 2],\n [1, 4, 3, 6, 5, 7, 9, 0, 2],\n [1, 4, 3, 6, 5, 7, 9, 0, 8, 2],\n [1, 4, 3, 6, 5, 8, 0, 2],\n [1, 4, 3, 6, 5, 8, 2],\n [1, 4, 3, 6, 7, 5, 0, 2],\n [1, 4, 3, 6, 7, 5, 0, 8, 2],\n [1, 4, 3, 6, 7, 5, 2],\n [1, 4, 3, 6, 7, 5, 8, 0, 2],\n [1, 4, 3, 6, 7, 5, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 2],\n [1, 4, 3, 6, 7, 9, 0, 5, 2],\n [1, 4, 3, 6, 7, 9, 0, 5, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 8, 2],\n [1, 4, 3, 6, 7, 9, 0, 8, 5, 2],\n [1, 4, 3, 6, 8, 0, 2],\n [1, 4, 3, 6, 8, 0, 5, 2],\n [1, 4, 3, 6, 8, 0, 9, 7, 5, 2],\n [1, 4, 3, 6, 8, 2],\n [1, 4, 3, 6, 8, 5, 0, 2],\n [1, 4, 3, 6, 8, 5, 2],\n [1, 4, 3, 6, 8, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 0, 2],\n [1, 4, 3, 8, 0, 5, 2],\n [1, 4, 3, 8, 0, 5, 6, 2],\n [1, 4, 3, 8, 0, 5, 7, 6, 2],\n [1, 4, 3, 8, 0, 6, 2],\n [1, 4, 3, 8, 0, 6, 5, 2],\n [1, 4, 3, 8, 0, 6, 7, 5, 2],\n [1, 4, 3, 8, 0, 9, 7, 5, 2],\n [1, 4, 3, 8, 0, 9, 7, 5, 6, 2],\n [1, 4, 3, 8, 0, 9, 7, 6, 2],\n [1, 4, 3, 8, 0, 9, 7, 6, 5, 2],\n [1, 4, 3, 8, 2],\n [1, 4, 3, 8, 5, 0, 2],\n [1, 4, 3, 8, 5, 0, 6, 2],\n [1, 4, 3, 8, 5, 0, 9, 7, 6, 2],\n [1, 4, 3, 8, 5, 2],\n [1, 4, 3, 8, 5, 6, 0, 2],\n [1, 4, 3, 8, 5, 6, 2],\n [1, 4, 3, 8, 5, 6, 7, 9, 0, 2],\n [1, 4, 3, 8, 5, 7, 6, 0, 2],\n [1, 4, 3, 8, 5, 7, 6, 2],\n [1, 4, 3, 8, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 5, 7, 9, 0, 6, 2],\n [1, 4, 3, 8, 6, 0, 2],\n [1, 4, 3, 8, 6, 0, 5, 2],\n [1, 4, 3, 8, 6, 0, 9, 7, 5, 2],\n [1, 4, 3, 8, 6, 2],\n [1, 4, 3, 8, 6, 5, 0, 2],\n [1, 4, 3, 8, 6, 5, 2],\n [1, 4, 3, 8, 6, 5, 7, 9, 0, 2],\n [1, 4, 3, 8, 6, 7, 5, 0, 2],\n [1, 4, 3, 8, 6, 7, 5, 2],\n [1, 4, 3, 8, 6, 7, 9, 0, 2],\n [1, 4, 3, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 0, 2],\n [1, 4, 8, 0, 3, 2],\n [1, 4, 8, 0, 3, 5, 2],\n [1, 4, 8, 0, 3, 5, 6, 2],\n [1, 4, 8, 0, 3, 5, 7, 6, 2],\n [1, 4, 8, 0, 3, 6, 2],\n [1, 4, 8, 0, 3, 6, 5, 2],\n [1, 4, 8, 0, 3, 6, 7, 5, 2],\n [1, 4, 8, 0, 5, 2],\n [1, 4, 8, 0, 5, 3, 2],\n [1, 4, 8, 0, 5, 3, 6, 2],\n [1, 4, 8, 0, 5, 6, 2],\n [1, 4, 8, 0, 5, 6, 3, 2],\n [1, 4, 8, 0, 5, 7, 6, 2],\n [1, 4, 8, 0, 5, 7, 6, 3, 2],\n [1, 4, 8, 0, 6, 2],\n [1, 4, 8, 0, 6, 3, 2],\n [1, 4, 8, 0, 6, 3, 5, 2],\n [1, 4, 8, 0, 6, 5, 2],\n [1, 4, 8, 0, 6, 5, 3, 2],\n [1, 4, 8, 0, 6, 7, 5, 2],\n [1, 4, 8, 0, 6, 7, 5, 3, 2],\n [1, 4, 8, 0, 9, 7, 5, 2],\n [1, 4, 8, 0, 9, 7, 5, 3, 2],\n [1, 4, 8, 0, 9, 7, 5, 3, 6, 2],\n [1, 4, 8, 0, 9, 7, 5, 6, 2],\n [1, 4, 8, 0, 9, 7, 5, 6, 3, 2],\n [1, 4, 8, 0, 9, 7, 6, 2],\n [1, 4, 8, 0, 9, 7, 6, 3, 2],\n [1, 4, 8, 0, 9, 7, 6, 3, 5, 2],\n [1, 4, 8, 0, 9, 7, 6, 5, 2],\n [1, 4, 8, 0, 9, 7, 6, 5, 3, 2],\n [1, 4, 8, 2],\n [1, 4, 8, 3, 0, 2],\n [1, 4, 8, 3, 0, 5, 2],\n [1, 4, 8, 3, 0, 5, 6, 2],\n [1, 4, 8, 3, 0, 5, 7, 6, 2],\n [1, 4, 8, 3, 0, 6, 2],\n [1, 4, 8, 3, 0, 6, 5, 2],\n [1, 4, 8, 3, 0, 6, 7, 5, 2],\n [1, 4, 8, 3, 0, 9, 7, 5, 2],\n [1, 4, 8, 3, 0, 9, 7, 5, 6, 2],\n [1, 4, 8, 3, 0, 9, 7, 6, 2],\n [1, 4, 8, 3, 0, 9, 7, 6, 5, 2],\n [1, 4, 8, 3, 2],\n [1, 4, 8, 3, 5, 0, 2],\n [1, 4, 8, 3, 5, 0, 6, 2],\n [1, 4, 8, 3, 5, 0, 9, 7, 6, 2],\n [1, 4, 8, 3, 5, 2],\n [1, 4, 8, 3, 5, 6, 0, 2],\n [1, 4, 8, 3, 5, 6, 2],\n [1, 4, 8, 3, 5, 6, 7, 9, 0, 2],\n [1, 4, 8, 3, 5, 7, 6, 0, 2],\n [1, 4, 8, 3, 5, 7, 6, 2],\n [1, 4, 8, 3, 5, 7, 9, 0, 2],\n [1, 4, 8, 3, 5, 7, 9, 0, 6, 2],\n [1, 4, 8, 3, 6, 0, 2],\n [1, 4, 8, 3, 6, 0, 5, 2],\n [1, 4, 8, 3, 6, 0, 9, 7, 5, 2],\n [1, 4, 8, 3, 6, 2],\n [1, 4, 8, 3, 6, 5, 0, 2],\n [1, 4, 8, 3, 6, 5, 2],\n [1, 4, 8, 3, 6, 5, 7, 9, 0, 2],\n [1, 4, 8, 3, 6, 7, 5, 0, 2],\n [1, 4, 8, 3, 6, 7, 5, 2],\n [1, 4, 8, 3, 6, 7, 9, 0, 2],\n [1, 4, 8, 3, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 5, 0, 2],\n [1, 4, 8, 5, 0, 3, 2],\n [1, 4, 8, 5, 0, 3, 6, 2],\n [1, 4, 8, 5, 0, 6, 2],\n [1, 4, 8, 5, 0, 6, 3, 2],\n [1, 4, 8, 5, 0, 9, 7, 6, 2],\n [1, 4, 8, 5, 0, 9, 7, 6, 3, 2],\n [1, 4, 8, 5, 2],\n [1, 4, 8, 5, 3, 0, 2],\n [1, 4, 8, 5, 3, 0, 6, 2],\n [1, 4, 8, 5, 3, 0, 9, 7, 6, 2],\n [1, 4, 8, 5, 3, 2],\n [1, 4, 8, 5, 3, 6, 0, 2],\n [1, 4, 8, 5, 3, 6, 2],\n [1, 4, 8, 5, 3, 6, 7, 9, 0, 2],\n [1, 4, 8, 5, 6, 0, 2],\n [1, 4, 8, 5, 6, 0, 3, 2],\n [1, 4, 8, 5, 6, 2],\n [1, 4, 8, 5, 6, 3, 0, 2],\n [1, 4, 8, 5, 6, 3, 2],\n [1, 4, 8, 5, 6, 7, 9, 0, 2],\n [1, 4, 8, 5, 6, 7, 9, 0, 3, 2],\n [1, 4, 8, 5, 7, 6, 0, 2],\n [1, 4, 8, 5, 7, 6, 0, 3, 2],\n [1, 4, 8, 5, 7, 6, 2],\n [1, 4, 8, 5, 7, 6, 3, 0, 2],\n [1, 4, 8, 5, 7, 6, 3, 2],\n [1, 4, 8, 5, 7, 9, 0, 2],\n [1, 4, 8, 5, 7, 9, 0, 3, 2],\n [1, 4, 8, 5, 7, 9, 0, 3, 6, 2],\n [1, 4, 8, 5, 7, 9, 0, 6, 2],\n [1, 4, 8, 5, 7, 9, 0, 6, 3, 2],\n [1, 4, 8, 6, 0, 2],\n [1, 4, 8, 6, 0, 3, 2],\n [1, 4, 8, 6, 0, 3, 5, 2],\n [1, 4, 8, 6, 0, 5, 2],\n [1, 4, 8, 6, 0, 5, 3, 2],\n [1, 4, 8, 6, 0, 9, 7, 5, 2],\n [1, 4, 8, 6, 0, 9, 7, 5, 3, 2],\n [1, 4, 8, 6, 2],\n [1, 4, 8, 6, 3, 0, 2],\n [1, 4, 8, 6, 3, 0, 5, 2],\n [1, 4, 8, 6, 3, 0, 9, 7, 5, 2],\n [1, 4, 8, 6, 3, 2],\n [1, 4, 8, 6, 3, 5, 0, 2],\n [1, 4, 8, 6, 3, 5, 2],\n [1, 4, 8, 6, 3, 5, 7, 9, 0, 2],\n [1, 4, 8, 6, 5, 0, 2],\n [1, 4, 8, 6, 5, 0, 3, 2],\n [1, 4, 8, 6, 5, 2],\n [1, 4, 8, 6, 5, 3, 0, 2],\n [1, 4, 8, 6, 5, 3, 2],\n [1, 4, 8, 6, 5, 7, 9, 0, 2],\n [1, 4, 8, 6, 5, 7, 9, 0, 3, 2],\n [1, 4, 8, 6, 7, 5, 0, 2],\n [1, 4, 8, 6, 7, 5, 0, 3, 2],\n [1, 4, 8, 6, 7, 5, 2],\n [1, 4, 8, 6, 7, 5, 3, 0, 2],\n [1, 4, 8, 6, 7, 5, 3, 2],\n [1, 4, 8, 6, 7, 9, 0, 2],\n [1, 4, 8, 6, 7, 9, 0, 3, 2],\n [1, 4, 8, 6, 7, 9, 0, 3, 5, 2],\n [1, 4, 8, 6, 7, 9, 0, 5, 2],\n [1, 4, 8, 6, 7, 9, 0, 5, 3, 2],\n [1, 4, 9, 0, 2],\n [1, 4, 9, 0, 3, 2],\n [1, 4, 9, 0, 3, 5, 2],\n [1, 4, 9, 0, 3, 5, 6, 2],\n [1, 4, 9, 0, 3, 5, 6, 8, 2],\n [1, 4, 9, 0, 3, 5, 7, 6, 2],\n [1, 4, 9, 0, 3, 5, 7, 6, 8, 2],\n [1, 4, 9, 0, 3, 5, 8, 2],\n [1, 4, 9, 0, 3, 5, 8, 6, 2],\n [1, 4, 9, 0, 3, 6, 2],\n [1, 4, 9, 0, 3, 6, 5, 2],\n [1, 4, 9, 0, 3, 6, 5, 8, 2],\n [1, 4, 9, 0, 3, 6, 7, 5, 2],\n [1, 4, 9, 0, 3, 6, 7, 5, 8, 2],\n [1, 4, 9, 0, 3, 6, 8, 2],\n [1, 4, 9, 0, 3, 6, 8, 5, 2],\n [1, 4, 9, 0, 3, 8, 2],\n [1, 4, 9, 0, 3, 8, 5, 2],\n [1, 4, 9, 0, 3, 8, 5, 6, 2],\n [1, 4, 9, 0, 3, 8, 5, 7, 6, 2],\n [1, 4, 9, 0, 3, 8, 6, 2],\n [1, 4, 9, 0, 3, 8, 6, 5, 2],\n [1, 4, 9, 0, 3, 8, 6, 7, 5, 2],\n [1, 4, 9, 0, 5, 2],\n [1, 4, 9, 0, 5, 3, 2],\n [1, 4, 9, 0, 5, 3, 6, 2],\n [1, 4, 9, 0, 5, 3, 6, 8, 2],\n [1, 4, 9, 0, 5, 3, 8, 2],\n [1, 4, 9, 0, 5, 3, 8, 6, 2],\n [1, 4, 9, 0, 5, 6, 2],\n [1, 4, 9, 0, 5, 6, 3, 2],\n [1, 4, 9, 0, 5, 6, 3, 8, 2],\n [1, 4, 9, 0, 5, 6, 8, 2],\n [1, 4, 9, 0, 5, 6, 8, 3, 2],\n [1, 4, 9, 0, 5, 7, 6, 2],\n [1, 4, 9, 0, 5, 7, 6, 3, 2],\n [1, 4, 9, 0, 5, 7, 6, 3, 8, 2],\n [1, 4, 9, 0, 5, 7, 6, 8, 2],\n [1, 4, 9, 0, 5, 7, 6, 8, 3, 2],\n [1, 4, 9, 0, 5, 8, 2],\n [1, 4, 9, 0, 5, 8, 3, 2],\n [1, 4, 9, 0, 5, 8, 3, 6, 2],\n [1, 4, 9, 0, 5, 8, 6, 2],\n [1, 4, 9, 0, 5, 8, 6, 3, 2],\n [1, 4, 9, 0, 6, 2],\n [1, 4, 9, 0, 6, 3, 2],\n [1, 4, 9, 0, 6, 3, 5, 2],\n [1, 4, 9, 0, 6, 3, 5, 8, 2],\n [1, 4, 9, 0, 6, 3, 8, 2],\n [1, 4, 9, 0, 6, 3, 8, 5, 2],\n [1, 4, 9, 0, 6, 5, 2],\n [1, 4, 9, 0, 6, 5, 3, 2],\n [1, 4, 9, 0, 6, 5, 3, 8, 2],\n [1, 4, 9, 0, 6, 5, 8, 2],\n [1, 4, 9, 0, 6, 5, 8, 3, 2],\n [1, 4, 9, 0, 6, 7, 5, 2],\n [1, 4, 9, 0, 6, 7, 5, 3, 2],\n [1, 4, 9, 0, 6, 7, 5, 3, 8, 2],\n [1, 4, 9, 0, 6, 7, 5, 8, 2],\n [1, 4, 9, 0, 6, 7, 5, 8, 3, 2],\n [1, 4, 9, 0, 6, 8, 2],\n [1, 4, 9, 0, 6, 8, 3, 2],\n [1, 4, 9, 0, 6, 8, 3, 5, 2],\n [1, 4, 9, 0, 6, 8, 5, 2],\n [1, 4, 9, 0, 6, 8, 5, 3, 2],\n [1, 4, 9, 0, 8, 2],\n [1, 4, 9, 0, 8, 3, 2],\n [1, 4, 9, 0, 8, 3, 5, 2],\n [1, 4, 9, 0, 8, 3, 5, 6, 2],\n [1, 4, 9, 0, 8, 3, 5, 7, 6, 2],\n [1, 4, 9, 0, 8, 3, 6, 2],\n [1, 4, 9, 0, 8, 3, 6, 5, 2],\n [1, 4, 9, 0, 8, 3, 6, 7, 5, 2],\n [1, 4, 9, 0, 8, 5, 2],\n [1, 4, 9, 0, 8, 5, 3, 2],\n [1, 4, 9, 0, 8, 5, 3, 6, 2],\n [1, 4, 9, 0, 8, 5, 6, 2],\n [1, 4, 9, 0, 8, 5, 6, 3, 2],\n [1, 4, 9, 0, 8, 5, 7, 6, 2],\n [1, 4, 9, 0, 8, 5, 7, 6, 3, 2],\n [1, 4, 9, 0, 8, 6, 2],\n [1, 4, 9, 0, 8, 6, 3, 2],\n [1, 4, 9, 0, 8, 6, 3, 5, 2],\n [1, 4, 9, 0, 8, 6, 5, 2],\n [1, 4, 9, 0, 8, 6, 5, 3, 2],\n [1, 4, 9, 0, 8, 6, 7, 5, 2],\n [1, 4, 9, 0, 8, 6, 7, 5, 3, 2],\n [1, 4, 9, 7, 5, 0, 2],\n [1, 4, 9, 7, 5, 0, 3, 2],\n [1, 4, 9, 7, 5, 0, 3, 6, 2],\n [1, 4, 9, 7, 5, 0, 3, 6, 8, 2],\n [1, 4, 9, 7, 5, 0, 3, 8, 2],\n [1, 4, 9, 7, 5, 0, 3, 8, 6, 2],\n [1, 4, 9, 7, 5, 0, 6, 2],\n [1, 4, 9, 7, 5, 0, 6, 3, 2],\n [1, 4, 9, 7, 5, 0, 6, 3, 8, 2],\n [1, 4, 9, 7, 5, 0, 6, 8, 2],\n [1, 4, 9, 7, 5, 0, 6, 8, 3, 2],\n [1, 4, 9, 7, 5, 0, 8, 2],\n [1, 4, 9, 7, 5, 0, 8, 3, 2],\n [1, 4, 9, 7, 5, 0, 8, 3, 6, 2],\n [1, 4, 9, 7, 5, 0, 8, 6, 2],\n [1, 4, 9, 7, 5, 0, 8, 6, 3, 2],\n [1, 4, 9, 7, 5, 2],\n [1, 4, 9, 7, 5, 3, 0, 2],\n [1, 4, 9, 7, 5, 3, 0, 6, 2],\n [1, 4, 9, 7, 5, 3, 0, 6, 8, 2],\n [1, 4, 9, 7, 5, 3, 0, 8, 2],\n [1, 4, 9, 7, 5, 3, 0, 8, 6, 2],\n [1, 4, 9, 7, 5, 3, 2],\n [1, 4, 9, 7, 5, 3, 6, 0, 2],\n [1, 4, 9, 7, 5, 3, 6, 0, 8, 2],\n [1, 4, 9, 7, 5, 3, 6, 2],\n [1, 4, 9, 7, 5, 3, 6, 8, 0, 2],\n [1, 4, 9, 7, 5, 3, 6, 8, 2],\n [1, 4, 9, 7, 5, 3, 8, 0, 2],\n [1, 4, 9, 7, 5, 3, 8, 0, 6, 2],\n [1, 4, 9, 7, 5, 3, 8, 2],\n [1, 4, 9, 7, 5, 3, 8, 6, 0, 2],\n [1, 4, 9, 7, 5, 3, 8, 6, 2],\n [1, 4, 9, 7, 5, 6, 0, 2],\n [1, 4, 9, 7, 5, 6, 0, 3, 2],\n [1, 4, 9, 7, 5, 6, 0, 3, 8, 2],\n [1, 4, 9, 7, 5, 6, 0, 8, 2],\n [1, 4, 9, 7, 5, 6, 0, 8, 3, 2],\n [1, 4, 9, 7, 5, 6, 2],\n [1, 4, 9, 7, 5, 6, 3, 0, 2],\n [1, 4, 9, 7, 5, 6, 3, 0, 8, 2],\n [1, 4, 9, 7, 5, 6, 3, 2],\n [1, 4, 9, 7, 5, 6, 3, 8, 0, 2],\n [1, 4, 9, 7, 5, 6, 3, 8, 2],\n [1, 4, 9, 7, 5, 6, 8, 0, 2],\n [1, 4, 9, 7, 5, 6, 8, 0, 3, 2],\n [1, 4, 9, 7, 5, 6, 8, 2],\n [1, 4, 9, 7, 5, 6, 8, 3, 0, 2],\n [1, 4, 9, 7, 5, 6, 8, 3, 2],\n [1, 4, 9, 7, 5, 8, 0, 2],\n [1, 4, 9, 7, 5, 8, 0, 3, 2],\n [1, 4, 9, 7, 5, 8, 0, 3, 6, 2],\n [1, 4, 9, 7, 5, 8, 0, 6, 2],\n [1, 4, 9, 7, 5, 8, 0, 6, 3, 2],\n [1, 4, 9, 7, 5, 8, 2],\n [1, 4, 9, 7, 5, 8, 3, 0, 2],\n [1, 4, 9, 7, 5, 8, 3, 0, 6, 2],\n [1, 4, 9, 7, 5, 8, 3, 2],\n [1, 4, 9, 7, 5, 8, 3, 6, 0, 2],\n [1, 4, 9, 7, 5, 8, 3, 6, 2],\n [1, 4, 9, 7, 5, 8, 6, 0, 2],\n [1, 4, 9, 7, 5, 8, 6, 0, 3, 2],\n [1, 4, 9, 7, 5, 8, 6, 2],\n [1, 4, 9, 7, 5, 8, 6, 3, 0, 2],\n ...]\n\n\n\n# Node Connectivity: from i to j\n# If we wanted to block the message from i to j by removing nodes from the network, how many\n# nodes would we need to remove?\nnx.node_connectivity(graph_er, 1, 2)\n\n6\n\n\n\n# Which nodes?(the set of nodes we must remove in order to block msg from i to j)\n# {} when two nodes are connected!\nnx.minimum_node_cut(graph_er, 1, 2)\n\n{}\n\n\n\n\nIf we wanted to block the message from i to j by removing edges from the network, how many edges would we need to remove?\n\nnx.edge_connectivity(graph_er, 1, 2)\n\n6\n\n\n\n# Which edges?\nnx.minimum_edge_cut(graph_er, 1, 2)\n\n{(0, 2), (1, 2), (3, 2), (5, 2), (6, 2), (8, 2)}"
  },
  {
    "objectID": "references/networkx_kaggle/5-networkx-degree-distributions.html",
    "href": "references/networkx_kaggle/5-networkx-degree-distributions.html",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\n\nThe degree distribution of a graph is the probability distribution of the degrees over the entire network.\n\ngraph_karate = nx.karate_club_graph()\n\n# degrees\ndegrees = dict(graph_karate.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_karate))\n    for i in degree_values\n]\n\n# histogram\nplt.bar(degree_values, histogram)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe in-degree of a node in a directed graph is the number of in-links it has.\n\n# describe a directed graph gllobally\n# directed graph\ngraph_directed = nx.DiGraph()\n\ngraph_directed.add_edge(\"A\", \"B\")\ngraph_directed.add_edge(\"A\", \"D\")\ngraph_directed.add_edge(\"A\", \"C\")\ngraph_directed.add_edge(\"B\", \"D\")\n\n# draw the nodes with labels\nnx.draw(graph_directed, with_labels=True)\n\n\n\n\n\n\n\n\n\nin_degrees = dict(graph_directed.in_degree())\nin_degree_values = sorted(set(in_degrees.values()))\nhistogram = [\n    list(in_degrees.values()).count(i) / float(nx.number_of_nodes(graph_directed))\n    for i in in_degree_values\n]\nplt.bar(in_degree_values, histogram)\nplt.xlabel(\"In Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nThe power law degree distribution is characterized by a heavy tail, with a few nodes having a very high degree and the majority having only a few. The degree distribution can be described by a power law function of the form:\n\\[P(k) \\propto k^{-\\gamma}\\]\nwhere \\(k\\) is the degree of a node, \\(P(k)\\) is the probability of a node having degree \\(k\\), and \\(\\gamma\\) is the exponent of the power law. The exponent \\(\\gamma\\) is typically in the range of 2 to 3 for most real-world networks.\nThe power law degree distribution has important implications for the structure and function of networks. For example, networks with a power law degree distribution are often more robust and resilient to random failures, but more vulnerable to targeted attacks on high-degree nodes.\nNetworks with power law distribution have many nodes with small degree and a few nodes with very large degree.\nfew riches, lots of poors!\n\ndegrees = dict(graph_karate.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_karate))\n    for i in degree_values\n]\n\n# plotting\nplt.plot(degree_values, histogram, \"o\")\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nYou can use barabasi_albert_graph(n,m) to construct a n-node preferential attachment network, where each new node attaches to m existing nodes.\n\nn = 500  # n-node\nm = 2  # each new node attaches to m existing nodes.\ngraph_barabasi = nx.barabasi_albert_graph(n, m)\n\n# degrees\ndegrees = dict(graph_barabasi.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_barabasi))\n    for i in degree_values\n]\n\n# plotting\nplt.plot(degree_values, histogram, \"o\")\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\n\n\nnx.draw(graph_barabasi, node_size=1)\n\n\n\n\n\n\n\n\nSocial networks tend to have high clustering coefficient and small average path length.\n\nprint(\n    nx.average_clustering(graph_barabasi)\n)  # rather low clustring(limitation of the model)\nprint(nx.average_shortest_path_length(graph_barabasi))  # but a short Diameter\n\n0.03963494920250683\n3.7406492985971944\n\n\n\n\n\n\ngraph_watts = nx.watts_strogatz_graph(1000, 6, 0.04)\ndegrees = dict(graph_watts.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_watts))\n    for i in degree_values\n]\nplt.bar(degree_values, histogram)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()"
  },
  {
    "objectID": "references/networkx_kaggle/5-networkx-degree-distributions.html#installing-networkx",
    "href": "references/networkx_kaggle/5-networkx-degree-distributions.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx"
  },
  {
    "objectID": "references/networkx_kaggle/5-networkx-degree-distributions.html#degree-distributions",
    "href": "references/networkx_kaggle/5-networkx-degree-distributions.html#degree-distributions",
    "title": "NetworkX",
    "section": "",
    "text": "The degree distribution of a graph is the probability distribution of the degrees over the entire network.\n\ngraph_karate = nx.karate_club_graph()\n\n# degrees\ndegrees = dict(graph_karate.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_karate))\n    for i in degree_values\n]\n\n# histogram\nplt.bar(degree_values, histogram)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe in-degree of a node in a directed graph is the number of in-links it has.\n\n# describe a directed graph gllobally\n# directed graph\ngraph_directed = nx.DiGraph()\n\ngraph_directed.add_edge(\"A\", \"B\")\ngraph_directed.add_edge(\"A\", \"D\")\ngraph_directed.add_edge(\"A\", \"C\")\ngraph_directed.add_edge(\"B\", \"D\")\n\n# draw the nodes with labels\nnx.draw(graph_directed, with_labels=True)\n\n\n\n\n\n\n\n\n\nin_degrees = dict(graph_directed.in_degree())\nin_degree_values = sorted(set(in_degrees.values()))\nhistogram = [\n    list(in_degrees.values()).count(i) / float(nx.number_of_nodes(graph_directed))\n    for i in in_degree_values\n]\nplt.bar(in_degree_values, histogram)\nplt.xlabel(\"In Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nThe power law degree distribution is characterized by a heavy tail, with a few nodes having a very high degree and the majority having only a few. The degree distribution can be described by a power law function of the form:\n\\[P(k) \\propto k^{-\\gamma}\\]\nwhere \\(k\\) is the degree of a node, \\(P(k)\\) is the probability of a node having degree \\(k\\), and \\(\\gamma\\) is the exponent of the power law. The exponent \\(\\gamma\\) is typically in the range of 2 to 3 for most real-world networks.\nThe power law degree distribution has important implications for the structure and function of networks. For example, networks with a power law degree distribution are often more robust and resilient to random failures, but more vulnerable to targeted attacks on high-degree nodes.\nNetworks with power law distribution have many nodes with small degree and a few nodes with very large degree.\nfew riches, lots of poors!\n\ndegrees = dict(graph_karate.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_karate))\n    for i in degree_values\n]\n\n# plotting\nplt.plot(degree_values, histogram, \"o\")\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nYou can use barabasi_albert_graph(n,m) to construct a n-node preferential attachment network, where each new node attaches to m existing nodes.\n\nn = 500  # n-node\nm = 2  # each new node attaches to m existing nodes.\ngraph_barabasi = nx.barabasi_albert_graph(n, m)\n\n# degrees\ndegrees = dict(graph_barabasi.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_barabasi))\n    for i in degree_values\n]\n\n# plotting\nplt.plot(degree_values, histogram, \"o\")\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.show()\n\n\n\n\n\n\n\n\n\nnx.draw(graph_barabasi, node_size=1)\n\n\n\n\n\n\n\n\nSocial networks tend to have high clustering coefficient and small average path length.\n\nprint(\n    nx.average_clustering(graph_barabasi)\n)  # rather low clustring(limitation of the model)\nprint(nx.average_shortest_path_length(graph_barabasi))  # but a short Diameter\n\n0.03963494920250683\n3.7406492985971944\n\n\n\n\n\n\ngraph_watts = nx.watts_strogatz_graph(1000, 6, 0.04)\ndegrees = dict(graph_watts.degree())\ndegree_values = sorted(set(degrees.values()))\nhistogram = [\n    list(degrees.values()).count(i) / float(nx.number_of_nodes(graph_watts))\n    for i in degree_values\n]\nplt.bar(degree_values, histogram)\nplt.xlabel(\"Degree\")\nplt.ylabel(\"Fraction of Nodes\")\nplt.show()"
  },
  {
    "objectID": "references/networkx_kaggle/4-networkx-centrality.html",
    "href": "references/networkx_kaggle/4-networkx-centrality.html",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\n\nCentrality is a measure of the importance of nodes in a network based on their position and connectivity. There are different types of centrality measures, each capturing a different aspect of node importance.\nSome common centrality measures include degree centrality, betweenness centrality, closeness centrality, and eigenvector centrality.\n\n\nDegree centrality is a measure of the importance of a node in a network based on the number of connections it has to other nodes. The degree centrality of a node \\(i\\) can be calculated as:\n\\[C_D(i) = \\frac{k_i}{n-1}\\]\nwhere \\(k_i\\) is the degree of node \\(i\\), i.e., the number of edges that are incident to the node, and \\(n\\) is the total number of nodes in the network. The denominator \\(n-1\\) is used to account for the fact that a node cannot be connected to itself.\nThe degree centrality of a node ranges from 0 to 1, with a higher value indicating a more central node in the network. Nodes with a high degree centrality are typically well-connected to other nodes, and their removal from the network can have a significant impact on its connectivity.\n\ngraph_karate = nx.karate_club_graph()\ngraph_karate = nx.convert_node_labels_to_integers(graph_karate, first_label=1)\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\n\n# degree centrality\ndegCent = nx.degree_centrality(graph_karate)\ndegCent\n\n{1: 0.48484848484848486,\n 2: 0.2727272727272727,\n 3: 0.30303030303030304,\n 4: 0.18181818181818182,\n 5: 0.09090909090909091,\n 6: 0.12121212121212122,\n 7: 0.12121212121212122,\n 8: 0.12121212121212122,\n 9: 0.15151515151515152,\n 10: 0.06060606060606061,\n 11: 0.09090909090909091,\n 12: 0.030303030303030304,\n 13: 0.06060606060606061,\n 14: 0.15151515151515152,\n 15: 0.06060606060606061,\n 16: 0.06060606060606061,\n 17: 0.06060606060606061,\n 18: 0.06060606060606061,\n 19: 0.06060606060606061,\n 20: 0.09090909090909091,\n 21: 0.06060606060606061,\n 22: 0.06060606060606061,\n 23: 0.06060606060606061,\n 24: 0.15151515151515152,\n 25: 0.09090909090909091,\n 26: 0.09090909090909091,\n 27: 0.06060606060606061,\n 28: 0.12121212121212122,\n 29: 0.09090909090909091,\n 30: 0.12121212121212122,\n 31: 0.12121212121212122,\n 32: 0.18181818181818182,\n 33: 0.36363636363636365,\n 34: 0.5151515151515151}\n\n\n\n# sort based on degree centrality\nsorted_degcent = {\n    k: v for k, v in sorted(degCent.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_degcent\n\n{34: 0.5151515151515151,\n 1: 0.48484848484848486,\n 33: 0.36363636363636365,\n 3: 0.30303030303030304,\n 2: 0.2727272727272727,\n 4: 0.18181818181818182,\n 32: 0.18181818181818182,\n 9: 0.15151515151515152,\n 14: 0.15151515151515152,\n 24: 0.15151515151515152,\n 6: 0.12121212121212122,\n 7: 0.12121212121212122,\n 8: 0.12121212121212122,\n 28: 0.12121212121212122,\n 30: 0.12121212121212122,\n 31: 0.12121212121212122,\n 5: 0.09090909090909091,\n 11: 0.09090909090909091,\n 20: 0.09090909090909091,\n 25: 0.09090909090909091,\n 26: 0.09090909090909091,\n 29: 0.09090909090909091,\n 10: 0.06060606060606061,\n 13: 0.06060606060606061,\n 15: 0.06060606060606061,\n 16: 0.06060606060606061,\n 17: 0.06060606060606061,\n 18: 0.06060606060606061,\n 19: 0.06060606060606061,\n 21: 0.06060606060606061,\n 22: 0.06060606060606061,\n 23: 0.06060606060606061,\n 27: 0.06060606060606061,\n 12: 0.030303030303030304}\n\n\n\n# degree centrality of a node\n\ndegCent[34]\n\n0.5151515151515151\n\n\n\n# draw a network with node sizes based on their degree centrality\n\n# create a list of node sizes based on degree centrality\nnode_sizes = [10000 * v * v for v in degCent.values()]\n\n# draw the graph\nnx.draw(\n    graph_karate,\n    with_labels=True,\n    node_size=node_sizes,\n    pos=nx.spring_layout(graph_karate),\n)\n\n\n\n\n\n\n\n\n\n# colors based on degree centrality\nnode_colors = [v for v in degCent.values()]\n# draw the graph\nnx.draw(\n    graph_karate,\n    with_labels=True,\n    node_size=node_sizes,\n    pos=nx.spring_layout(graph_karate),\n    node_color=node_colors,\n    cmap=plt.cm.PuBu,\n)  # graph_karatereens\n\n# PuBu stands for \"Pu\" (purple) to \"Bu\" (blue), and it is a sequential colormap that ranges from light purple to dark blue.\n\n\n\n\n\n\n\n\n\n\n\nUndirected networks: use degree\nDirected networks: use in-degree or out-degree\n\n# describe a directed graph gllobally\n# directed graph\ngraph_directed = nx.DiGraph()\n\ngraph_directed.add_edge(\"A\", \"B\")\ngraph_directed.add_edge(\"A\", \"D\")\ngraph_directed.add_edge(\"A\", \"C\")\ngraph_directed.add_edge(\"B\", \"D\")\n\n# draw the nodes with labels\nnx.draw(graph_directed, with_labels=True)\n\n\n\n\n\n\n\n\n\n# indegree\nindegCent = nx.in_degree_centrality(graph_directed)\nindegCent\n\n{'A': 0.0,\n 'B': 0.3333333333333333,\n 'D': 0.6666666666666666,\n 'C': 0.3333333333333333}\n\n\n\n# out-degree\noutdegCent = nx.out_degree_centrality(graph_directed)\noutdegCent\n\n{'A': 1.0, 'B': 0.3333333333333333, 'D': 0.0, 'C': 0.0}\n\n\n\n# A specific node\noutdegCent[\"A\"]\n\n1.0\n\n\n\n\n\nCloseness centrality is a measure of the average distance of a node to all other nodes in the network. The closeness centrality of a node \\(i\\) can be calculated as:\n\\[C_C(i) = \\frac{1}{\\sum\\limits_{j \\neq i} d_{ij}}\\]\nwhere \\(d_{ij}\\) is the shortest path distance between nodes \\(i\\) and \\(j\\). The closeness centrality of a node ranges from 0 to 1, with a higher value indicating a shorter average distance to all other nodes in the network.\nThe closeness centrality of a node measures how quickly it can spread information or influence throughout the network, as nodes with a shorter average distance to all other nodes can communicate more efficiently. In addition, nodes with a high closeness centrality are often located in the center of the network, and their removal can have a significant impact on the network’s connectivity.\n\n# Closness centrality\ncloseCent = nx.closeness_centrality(graph_directed)\ncloseCent\n\n{'A': 0.0,\n 'B': 0.3333333333333333,\n 'D': 0.6666666666666666,\n 'C': 0.3333333333333333}\n\n\n\n# Another way to compute Closeness Centrality of a node\nNodeNumber = 34\n(len(graph_karate.nodes()) - 1) / sum(\n    nx.shortest_path_length(graph_karate, NodeNumber).values()\n)\n\n0.55\n\n\n\n\n\nBetweenness centrality is a measure of the extent to which a node lies on the shortest paths between other nodes in the network. The betweenness centrality of a node \\(i\\) can be calculated as:\n\\[C_B(i) = \\sum\\limits_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}\\]\nwhere \\(s\\) and \\(t\\) are two nodes in the network, \\(\\sigma_{st}\\) is the total number of shortest paths between \\(s\\) and \\(t\\), and \\(\\sigma_{st}(i)\\) is the number of shortest paths between \\(s\\) and \\(t\\) that pass through node \\(i\\).\nThe betweenness centrality of a node ranges from 0 to 1, with a higher value indicating a greater number of shortest paths that pass through the node. Nodes with a high betweenness centrality are often located on the “bridges” between different clusters or communities in the network, and their removal can have a significant impact on the network’s connectivity.\n\nbtwnCent = nx.betweenness_centrality(graph_karate, endpoints=False)\n# endpoints = False states that each node dose not included in computation for shortest path numeration\nbtwnCent\n\n{1: 0.43763528138528146,\n 2: 0.053936688311688304,\n 3: 0.14365680615680618,\n 4: 0.011909271284271283,\n 5: 0.0006313131313131313,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 8: 0.0,\n 9: 0.05592682780182781,\n 10: 0.0008477633477633478,\n 11: 0.0006313131313131313,\n 12: 0.0,\n 13: 0.0,\n 14: 0.04586339586339586,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.03247504810004811,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.017613636363636363,\n 25: 0.0022095959595959595,\n 26: 0.0038404882154882154,\n 27: 0.0,\n 28: 0.02233345358345358,\n 29: 0.0017947330447330447,\n 30: 0.0029220779220779218,\n 31: 0.014411976911976909,\n 32: 0.13827561327561325,\n 33: 0.145247113997114,\n 34: 0.30407497594997596}\n\n\n\nsorted_btwnCent = {\n    k: v for k, v in sorted(btwnCent.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_btwnCent\n\n{1: 0.43763528138528146,\n 34: 0.30407497594997596,\n 33: 0.145247113997114,\n 3: 0.14365680615680618,\n 32: 0.13827561327561325,\n 9: 0.05592682780182781,\n 2: 0.053936688311688304,\n 14: 0.04586339586339586,\n 20: 0.03247504810004811,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 28: 0.02233345358345358,\n 24: 0.017613636363636363,\n 31: 0.014411976911976909,\n 4: 0.011909271284271283,\n 26: 0.0038404882154882154,\n 30: 0.0029220779220779218,\n 25: 0.0022095959595959595,\n 29: 0.0017947330447330447,\n 10: 0.0008477633477633478,\n 5: 0.0006313131313131313,\n 11: 0.0006313131313131313,\n 8: 0.0,\n 12: 0.0,\n 13: 0.0,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 27: 0.0}\n\n\nbetwenness centrality values will be larger in graphs with many nodes. To control for this, we divide centrality values by the number of pairs of nodes in the graph (excluding i)\n\n# comparison betweeness centrality in networks with diffrent number of nodes:\n# more nodes =&gt; bigger betweeness centrality =&gt; useing normalization\nbtwnCent = nx.betweenness_centrality(\n    graph_karate, normalized=True, endpoints=False\n)  # defualt = normalize!\nbtwnCent\n\n{1: 0.43763528138528146,\n 2: 0.053936688311688304,\n 3: 0.14365680615680618,\n 4: 0.011909271284271283,\n 5: 0.0006313131313131313,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 8: 0.0,\n 9: 0.05592682780182781,\n 10: 0.0008477633477633478,\n 11: 0.0006313131313131313,\n 12: 0.0,\n 13: 0.0,\n 14: 0.04586339586339586,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.03247504810004811,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.017613636363636363,\n 25: 0.0022095959595959595,\n 26: 0.0038404882154882154,\n 27: 0.0,\n 28: 0.02233345358345358,\n 29: 0.0017947330447330447,\n 30: 0.0029220779220779218,\n 31: 0.014411976911976909,\n 32: 0.13827561327561325,\n 33: 0.145247113997114,\n 34: 0.30407497594997596}\n\n\nComputing betweenness centrality of all nodes can be very computationally expensive.\nApproximation: rather than computing betweenness centrality based on all pairs of nodes s,t , we can approximate it based on a sample of nodes.\n\n# betweenness centrality approximation\nbtwnCent_approx = nx.betweenness_centrality(\n    graph_karate, normalized=True, endpoints=False, k=10\n)  # number of samples = k\nbtwnCent_approx\n\n{1: 0.4575138287638286,\n 2: 0.08368145743145743,\n 3: 0.1283688071188071,\n 4: 0.005723905723905724,\n 5: 0.0010732323232323232,\n 6: 0.0139520202020202,\n 7: 0.013952020202020203,\n 8: 0.0,\n 9: 0.05614027176527176,\n 10: 0.0,\n 11: 0.0010732323232323232,\n 12: 0.0,\n 13: 0.0,\n 14: 0.036014610389610395,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.0320794252044252,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.03616792929292929,\n 25: 0.005366161616161615,\n 26: 0.00093013468013468,\n 27: 0.0,\n 28: 0.008657407407407407,\n 29: 0.0005366161616161616,\n 30: 0.0010732323232323232,\n 31: 0.023565115440115438,\n 32: 0.15291005291005288,\n 33: 0.1458471620971621,\n 34: 0.32150974025974033}\n\n\n\nsorted_btwnCent = {\n    k: v\n    for k, v in sorted(btwnCent_approx.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_btwnCent\n\n{1: 0.4575138287638286,\n 34: 0.32150974025974033,\n 32: 0.15291005291005288,\n 33: 0.1458471620971621,\n 3: 0.1283688071188071,\n 2: 0.08368145743145743,\n 9: 0.05614027176527176,\n 24: 0.03616792929292929,\n 14: 0.036014610389610395,\n 20: 0.0320794252044252,\n 31: 0.023565115440115438,\n 7: 0.013952020202020203,\n 6: 0.0139520202020202,\n 28: 0.008657407407407407,\n 4: 0.005723905723905724,\n 25: 0.005366161616161615,\n 5: 0.0010732323232323232,\n 11: 0.0010732323232323232,\n 30: 0.0010732323232323232,\n 26: 0.00093013468013468,\n 29: 0.0005366161616161616,\n 8: 0.0,\n 10: 0.0,\n 12: 0.0,\n 13: 0.0,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 27: 0.0}\n\n\n\n\n\nbtwnCent_subset = nx.betweenness_centrality_subset(\n    graph_karate,\n    [34, 21, 30, 16, 27, 15, 23, 10],\n    [1, 4, 13, 11, 6, 12, 17, 7],\n    normalized=True,\n)\nbtwnCent_subset\n\n{1: 0.04355008417508417,\n 2: 0.0,\n 3: 0.01505381192881193,\n 4: 0.0019044612794612795,\n 5: 0.0,\n 6: 0.003787878787878788,\n 7: 0.003787878787878788,\n 8: 0.0,\n 9: 0.012388768638768638,\n 10: 0.0,\n 11: 0.0,\n 12: 0.0,\n 13: 0.0,\n 14: 0.012970478595478596,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.007804232804232804,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.0,\n 25: 0.0,\n 26: 0.0,\n 27: 0.0,\n 28: 0.0,\n 29: 0.0,\n 30: 0.0,\n 31: 0.0,\n 32: 0.012388768638768638,\n 33: 0.01664712602212602,\n 34: 0.028807419432419434}\n\n\n\n\n\n\nBetweenness centrality for edges is a measure of the extent to which an edge lies on the shortest paths between other edges in the network. The betweenness centrality of an edge \\(e\\) can be calculated as:\n\\[C_B(e) = \\sum_{s \\neq e \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}\\]\nwhere \\(s\\) and \\(t\\) are two nodes in the network, \\(\\sigma_{st}\\) is the total number of shortest paths between \\(s\\) and \\(t\\), and \\(\\sigma_{st}(e)\\) is the number of shortest paths between \\(s\\) and \\(t\\) that pass through edge \\(e\\).\nThe betweenness centrality of an edge ranges from 0 to 1, with a higher value indicating a greater number of shortest paths that pass through the edge. Edges with a high betweenness centrality are often located on the “bridges” between different clusters or communities in the network, and their removal can have a significant impact on the network’s connectivity.\n\nbtwnCent_edge = nx.edge_betweenness_centrality(graph_karate, normalized=True)\nbtwnCent_edge\n\n{(1, 2): 0.025252525252525245,\n (1, 3): 0.0777876807288572,\n (1, 4): 0.02049910873440285,\n (1, 5): 0.0522875816993464,\n (1, 6): 0.07813428401663694,\n (1, 7): 0.07813428401663695,\n (1, 8): 0.0228206434088787,\n (1, 9): 0.07423959482783014,\n (1, 11): 0.0522875816993464,\n (1, 12): 0.058823529411764705,\n (1, 13): 0.04652406417112298,\n (1, 14): 0.04237189825425121,\n (1, 18): 0.04012392835922248,\n (1, 20): 0.045936960642843,\n (1, 22): 0.040123928359222474,\n (1, 32): 0.1272599949070537,\n (2, 3): 0.023232323232323233,\n (2, 4): 0.0077243018419489,\n (2, 8): 0.007422969187675069,\n (2, 14): 0.01240556828792123,\n (2, 18): 0.01869960105254222,\n (2, 20): 0.014633732280791102,\n (2, 22): 0.01869960105254222,\n (2, 31): 0.032280791104320514,\n (3, 4): 0.022430184194890075,\n (3, 8): 0.025214328155504617,\n (3, 9): 0.009175791528732704,\n (3, 10): 0.030803836686189627,\n (3, 14): 0.007630931160342923,\n (3, 28): 0.04119203236850296,\n (3, 29): 0.02278244631185807,\n (3, 33): 0.06898678663384543,\n (4, 8): 0.003365588659706307,\n (4, 13): 0.012299465240641705,\n (4, 14): 0.01492233256939139,\n (5, 7): 0.0047534165181224,\n (5, 11): 0.0029708853238265,\n (6, 7): 0.0029708853238265003,\n (6, 11): 0.0047534165181224,\n (6, 17): 0.029411764705882353,\n (7, 17): 0.029411764705882353,\n (9, 31): 0.00980392156862745,\n (9, 33): 0.0304416716181422,\n (9, 34): 0.04043657867187279,\n (10, 34): 0.029615482556659026,\n (14, 34): 0.06782389723566191,\n (15, 33): 0.024083977025153497,\n (15, 34): 0.03473955238661121,\n (16, 33): 0.024083977025153497,\n (16, 34): 0.03473955238661121,\n (19, 33): 0.024083977025153497,\n (19, 34): 0.03473955238661121,\n (20, 34): 0.05938233879410351,\n (21, 33): 0.024083977025153497,\n (21, 34): 0.03473955238661121,\n (23, 33): 0.024083977025153493,\n (23, 34): 0.03473955238661121,\n (24, 26): 0.019776193305605066,\n (24, 28): 0.010536739948504653,\n (24, 30): 0.00665478312537136,\n (24, 33): 0.022341057635175278,\n (24, 34): 0.03266983561101209,\n (25, 26): 0.0042186571598336305,\n (25, 28): 0.018657159833630418,\n (25, 32): 0.040106951871657755,\n (26, 32): 0.04205783323430383,\n (27, 30): 0.004532722179781003,\n (27, 34): 0.0542908072319837,\n (28, 34): 0.030477039300568713,\n (29, 32): 0.0148544266191325,\n (29, 34): 0.024564977506153975,\n (30, 33): 0.023328523328523323,\n (30, 34): 0.029807882749059215,\n (31, 33): 0.01705288175876411,\n (31, 34): 0.02681436210847975,\n (32, 33): 0.04143394731630026,\n (32, 34): 0.05339388280564752,\n (33, 34): 0.008225108225108224}\n\n\n\n\n\nEigenvalue centrality is a measure of the importance of a node in a network based on the importance of its neighbors. The eigenvalue centrality of a node \\(i\\) can be calculated as the principal eigenvector of the adjacency matrix \\(\\mathbf{A}\\) of the network:\n\\[\\mathbf{Av} = \\lambda \\mathbf{v}\\]\nwhere \\(\\mathbf{v}\\) is the eigenvector corresponding to the largest eigenvalue \\(\\lambda\\). The eigenvalue centrality of node \\(i\\) is then given by the \\(i\\)-th element of \\(\\mathbf{v}\\).\nThe eigenvalue centrality of a node ranges from 0 to 1, with a higher value indicating a greater importance of the node and its neighbors in the network. Nodes with a high eigenvalue centrality are often located in the center of the network and are well-connected to other highly connected nodes, and their removal can have a significant impact on the network’s connectivity.\n\n# Compute the adjacency matrix of the network\nA = nx.adjacency_matrix(graph_karate)\n\n# Compute the principal eigenvector of the adjacency matrix\neigenvector_centrality = nx.eigenvector_centrality_numpy(graph_karate)\neigenvector_centrality\n\n{1: 0.3554914445245666,\n 2: 0.2659599195524917,\n 3: 0.3171925044864317,\n 4: 0.21117972037789046,\n 5: 0.07596881818306869,\n 6: 0.07948304511709926,\n 7: 0.07948304511709926,\n 8: 0.17095974804479655,\n 9: 0.22740390712540018,\n 10: 0.1026742507235863,\n 11: 0.07596881818306875,\n 12: 0.05285569749352127,\n 13: 0.08425462871671377,\n 14: 0.22647272014248135,\n 15: 0.10140326218952456,\n 16: 0.10140326218952456,\n 17: 0.02363562810459123,\n 18: 0.09239953819570257,\n 19: 0.10140326218952456,\n 20: 0.14791251029338737,\n 21: 0.10140326218952452,\n 22: 0.09239953819570255,\n 23: 0.10140326218952454,\n 24: 0.1501185718611527,\n 25: 0.057052440541165546,\n 26: 0.05920647491677841,\n 27: 0.07557941348827209,\n 28: 0.13347715338024016,\n 29: 0.1310778229837107,\n 30: 0.13496081926232775,\n 31: 0.17475830231435288,\n 32: 0.19103384140654373,\n 33: 0.30864421979104706,\n 34: 0.3733634702914831}\n\n\n\nsorted_EigenCent = {\n    k: v\n    for k, v in sorted(\n        eigenvector_centrality.items(), key=lambda item: item[1], reverse=True\n    )\n}\nsorted_EigenCent\n\n{34: 0.3733634702914831,\n 1: 0.3554914445245666,\n 3: 0.3171925044864317,\n 33: 0.30864421979104706,\n 2: 0.2659599195524917,\n 9: 0.22740390712540018,\n 14: 0.22647272014248135,\n 4: 0.21117972037789046,\n 32: 0.19103384140654373,\n 31: 0.17475830231435288,\n 8: 0.17095974804479655,\n 24: 0.1501185718611527,\n 20: 0.14791251029338737,\n 30: 0.13496081926232775,\n 28: 0.13347715338024016,\n 29: 0.1310778229837107,\n 10: 0.1026742507235863,\n 15: 0.10140326218952456,\n 16: 0.10140326218952456,\n 19: 0.10140326218952456,\n 23: 0.10140326218952454,\n 21: 0.10140326218952452,\n 18: 0.09239953819570257,\n 22: 0.09239953819570255,\n 13: 0.08425462871671377,\n 6: 0.07948304511709926,\n 7: 0.07948304511709926,\n 11: 0.07596881818306875,\n 5: 0.07596881818306869,\n 27: 0.07557941348827209,\n 26: 0.05920647491677841,\n 25: 0.057052440541165546,\n 12: 0.05285569749352127,\n 17: 0.02363562810459123}"
  },
  {
    "objectID": "references/networkx_kaggle/4-networkx-centrality.html#installing-networkx",
    "href": "references/networkx_kaggle/4-networkx-centrality.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx"
  },
  {
    "objectID": "references/networkx_kaggle/4-networkx-centrality.html#centrality",
    "href": "references/networkx_kaggle/4-networkx-centrality.html#centrality",
    "title": "NetworkX",
    "section": "",
    "text": "Centrality is a measure of the importance of nodes in a network based on their position and connectivity. There are different types of centrality measures, each capturing a different aspect of node importance.\nSome common centrality measures include degree centrality, betweenness centrality, closeness centrality, and eigenvector centrality.\n\n\nDegree centrality is a measure of the importance of a node in a network based on the number of connections it has to other nodes. The degree centrality of a node \\(i\\) can be calculated as:\n\\[C_D(i) = \\frac{k_i}{n-1}\\]\nwhere \\(k_i\\) is the degree of node \\(i\\), i.e., the number of edges that are incident to the node, and \\(n\\) is the total number of nodes in the network. The denominator \\(n-1\\) is used to account for the fact that a node cannot be connected to itself.\nThe degree centrality of a node ranges from 0 to 1, with a higher value indicating a more central node in the network. Nodes with a high degree centrality are typically well-connected to other nodes, and their removal from the network can have a significant impact on its connectivity.\n\ngraph_karate = nx.karate_club_graph()\ngraph_karate = nx.convert_node_labels_to_integers(graph_karate, first_label=1)\nnx.draw(graph_karate, with_labels=True)\n\n\n\n\n\n\n\n\n\n# degree centrality\ndegCent = nx.degree_centrality(graph_karate)\ndegCent\n\n{1: 0.48484848484848486,\n 2: 0.2727272727272727,\n 3: 0.30303030303030304,\n 4: 0.18181818181818182,\n 5: 0.09090909090909091,\n 6: 0.12121212121212122,\n 7: 0.12121212121212122,\n 8: 0.12121212121212122,\n 9: 0.15151515151515152,\n 10: 0.06060606060606061,\n 11: 0.09090909090909091,\n 12: 0.030303030303030304,\n 13: 0.06060606060606061,\n 14: 0.15151515151515152,\n 15: 0.06060606060606061,\n 16: 0.06060606060606061,\n 17: 0.06060606060606061,\n 18: 0.06060606060606061,\n 19: 0.06060606060606061,\n 20: 0.09090909090909091,\n 21: 0.06060606060606061,\n 22: 0.06060606060606061,\n 23: 0.06060606060606061,\n 24: 0.15151515151515152,\n 25: 0.09090909090909091,\n 26: 0.09090909090909091,\n 27: 0.06060606060606061,\n 28: 0.12121212121212122,\n 29: 0.09090909090909091,\n 30: 0.12121212121212122,\n 31: 0.12121212121212122,\n 32: 0.18181818181818182,\n 33: 0.36363636363636365,\n 34: 0.5151515151515151}\n\n\n\n# sort based on degree centrality\nsorted_degcent = {\n    k: v for k, v in sorted(degCent.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_degcent\n\n{34: 0.5151515151515151,\n 1: 0.48484848484848486,\n 33: 0.36363636363636365,\n 3: 0.30303030303030304,\n 2: 0.2727272727272727,\n 4: 0.18181818181818182,\n 32: 0.18181818181818182,\n 9: 0.15151515151515152,\n 14: 0.15151515151515152,\n 24: 0.15151515151515152,\n 6: 0.12121212121212122,\n 7: 0.12121212121212122,\n 8: 0.12121212121212122,\n 28: 0.12121212121212122,\n 30: 0.12121212121212122,\n 31: 0.12121212121212122,\n 5: 0.09090909090909091,\n 11: 0.09090909090909091,\n 20: 0.09090909090909091,\n 25: 0.09090909090909091,\n 26: 0.09090909090909091,\n 29: 0.09090909090909091,\n 10: 0.06060606060606061,\n 13: 0.06060606060606061,\n 15: 0.06060606060606061,\n 16: 0.06060606060606061,\n 17: 0.06060606060606061,\n 18: 0.06060606060606061,\n 19: 0.06060606060606061,\n 21: 0.06060606060606061,\n 22: 0.06060606060606061,\n 23: 0.06060606060606061,\n 27: 0.06060606060606061,\n 12: 0.030303030303030304}\n\n\n\n# degree centrality of a node\n\ndegCent[34]\n\n0.5151515151515151\n\n\n\n# draw a network with node sizes based on their degree centrality\n\n# create a list of node sizes based on degree centrality\nnode_sizes = [10000 * v * v for v in degCent.values()]\n\n# draw the graph\nnx.draw(\n    graph_karate,\n    with_labels=True,\n    node_size=node_sizes,\n    pos=nx.spring_layout(graph_karate),\n)\n\n\n\n\n\n\n\n\n\n# colors based on degree centrality\nnode_colors = [v for v in degCent.values()]\n# draw the graph\nnx.draw(\n    graph_karate,\n    with_labels=True,\n    node_size=node_sizes,\n    pos=nx.spring_layout(graph_karate),\n    node_color=node_colors,\n    cmap=plt.cm.PuBu,\n)  # graph_karatereens\n\n# PuBu stands for \"Pu\" (purple) to \"Bu\" (blue), and it is a sequential colormap that ranges from light purple to dark blue.\n\n\n\n\n\n\n\n\n\n\n\nUndirected networks: use degree\nDirected networks: use in-degree or out-degree\n\n# describe a directed graph gllobally\n# directed graph\ngraph_directed = nx.DiGraph()\n\ngraph_directed.add_edge(\"A\", \"B\")\ngraph_directed.add_edge(\"A\", \"D\")\ngraph_directed.add_edge(\"A\", \"C\")\ngraph_directed.add_edge(\"B\", \"D\")\n\n# draw the nodes with labels\nnx.draw(graph_directed, with_labels=True)\n\n\n\n\n\n\n\n\n\n# indegree\nindegCent = nx.in_degree_centrality(graph_directed)\nindegCent\n\n{'A': 0.0,\n 'B': 0.3333333333333333,\n 'D': 0.6666666666666666,\n 'C': 0.3333333333333333}\n\n\n\n# out-degree\noutdegCent = nx.out_degree_centrality(graph_directed)\noutdegCent\n\n{'A': 1.0, 'B': 0.3333333333333333, 'D': 0.0, 'C': 0.0}\n\n\n\n# A specific node\noutdegCent[\"A\"]\n\n1.0\n\n\n\n\n\nCloseness centrality is a measure of the average distance of a node to all other nodes in the network. The closeness centrality of a node \\(i\\) can be calculated as:\n\\[C_C(i) = \\frac{1}{\\sum\\limits_{j \\neq i} d_{ij}}\\]\nwhere \\(d_{ij}\\) is the shortest path distance between nodes \\(i\\) and \\(j\\). The closeness centrality of a node ranges from 0 to 1, with a higher value indicating a shorter average distance to all other nodes in the network.\nThe closeness centrality of a node measures how quickly it can spread information or influence throughout the network, as nodes with a shorter average distance to all other nodes can communicate more efficiently. In addition, nodes with a high closeness centrality are often located in the center of the network, and their removal can have a significant impact on the network’s connectivity.\n\n# Closness centrality\ncloseCent = nx.closeness_centrality(graph_directed)\ncloseCent\n\n{'A': 0.0,\n 'B': 0.3333333333333333,\n 'D': 0.6666666666666666,\n 'C': 0.3333333333333333}\n\n\n\n# Another way to compute Closeness Centrality of a node\nNodeNumber = 34\n(len(graph_karate.nodes()) - 1) / sum(\n    nx.shortest_path_length(graph_karate, NodeNumber).values()\n)\n\n0.55\n\n\n\n\n\nBetweenness centrality is a measure of the extent to which a node lies on the shortest paths between other nodes in the network. The betweenness centrality of a node \\(i\\) can be calculated as:\n\\[C_B(i) = \\sum\\limits_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}\\]\nwhere \\(s\\) and \\(t\\) are two nodes in the network, \\(\\sigma_{st}\\) is the total number of shortest paths between \\(s\\) and \\(t\\), and \\(\\sigma_{st}(i)\\) is the number of shortest paths between \\(s\\) and \\(t\\) that pass through node \\(i\\).\nThe betweenness centrality of a node ranges from 0 to 1, with a higher value indicating a greater number of shortest paths that pass through the node. Nodes with a high betweenness centrality are often located on the “bridges” between different clusters or communities in the network, and their removal can have a significant impact on the network’s connectivity.\n\nbtwnCent = nx.betweenness_centrality(graph_karate, endpoints=False)\n# endpoints = False states that each node dose not included in computation for shortest path numeration\nbtwnCent\n\n{1: 0.43763528138528146,\n 2: 0.053936688311688304,\n 3: 0.14365680615680618,\n 4: 0.011909271284271283,\n 5: 0.0006313131313131313,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 8: 0.0,\n 9: 0.05592682780182781,\n 10: 0.0008477633477633478,\n 11: 0.0006313131313131313,\n 12: 0.0,\n 13: 0.0,\n 14: 0.04586339586339586,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.03247504810004811,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.017613636363636363,\n 25: 0.0022095959595959595,\n 26: 0.0038404882154882154,\n 27: 0.0,\n 28: 0.02233345358345358,\n 29: 0.0017947330447330447,\n 30: 0.0029220779220779218,\n 31: 0.014411976911976909,\n 32: 0.13827561327561325,\n 33: 0.145247113997114,\n 34: 0.30407497594997596}\n\n\n\nsorted_btwnCent = {\n    k: v for k, v in sorted(btwnCent.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_btwnCent\n\n{1: 0.43763528138528146,\n 34: 0.30407497594997596,\n 33: 0.145247113997114,\n 3: 0.14365680615680618,\n 32: 0.13827561327561325,\n 9: 0.05592682780182781,\n 2: 0.053936688311688304,\n 14: 0.04586339586339586,\n 20: 0.03247504810004811,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 28: 0.02233345358345358,\n 24: 0.017613636363636363,\n 31: 0.014411976911976909,\n 4: 0.011909271284271283,\n 26: 0.0038404882154882154,\n 30: 0.0029220779220779218,\n 25: 0.0022095959595959595,\n 29: 0.0017947330447330447,\n 10: 0.0008477633477633478,\n 5: 0.0006313131313131313,\n 11: 0.0006313131313131313,\n 8: 0.0,\n 12: 0.0,\n 13: 0.0,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 27: 0.0}\n\n\nbetwenness centrality values will be larger in graphs with many nodes. To control for this, we divide centrality values by the number of pairs of nodes in the graph (excluding i)\n\n# comparison betweeness centrality in networks with diffrent number of nodes:\n# more nodes =&gt; bigger betweeness centrality =&gt; useing normalization\nbtwnCent = nx.betweenness_centrality(\n    graph_karate, normalized=True, endpoints=False\n)  # defualt = normalize!\nbtwnCent\n\n{1: 0.43763528138528146,\n 2: 0.053936688311688304,\n 3: 0.14365680615680618,\n 4: 0.011909271284271283,\n 5: 0.0006313131313131313,\n 6: 0.02998737373737374,\n 7: 0.029987373737373736,\n 8: 0.0,\n 9: 0.05592682780182781,\n 10: 0.0008477633477633478,\n 11: 0.0006313131313131313,\n 12: 0.0,\n 13: 0.0,\n 14: 0.04586339586339586,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.03247504810004811,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.017613636363636363,\n 25: 0.0022095959595959595,\n 26: 0.0038404882154882154,\n 27: 0.0,\n 28: 0.02233345358345358,\n 29: 0.0017947330447330447,\n 30: 0.0029220779220779218,\n 31: 0.014411976911976909,\n 32: 0.13827561327561325,\n 33: 0.145247113997114,\n 34: 0.30407497594997596}\n\n\nComputing betweenness centrality of all nodes can be very computationally expensive.\nApproximation: rather than computing betweenness centrality based on all pairs of nodes s,t , we can approximate it based on a sample of nodes.\n\n# betweenness centrality approximation\nbtwnCent_approx = nx.betweenness_centrality(\n    graph_karate, normalized=True, endpoints=False, k=10\n)  # number of samples = k\nbtwnCent_approx\n\n{1: 0.4575138287638286,\n 2: 0.08368145743145743,\n 3: 0.1283688071188071,\n 4: 0.005723905723905724,\n 5: 0.0010732323232323232,\n 6: 0.0139520202020202,\n 7: 0.013952020202020203,\n 8: 0.0,\n 9: 0.05614027176527176,\n 10: 0.0,\n 11: 0.0010732323232323232,\n 12: 0.0,\n 13: 0.0,\n 14: 0.036014610389610395,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.0320794252044252,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.03616792929292929,\n 25: 0.005366161616161615,\n 26: 0.00093013468013468,\n 27: 0.0,\n 28: 0.008657407407407407,\n 29: 0.0005366161616161616,\n 30: 0.0010732323232323232,\n 31: 0.023565115440115438,\n 32: 0.15291005291005288,\n 33: 0.1458471620971621,\n 34: 0.32150974025974033}\n\n\n\nsorted_btwnCent = {\n    k: v\n    for k, v in sorted(btwnCent_approx.items(), key=lambda item: item[1], reverse=True)\n}\nsorted_btwnCent\n\n{1: 0.4575138287638286,\n 34: 0.32150974025974033,\n 32: 0.15291005291005288,\n 33: 0.1458471620971621,\n 3: 0.1283688071188071,\n 2: 0.08368145743145743,\n 9: 0.05614027176527176,\n 24: 0.03616792929292929,\n 14: 0.036014610389610395,\n 20: 0.0320794252044252,\n 31: 0.023565115440115438,\n 7: 0.013952020202020203,\n 6: 0.0139520202020202,\n 28: 0.008657407407407407,\n 4: 0.005723905723905724,\n 25: 0.005366161616161615,\n 5: 0.0010732323232323232,\n 11: 0.0010732323232323232,\n 30: 0.0010732323232323232,\n 26: 0.00093013468013468,\n 29: 0.0005366161616161616,\n 8: 0.0,\n 10: 0.0,\n 12: 0.0,\n 13: 0.0,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 27: 0.0}\n\n\n\n\n\nbtwnCent_subset = nx.betweenness_centrality_subset(\n    graph_karate,\n    [34, 21, 30, 16, 27, 15, 23, 10],\n    [1, 4, 13, 11, 6, 12, 17, 7],\n    normalized=True,\n)\nbtwnCent_subset\n\n{1: 0.04355008417508417,\n 2: 0.0,\n 3: 0.01505381192881193,\n 4: 0.0019044612794612795,\n 5: 0.0,\n 6: 0.003787878787878788,\n 7: 0.003787878787878788,\n 8: 0.0,\n 9: 0.012388768638768638,\n 10: 0.0,\n 11: 0.0,\n 12: 0.0,\n 13: 0.0,\n 14: 0.012970478595478596,\n 15: 0.0,\n 16: 0.0,\n 17: 0.0,\n 18: 0.0,\n 19: 0.0,\n 20: 0.007804232804232804,\n 21: 0.0,\n 22: 0.0,\n 23: 0.0,\n 24: 0.0,\n 25: 0.0,\n 26: 0.0,\n 27: 0.0,\n 28: 0.0,\n 29: 0.0,\n 30: 0.0,\n 31: 0.0,\n 32: 0.012388768638768638,\n 33: 0.01664712602212602,\n 34: 0.028807419432419434}\n\n\n\n\n\n\nBetweenness centrality for edges is a measure of the extent to which an edge lies on the shortest paths between other edges in the network. The betweenness centrality of an edge \\(e\\) can be calculated as:\n\\[C_B(e) = \\sum_{s \\neq e \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}\\]\nwhere \\(s\\) and \\(t\\) are two nodes in the network, \\(\\sigma_{st}\\) is the total number of shortest paths between \\(s\\) and \\(t\\), and \\(\\sigma_{st}(e)\\) is the number of shortest paths between \\(s\\) and \\(t\\) that pass through edge \\(e\\).\nThe betweenness centrality of an edge ranges from 0 to 1, with a higher value indicating a greater number of shortest paths that pass through the edge. Edges with a high betweenness centrality are often located on the “bridges” between different clusters or communities in the network, and their removal can have a significant impact on the network’s connectivity.\n\nbtwnCent_edge = nx.edge_betweenness_centrality(graph_karate, normalized=True)\nbtwnCent_edge\n\n{(1, 2): 0.025252525252525245,\n (1, 3): 0.0777876807288572,\n (1, 4): 0.02049910873440285,\n (1, 5): 0.0522875816993464,\n (1, 6): 0.07813428401663694,\n (1, 7): 0.07813428401663695,\n (1, 8): 0.0228206434088787,\n (1, 9): 0.07423959482783014,\n (1, 11): 0.0522875816993464,\n (1, 12): 0.058823529411764705,\n (1, 13): 0.04652406417112298,\n (1, 14): 0.04237189825425121,\n (1, 18): 0.04012392835922248,\n (1, 20): 0.045936960642843,\n (1, 22): 0.040123928359222474,\n (1, 32): 0.1272599949070537,\n (2, 3): 0.023232323232323233,\n (2, 4): 0.0077243018419489,\n (2, 8): 0.007422969187675069,\n (2, 14): 0.01240556828792123,\n (2, 18): 0.01869960105254222,\n (2, 20): 0.014633732280791102,\n (2, 22): 0.01869960105254222,\n (2, 31): 0.032280791104320514,\n (3, 4): 0.022430184194890075,\n (3, 8): 0.025214328155504617,\n (3, 9): 0.009175791528732704,\n (3, 10): 0.030803836686189627,\n (3, 14): 0.007630931160342923,\n (3, 28): 0.04119203236850296,\n (3, 29): 0.02278244631185807,\n (3, 33): 0.06898678663384543,\n (4, 8): 0.003365588659706307,\n (4, 13): 0.012299465240641705,\n (4, 14): 0.01492233256939139,\n (5, 7): 0.0047534165181224,\n (5, 11): 0.0029708853238265,\n (6, 7): 0.0029708853238265003,\n (6, 11): 0.0047534165181224,\n (6, 17): 0.029411764705882353,\n (7, 17): 0.029411764705882353,\n (9, 31): 0.00980392156862745,\n (9, 33): 0.0304416716181422,\n (9, 34): 0.04043657867187279,\n (10, 34): 0.029615482556659026,\n (14, 34): 0.06782389723566191,\n (15, 33): 0.024083977025153497,\n (15, 34): 0.03473955238661121,\n (16, 33): 0.024083977025153497,\n (16, 34): 0.03473955238661121,\n (19, 33): 0.024083977025153497,\n (19, 34): 0.03473955238661121,\n (20, 34): 0.05938233879410351,\n (21, 33): 0.024083977025153497,\n (21, 34): 0.03473955238661121,\n (23, 33): 0.024083977025153493,\n (23, 34): 0.03473955238661121,\n (24, 26): 0.019776193305605066,\n (24, 28): 0.010536739948504653,\n (24, 30): 0.00665478312537136,\n (24, 33): 0.022341057635175278,\n (24, 34): 0.03266983561101209,\n (25, 26): 0.0042186571598336305,\n (25, 28): 0.018657159833630418,\n (25, 32): 0.040106951871657755,\n (26, 32): 0.04205783323430383,\n (27, 30): 0.004532722179781003,\n (27, 34): 0.0542908072319837,\n (28, 34): 0.030477039300568713,\n (29, 32): 0.0148544266191325,\n (29, 34): 0.024564977506153975,\n (30, 33): 0.023328523328523323,\n (30, 34): 0.029807882749059215,\n (31, 33): 0.01705288175876411,\n (31, 34): 0.02681436210847975,\n (32, 33): 0.04143394731630026,\n (32, 34): 0.05339388280564752,\n (33, 34): 0.008225108225108224}\n\n\n\n\n\nEigenvalue centrality is a measure of the importance of a node in a network based on the importance of its neighbors. The eigenvalue centrality of a node \\(i\\) can be calculated as the principal eigenvector of the adjacency matrix \\(\\mathbf{A}\\) of the network:\n\\[\\mathbf{Av} = \\lambda \\mathbf{v}\\]\nwhere \\(\\mathbf{v}\\) is the eigenvector corresponding to the largest eigenvalue \\(\\lambda\\). The eigenvalue centrality of node \\(i\\) is then given by the \\(i\\)-th element of \\(\\mathbf{v}\\).\nThe eigenvalue centrality of a node ranges from 0 to 1, with a higher value indicating a greater importance of the node and its neighbors in the network. Nodes with a high eigenvalue centrality are often located in the center of the network and are well-connected to other highly connected nodes, and their removal can have a significant impact on the network’s connectivity.\n\n# Compute the adjacency matrix of the network\nA = nx.adjacency_matrix(graph_karate)\n\n# Compute the principal eigenvector of the adjacency matrix\neigenvector_centrality = nx.eigenvector_centrality_numpy(graph_karate)\neigenvector_centrality\n\n{1: 0.3554914445245666,\n 2: 0.2659599195524917,\n 3: 0.3171925044864317,\n 4: 0.21117972037789046,\n 5: 0.07596881818306869,\n 6: 0.07948304511709926,\n 7: 0.07948304511709926,\n 8: 0.17095974804479655,\n 9: 0.22740390712540018,\n 10: 0.1026742507235863,\n 11: 0.07596881818306875,\n 12: 0.05285569749352127,\n 13: 0.08425462871671377,\n 14: 0.22647272014248135,\n 15: 0.10140326218952456,\n 16: 0.10140326218952456,\n 17: 0.02363562810459123,\n 18: 0.09239953819570257,\n 19: 0.10140326218952456,\n 20: 0.14791251029338737,\n 21: 0.10140326218952452,\n 22: 0.09239953819570255,\n 23: 0.10140326218952454,\n 24: 0.1501185718611527,\n 25: 0.057052440541165546,\n 26: 0.05920647491677841,\n 27: 0.07557941348827209,\n 28: 0.13347715338024016,\n 29: 0.1310778229837107,\n 30: 0.13496081926232775,\n 31: 0.17475830231435288,\n 32: 0.19103384140654373,\n 33: 0.30864421979104706,\n 34: 0.3733634702914831}\n\n\n\nsorted_EigenCent = {\n    k: v\n    for k, v in sorted(\n        eigenvector_centrality.items(), key=lambda item: item[1], reverse=True\n    )\n}\nsorted_EigenCent\n\n{34: 0.3733634702914831,\n 1: 0.3554914445245666,\n 3: 0.3171925044864317,\n 33: 0.30864421979104706,\n 2: 0.2659599195524917,\n 9: 0.22740390712540018,\n 14: 0.22647272014248135,\n 4: 0.21117972037789046,\n 32: 0.19103384140654373,\n 31: 0.17475830231435288,\n 8: 0.17095974804479655,\n 24: 0.1501185718611527,\n 20: 0.14791251029338737,\n 30: 0.13496081926232775,\n 28: 0.13347715338024016,\n 29: 0.1310778229837107,\n 10: 0.1026742507235863,\n 15: 0.10140326218952456,\n 16: 0.10140326218952456,\n 19: 0.10140326218952456,\n 23: 0.10140326218952454,\n 21: 0.10140326218952452,\n 18: 0.09239953819570257,\n 22: 0.09239953819570255,\n 13: 0.08425462871671377,\n 6: 0.07948304511709926,\n 7: 0.07948304511709926,\n 11: 0.07596881818306875,\n 5: 0.07596881818306869,\n 27: 0.07557941348827209,\n 26: 0.05920647491677841,\n 25: 0.057052440541165546,\n 12: 0.05285569749352127,\n 17: 0.02363562810459123}"
  },
  {
    "objectID": "references/networkx_indiana/6-networkx-simulation.html",
    "href": "references/networkx_indiana/6-networkx-simulation.html",
    "title": "NetworkX - Simulation",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nThis tutorial will show you how to use the included Simulation class to simulate node dynamics by specifying a graph, the initial state of the nodes, and node state transitions.\nContents:\n\nThe Simulation class\nVoter model\nSIS model\nConclusion\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\nfrom simulation import Simulation\n\n\n\nIncluded with these tutorials is a simulation.py file that contains a Simulation class. This class will allow us to skip the details of writing a simulation, allowing us to concentrate on the interesting parts.\n\n\nA simulation is made up of three main parts:\n\nThe graph on which to simulate node dynamics\nThe initial state of each node\nThe state transition function\n\n\n\nThis one is easy, we just need a NetworkX Graph instance. For this example we’ll use a random graph. You can run the following cell multiple times if you wish, until you get a graph that looks good:\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIn these simulations, state is represented as a dictionary where the keys are node names and the values are the state of the node. We can specify the initial state either directly as one of these dictionaries, or we can specify a function that generates such a state dictionary.\nThe function version is cleaner; let’s use it to generate a very simple initial state where every node has the same state: ‘asleep’.\n\n# An initial_state function takes one argument, the graph instance.\ndef initial_state(G: nx.Graph) -&gt; dict:\n    state = {}\n    for node in G.nodes:\n        state[node] = \"asleep\"\n    return state\n\n\n# We can test this function out to make sure it works on our graph and produces a dictionary with a state value for each node:\ninitial_state(G)\n\n{0: 'asleep',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'asleep',\n 4: 'asleep',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'asleep',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'asleep',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'asleep',\n 18: 'asleep',\n 19: 'asleep'}\n\n\n\n\n\nThe crux of the simulation is the state transition function: this is where we specify the dynamics. This function takes two arguments, the graph and the current node states provided as a dictionary, and should return a dictionary of the updated states.\nIn this simple example, at each simulation step, each node with the 'asleep' state will have a fixed probability to transition to the 'awake' state. We’ll specify this probability as p_awaken, the probability an asleep node will awaken at each step.\nGenerically, in order to do a thing with some probability, we generate a random number between 0 and 1 with the random.random() function and compare to our probability threshold: if the random number is below our probability threshold, then we do the thing.\n\ndef state_transition(G: nx.graph, current_state, p_awaken: float = 0.2):\n    next_state = {}\n    for node in G.nodes:\n        if current_state[node] == \"asleep\":\n            if random.random() &lt; p_awaken:\n                next_state[node] = \"awake\"\n    return next_state\n\nNote that this function only has to provide the states that change during this step, although no harm would be done by specifying the state for every node, changed or not.\nWe can do a dry run if we want, just to make sure our transition function works:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{0: 'awake', 2: 'awake', 9: 'awake', 18: 'awake'}\n\n\nWe should see some nodes transition to the 'awake' state in this test run, which is good.\n\n\n\nWe now have our three pieces: the graph, the initial state, and the state transition function. Let’s put them together along with a name for our simulation to create a Simulation object:\n\nsim = Simulation(G, initial_state, state_transition, name=\"Simple Sim\")\n\nThe name provided here is optional, it just for us to keep track of the images we’ll generate later.\nThis Simulation object has several useful methods. The first of these is the .state() method, which returns a dictionary for the current state of the simulation:\n\nsim.state()\n\n{0: 'asleep',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'asleep',\n 4: 'asleep',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'asleep',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'asleep',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'asleep',\n 18: 'asleep',\n 19: 'asleep'}\n\n\nWe haven’t done any steps in the simulation yet, so the state should be exactly our initial condition.\nWe can also draw the network with its nodes colored by their state values with the .draw() method:\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nOur initial condition has all nodes 'asleep', so this checks out.\n\n\n\n\nWith our initial condition checked out, let’s run the simulation! The simulation will advance in discrete steps: each step is one run of the state transition function.\nThe .run() method without any arguments will run the simulation one step:\n\nsim.run()\n\nWe can confirm the simulation advanced a step by checking out the .steps property, which tells us how many times the state transition function has been run:\n\nsim.steps\n\n1\n\n\nLet’s see what our graph looks like after one step, noting that we can include keyword arguments for the nx.draw() function:\n\nsim.draw(with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nSome of the nodes are awake! We can also see this in the simulation state:\n\nsim.state()\n\n{0: 'awake',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'awake',\n 4: 'awake',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'awake',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'awake',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'awake',\n 18: 'awake',\n 19: 'asleep'}\n\n\nIf we give the .run() method a number, we can run the simulation several steps at once:\n\nsim.run(10)\n\n\nsim.steps\n\n11\n\n\nThe .steps method confirms that our simulation went through several simulation steps. Let’s check up on the current state:\n\nsim.draw(with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nBy this point, all or most of the nodes should be awake, but how did that transition occur? Was it gradual or all at once? With the .plot() method, we can plot the proportion of nodes in each state at each step of the simulation:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIf we want to visualize the state of the graph at a specific step, we can specify the desired step in the .draw() function.\n\nsim.draw(4, with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe same is true for the .state() method:\n\nsim.state(4)\n\n{0: 'awake',\n 1: 'awake',\n 2: 'awake',\n 3: 'awake',\n 4: 'awake',\n 5: 'asleep',\n 6: 'awake',\n 7: 'asleep',\n 8: 'awake',\n 9: 'asleep',\n 10: 'awake',\n 11: 'awake',\n 12: 'awake',\n 13: 'asleep',\n 14: 'awake',\n 15: 'awake',\n 16: 'awake',\n 17: 'awake',\n 18: 'awake',\n 19: 'awake'}\n\n\nIf we only want to plot a subset of the steps, we can do that too by passing the min and/or max steps we want to plot. Do note that the bounds passed to the .plot() method are half-open, like Python’s range() function and list slices, so that .plot(2, 8) plots states from 2 and up to but not including 8.\n\nsim.plot(min_step=2, max_step=8)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn our trivial awake/asleep model above we ignored the underlying graph structure and each node’s dynamics was independent of its neighbors. In interesting network models, we make use of the graph connectivity in some way.\nThe voter model is a simple model of network opinion dynamics capable of producing interesting output. This model is described in detail in the textbook; we’re going to implement it here.\n\n\n\n\nWe’re going to use another random graph here, same as before.\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nFor the initial state, we will randomly assign each node a state by randomly selecting a letter A to D – we’re not limited to two states here!\nWe’ll make use of random.choice() in both the initial state and state transition functions. This function is used to randomly choose one item from a given collection.\n\ndef initial_state(G):\n    state = {}\n    for node in G.nodes:\n        state[node] = random.choice(\"ABCD\")\n    return state\n\nLet’s make sure this works:\n\ninitial_state(G)\n\n{0: 'D',\n 1: 'B',\n 2: 'C',\n 3: 'A',\n 4: 'D',\n 5: 'D',\n 6: 'A',\n 7: 'D',\n 8: 'A',\n 9: 'A',\n 10: 'D',\n 11: 'B',\n 12: 'B',\n 13: 'C',\n 14: 'B',\n 15: 'C',\n 16: 'C',\n 17: 'D',\n 18: 'C',\n 19: 'A'}\n\n\n\n\n\nThe algorithm at the heart of the voter model works like this: for each node in the graph, choose a neighbor at random and copy their “opinion”, i.e. set this node’s state to the same value as that of the neighbor.\n\nFor each node in the graph\n\nChoose a neighbor at random\nSet this node state equal to the neighbor state\n\n\n\ndef state_transition(G: nx.Graph, current_state: dict):\n    next_state = {}\n    for node in G.nodes:\n        # Caveat: what if the node has no neighbors?\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            next_state[node] = current_state[neighbor]\n    return next_state\n\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{0: 'C',\n 1: 'A',\n 2: 'A',\n 3: 'C',\n 4: 'A',\n 5: 'C',\n 6: 'A',\n 7: 'A',\n 8: 'D',\n 9: 'B',\n 10: 'D',\n 11: 'C',\n 12: 'C',\n 13: 'B',\n 14: 'A',\n 15: 'C',\n 16: 'C',\n 17: 'C',\n 18: 'C',\n 19: 'A'}\n\n\n\n\n\nLooks good. Now let’s create the simulation and visualize the initial state:\n\nsim = Simulation(G, initial_state, state_transition, name=\"Voter Model\")\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n# if you care about the order of the labels in the legend,\n# you can specify labels='ABCD' as a keyword argument for .draw()\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\nsim.run(40)\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIt’s probably different from where we started; let’s see how we got here:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGo ahead and execute the previous few cells again, running the simulation forward and examining the state, until it reaches the long-term steady state: all of the nodes should eventually end up with the same state.\n\n\n\nAs written, this state_transition function performs a synchronous update, i.e. all of the nodes’ states are updated at the same time, after the function returns the new state:\n\n# This is the same as in 2.1.3\ndef state_transition(G: nx.Graph, current_state: dict):\n    next_state = {}\n    for node in G.nodes:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            next_state[node] = current_state[neighbor]\n    return next_state\n\nNote how this function never changes the values of current_state so that each node’s update is based on the same information. Since each node “sees” the same state, the order in which we update the nodes doesn’t matter. This is equivalent to updating all of the node states simultaneously.\nOne can instead perform an asynchronous update, where each node sees the state changes that have taken place this step, by making in-place changes to current_state:\n\n# This example is potentially biased, don't use it\ndef state_transition_async(G: nx.Graph, current_state: dict):\n    for node in G.nodes:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n    return current_state\n\nIn this example, each node’s view of current_state reflects the changes made in this step by previous node updates.\nThere is a potential problem here, however: G.nodes is likely to always return the nodes in the same order, thus performing the updates in the same order and potentially introducing bias. We should instead loop over the nodes in a random order each time:\n\ndef state_transition_async(G: nx.Graph, current_state: dict):\n    # Randomizing the update order prevents bias\n    nodes_to_update = list(G.nodes)\n    random.shuffle(nodes_to_update)\n    for node in nodes_to_update:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n    return current_state\n\nWe can make use of this new state transition function by passing it to the Simulation class, then run it and compare to the synchronous version above.\n\nsim = Simulation(G, initial_state, state_transition_async, name=\"Async Voter Model\")\nsim.run(40)\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAsynchronous updates may or may not produce a different result depending on the particular dynamics of your simulation. Synchronous updates are slightly simpler in terms of their assumptions which is an advantage, but certain update mechanisms can fail to converge to the steady state without asynchronous updates.\n\n\n\nIn some situations we may want to specify a condition which, when true, causes the simulation to end early. In this Voter model example, we observe that the system state can’t change once all of the nodes have the same state. In order to avoid running the simulation longer than necessary, we can specify a stop condition to stop the simulation if all nodes have the same state.\nThis function takes the graph and current state as arguments, same as the state transition function, and returns True if the model should stop.\n\ndef stop_condition(G: nx.Graph, current_state: dict):\n    unique_state_values = set(current_state.values())\n    is_stopped = len(unique_state_values) &lt;= 1\n    return is_stopped\n\nLet’s create another instance of the voter model, specifying a stop condition, and run it for more steps than we think we’ll need. We still need to specify a maximum number of steps in case there is a bug in our stop condition and it never returns True.\n\nsim = Simulation(G, initial_state, state_transition, stop_condition, name=\"Voter model\")\nsim.run(100)\n\nStop condition met at step 15.\n\n\n\nsim.steps\n\n15\n\n\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nSince we have access to the Graph instance in our transition function, we can add or remove links in the graph if our system calls for it. Let’s add an extension to the voter model such that a node may also “unfriend” another node by removing the edge between them if their state differs.\n\ndef state_transition_async_rewiring(G: nx.Graph, current_state: dict):\n    # Randomizing the update order prevents bias\n    nodes_to_update = list(G.nodes)\n    random.shuffle(nodes_to_update)\n    for node in nodes_to_update:\n        if G.degree(node) &gt; 0:\n            # This is the same as before\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n            # This is the new part\n            neighbor = random.choice(list(G.neighbors(node)))\n            if current_state[node] != current_state[neighbor]:\n                G.remove_edge(node, neighbor)\n\n    return current_state\n\n\nsim = Simulation(\n    G,\n    initial_state,\n    state_transition_async_rewiring,\n    stop_condition,\n    name=\"Voter Model with rewiring\",\n)\nsim.draw()\n\n\n\n\n\n\n\n\n\nsim.run(40)\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe long-term behavior of this modified simulation is different than the previous model: it often ends up in a configuration with disconnected components, each containg nodes all of the same state. As such, the stop conditon as written doesn’t trigger. Creating a proper stop_condition function for this state transition function is left as an exercise to the reader.\n\n\n\n\n\nThis is one of the fundamental models of spreading dynamics on networks, examined in detail in the text. We will implement this spreading model using our simulation framework.\n\n\n\n\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nWe will initially assign every node to the ‘S’ state and then randomly choose one node to infect by setting it to the ‘I’ state. You should experiment with different choices of the “patient zero” node to infect and see how it affects the spreading dynamics, e.g. by selecting a high- or low-degree node.\n\ndef initial_state(G: nx.Graph) -&gt; dict:\n    state = {}\n    for node in G.nodes:\n        state[node] = \"S\"\n\n    patient_zero = random.choice(list(G.nodes))\n    state[patient_zero] = \"I\"\n    return state\n\nLet’s make sure this works:\n\ninitial_state(G)\n\n{0: 'S',\n 1: 'S',\n 2: 'S',\n 3: 'S',\n 4: 'S',\n 5: 'S',\n 6: 'S',\n 7: 'S',\n 8: 'S',\n 9: 'S',\n 10: 'S',\n 11: 'S',\n 12: 'S',\n 13: 'S',\n 14: 'S',\n 15: 'S',\n 16: 'S',\n 17: 'S',\n 18: 'S',\n 19: 'I'}\n\n\n\n\n\nThe SIS model involves two parameters, \\(\\beta\\) is the probability to transition from S to I given an infected neighbor, and \\(\\mu\\), the probability of transitioning from I to S.\nIn pseudocode, the algorithm looks like this:\n\nFor each node in the graph\n\nIf node has state I\n\nThe node transitions to state S with probability \\(\\mu\\)\n\nElse node has state S\n\nFor each neighbor of the node\n\nIf neighbor has state I\n\nThe node transitions to state I with probability \\(\\beta\\)\n\n\n\n\n\nThe logic gets a little deep with the indentations, but the code looks very much like this pseudocode.\n\ndef state_transition(\n    G: nx.Graph, current_state: dict, mu: float = 0.1, beta: float = 0.1\n) -&gt; dict:\n    next_state = {}\n    for node in G.nodes:\n        if current_state[node] == \"I\":\n            if random.random() &lt; mu:\n                next_state[node] = \"S\"\n        else:  # current_state[node] == 'S'\n            for neighbor in G.neighbors(node):\n                if current_state[neighbor] == \"I\":\n                    if random.random() &lt; beta:\n                        next_state[node] = \"I\"\n\n    return next_state\n\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{}\n\n\nIt’s possible, depending on your parameter values, that the first transition results in no state changes. This is okay, even expected. It might take a few tries before any states are updated and a nonempty dict is produced. It’s also okay to skip this, as we’re just checking our code accuracy, but it is easier to debug here than in the simulation proper.\n\n\n\nNow let’s create the simulation and visualize the initial state:\n\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\nsim.run(25)\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIt’s probably different from where we started; let’s see how we got here:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGo ahead and execute the previous few cells again, running the simulation forward and examining the state, until it reaches the long-term steady state: eventually the proportion curves will flatten out as the proportion of each node state will fluctuate around some average value.\nNow go back, adjust the BETA and MU parameter values, and see how the steady state changes!"
  },
  {
    "objectID": "references/networkx_indiana/6-networkx-simulation.html#the-simulation-class",
    "href": "references/networkx_indiana/6-networkx-simulation.html#the-simulation-class",
    "title": "NetworkX - Simulation",
    "section": "",
    "text": "Included with these tutorials is a simulation.py file that contains a Simulation class. This class will allow us to skip the details of writing a simulation, allowing us to concentrate on the interesting parts.\n\n\nA simulation is made up of three main parts:\n\nThe graph on which to simulate node dynamics\nThe initial state of each node\nThe state transition function\n\n\n\nThis one is easy, we just need a NetworkX Graph instance. For this example we’ll use a random graph. You can run the following cell multiple times if you wish, until you get a graph that looks good:\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIn these simulations, state is represented as a dictionary where the keys are node names and the values are the state of the node. We can specify the initial state either directly as one of these dictionaries, or we can specify a function that generates such a state dictionary.\nThe function version is cleaner; let’s use it to generate a very simple initial state where every node has the same state: ‘asleep’.\n\n# An initial_state function takes one argument, the graph instance.\ndef initial_state(G: nx.Graph) -&gt; dict:\n    state = {}\n    for node in G.nodes:\n        state[node] = \"asleep\"\n    return state\n\n\n# We can test this function out to make sure it works on our graph and produces a dictionary with a state value for each node:\ninitial_state(G)\n\n{0: 'asleep',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'asleep',\n 4: 'asleep',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'asleep',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'asleep',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'asleep',\n 18: 'asleep',\n 19: 'asleep'}\n\n\n\n\n\nThe crux of the simulation is the state transition function: this is where we specify the dynamics. This function takes two arguments, the graph and the current node states provided as a dictionary, and should return a dictionary of the updated states.\nIn this simple example, at each simulation step, each node with the 'asleep' state will have a fixed probability to transition to the 'awake' state. We’ll specify this probability as p_awaken, the probability an asleep node will awaken at each step.\nGenerically, in order to do a thing with some probability, we generate a random number between 0 and 1 with the random.random() function and compare to our probability threshold: if the random number is below our probability threshold, then we do the thing.\n\ndef state_transition(G: nx.graph, current_state, p_awaken: float = 0.2):\n    next_state = {}\n    for node in G.nodes:\n        if current_state[node] == \"asleep\":\n            if random.random() &lt; p_awaken:\n                next_state[node] = \"awake\"\n    return next_state\n\nNote that this function only has to provide the states that change during this step, although no harm would be done by specifying the state for every node, changed or not.\nWe can do a dry run if we want, just to make sure our transition function works:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{0: 'awake', 2: 'awake', 9: 'awake', 18: 'awake'}\n\n\nWe should see some nodes transition to the 'awake' state in this test run, which is good.\n\n\n\nWe now have our three pieces: the graph, the initial state, and the state transition function. Let’s put them together along with a name for our simulation to create a Simulation object:\n\nsim = Simulation(G, initial_state, state_transition, name=\"Simple Sim\")\n\nThe name provided here is optional, it just for us to keep track of the images we’ll generate later.\nThis Simulation object has several useful methods. The first of these is the .state() method, which returns a dictionary for the current state of the simulation:\n\nsim.state()\n\n{0: 'asleep',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'asleep',\n 4: 'asleep',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'asleep',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'asleep',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'asleep',\n 18: 'asleep',\n 19: 'asleep'}\n\n\nWe haven’t done any steps in the simulation yet, so the state should be exactly our initial condition.\nWe can also draw the network with its nodes colored by their state values with the .draw() method:\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nOur initial condition has all nodes 'asleep', so this checks out.\n\n\n\n\nWith our initial condition checked out, let’s run the simulation! The simulation will advance in discrete steps: each step is one run of the state transition function.\nThe .run() method without any arguments will run the simulation one step:\n\nsim.run()\n\nWe can confirm the simulation advanced a step by checking out the .steps property, which tells us how many times the state transition function has been run:\n\nsim.steps\n\n1\n\n\nLet’s see what our graph looks like after one step, noting that we can include keyword arguments for the nx.draw() function:\n\nsim.draw(with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nSome of the nodes are awake! We can also see this in the simulation state:\n\nsim.state()\n\n{0: 'awake',\n 1: 'asleep',\n 2: 'asleep',\n 3: 'awake',\n 4: 'awake',\n 5: 'asleep',\n 6: 'asleep',\n 7: 'asleep',\n 8: 'awake',\n 9: 'asleep',\n 10: 'asleep',\n 11: 'asleep',\n 12: 'asleep',\n 13: 'asleep',\n 14: 'awake',\n 15: 'asleep',\n 16: 'asleep',\n 17: 'awake',\n 18: 'awake',\n 19: 'asleep'}\n\n\nIf we give the .run() method a number, we can run the simulation several steps at once:\n\nsim.run(10)\n\n\nsim.steps\n\n11\n\n\nThe .steps method confirms that our simulation went through several simulation steps. Let’s check up on the current state:\n\nsim.draw(with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nBy this point, all or most of the nodes should be awake, but how did that transition occur? Was it gradual or all at once? With the .plot() method, we can plot the proportion of nodes in each state at each step of the simulation:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIf we want to visualize the state of the graph at a specific step, we can specify the desired step in the .draw() function.\n\nsim.draw(4, with_labels=True)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe same is true for the .state() method:\n\nsim.state(4)\n\n{0: 'awake',\n 1: 'awake',\n 2: 'awake',\n 3: 'awake',\n 4: 'awake',\n 5: 'asleep',\n 6: 'awake',\n 7: 'asleep',\n 8: 'awake',\n 9: 'asleep',\n 10: 'awake',\n 11: 'awake',\n 12: 'awake',\n 13: 'asleep',\n 14: 'awake',\n 15: 'awake',\n 16: 'awake',\n 17: 'awake',\n 18: 'awake',\n 19: 'awake'}\n\n\nIf we only want to plot a subset of the steps, we can do that too by passing the min and/or max steps we want to plot. Do note that the bounds passed to the .plot() method are half-open, like Python’s range() function and list slices, so that .plot(2, 8) plots states from 2 and up to but not including 8.\n\nsim.plot(min_step=2, max_step=8)\nplt.show()\nplt.close()"
  },
  {
    "objectID": "references/networkx_indiana/6-networkx-simulation.html#the-voter-model",
    "href": "references/networkx_indiana/6-networkx-simulation.html#the-voter-model",
    "title": "NetworkX - Simulation",
    "section": "",
    "text": "In our trivial awake/asleep model above we ignored the underlying graph structure and each node’s dynamics was independent of its neighbors. In interesting network models, we make use of the graph connectivity in some way.\nThe voter model is a simple model of network opinion dynamics capable of producing interesting output. This model is described in detail in the textbook; we’re going to implement it here.\n\n\n\n\nWe’re going to use another random graph here, same as before.\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nFor the initial state, we will randomly assign each node a state by randomly selecting a letter A to D – we’re not limited to two states here!\nWe’ll make use of random.choice() in both the initial state and state transition functions. This function is used to randomly choose one item from a given collection.\n\ndef initial_state(G):\n    state = {}\n    for node in G.nodes:\n        state[node] = random.choice(\"ABCD\")\n    return state\n\nLet’s make sure this works:\n\ninitial_state(G)\n\n{0: 'D',\n 1: 'B',\n 2: 'C',\n 3: 'A',\n 4: 'D',\n 5: 'D',\n 6: 'A',\n 7: 'D',\n 8: 'A',\n 9: 'A',\n 10: 'D',\n 11: 'B',\n 12: 'B',\n 13: 'C',\n 14: 'B',\n 15: 'C',\n 16: 'C',\n 17: 'D',\n 18: 'C',\n 19: 'A'}\n\n\n\n\n\nThe algorithm at the heart of the voter model works like this: for each node in the graph, choose a neighbor at random and copy their “opinion”, i.e. set this node’s state to the same value as that of the neighbor.\n\nFor each node in the graph\n\nChoose a neighbor at random\nSet this node state equal to the neighbor state\n\n\n\ndef state_transition(G: nx.Graph, current_state: dict):\n    next_state = {}\n    for node in G.nodes:\n        # Caveat: what if the node has no neighbors?\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            next_state[node] = current_state[neighbor]\n    return next_state\n\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{0: 'C',\n 1: 'A',\n 2: 'A',\n 3: 'C',\n 4: 'A',\n 5: 'C',\n 6: 'A',\n 7: 'A',\n 8: 'D',\n 9: 'B',\n 10: 'D',\n 11: 'C',\n 12: 'C',\n 13: 'B',\n 14: 'A',\n 15: 'C',\n 16: 'C',\n 17: 'C',\n 18: 'C',\n 19: 'A'}\n\n\n\n\n\nLooks good. Now let’s create the simulation and visualize the initial state:\n\nsim = Simulation(G, initial_state, state_transition, name=\"Voter Model\")\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n# if you care about the order of the labels in the legend,\n# you can specify labels='ABCD' as a keyword argument for .draw()\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\nsim.run(40)\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIt’s probably different from where we started; let’s see how we got here:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGo ahead and execute the previous few cells again, running the simulation forward and examining the state, until it reaches the long-term steady state: all of the nodes should eventually end up with the same state.\n\n\n\nAs written, this state_transition function performs a synchronous update, i.e. all of the nodes’ states are updated at the same time, after the function returns the new state:\n\n# This is the same as in 2.1.3\ndef state_transition(G: nx.Graph, current_state: dict):\n    next_state = {}\n    for node in G.nodes:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            next_state[node] = current_state[neighbor]\n    return next_state\n\nNote how this function never changes the values of current_state so that each node’s update is based on the same information. Since each node “sees” the same state, the order in which we update the nodes doesn’t matter. This is equivalent to updating all of the node states simultaneously.\nOne can instead perform an asynchronous update, where each node sees the state changes that have taken place this step, by making in-place changes to current_state:\n\n# This example is potentially biased, don't use it\ndef state_transition_async(G: nx.Graph, current_state: dict):\n    for node in G.nodes:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n    return current_state\n\nIn this example, each node’s view of current_state reflects the changes made in this step by previous node updates.\nThere is a potential problem here, however: G.nodes is likely to always return the nodes in the same order, thus performing the updates in the same order and potentially introducing bias. We should instead loop over the nodes in a random order each time:\n\ndef state_transition_async(G: nx.Graph, current_state: dict):\n    # Randomizing the update order prevents bias\n    nodes_to_update = list(G.nodes)\n    random.shuffle(nodes_to_update)\n    for node in nodes_to_update:\n        if G.degree(node) &gt; 0:\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n    return current_state\n\nWe can make use of this new state transition function by passing it to the Simulation class, then run it and compare to the synchronous version above.\n\nsim = Simulation(G, initial_state, state_transition_async, name=\"Async Voter Model\")\nsim.run(40)\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAsynchronous updates may or may not produce a different result depending on the particular dynamics of your simulation. Synchronous updates are slightly simpler in terms of their assumptions which is an advantage, but certain update mechanisms can fail to converge to the steady state without asynchronous updates.\n\n\n\nIn some situations we may want to specify a condition which, when true, causes the simulation to end early. In this Voter model example, we observe that the system state can’t change once all of the nodes have the same state. In order to avoid running the simulation longer than necessary, we can specify a stop condition to stop the simulation if all nodes have the same state.\nThis function takes the graph and current state as arguments, same as the state transition function, and returns True if the model should stop.\n\ndef stop_condition(G: nx.Graph, current_state: dict):\n    unique_state_values = set(current_state.values())\n    is_stopped = len(unique_state_values) &lt;= 1\n    return is_stopped\n\nLet’s create another instance of the voter model, specifying a stop condition, and run it for more steps than we think we’ll need. We still need to specify a maximum number of steps in case there is a bug in our stop condition and it never returns True.\n\nsim = Simulation(G, initial_state, state_transition, stop_condition, name=\"Voter model\")\nsim.run(100)\n\nStop condition met at step 15.\n\n\n\nsim.steps\n\n15\n\n\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nSince we have access to the Graph instance in our transition function, we can add or remove links in the graph if our system calls for it. Let’s add an extension to the voter model such that a node may also “unfriend” another node by removing the edge between them if their state differs.\n\ndef state_transition_async_rewiring(G: nx.Graph, current_state: dict):\n    # Randomizing the update order prevents bias\n    nodes_to_update = list(G.nodes)\n    random.shuffle(nodes_to_update)\n    for node in nodes_to_update:\n        if G.degree(node) &gt; 0:\n            # This is the same as before\n            neighbor = random.choice(list(G.neighbors(node)))\n            current_state[node] = current_state[neighbor]\n            # This is the new part\n            neighbor = random.choice(list(G.neighbors(node)))\n            if current_state[node] != current_state[neighbor]:\n                G.remove_edge(node, neighbor)\n\n    return current_state\n\n\nsim = Simulation(\n    G,\n    initial_state,\n    state_transition_async_rewiring,\n    stop_condition,\n    name=\"Voter Model with rewiring\",\n)\nsim.draw()\n\n\n\n\n\n\n\n\n\nsim.run(40)\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe long-term behavior of this modified simulation is different than the previous model: it often ends up in a configuration with disconnected components, each containg nodes all of the same state. As such, the stop conditon as written doesn’t trigger. Creating a proper stop_condition function for this state transition function is left as an exercise to the reader."
  },
  {
    "objectID": "references/networkx_indiana/6-networkx-simulation.html#the-sis-model",
    "href": "references/networkx_indiana/6-networkx-simulation.html#the-sis-model",
    "title": "NetworkX - Simulation",
    "section": "",
    "text": "This is one of the fundamental models of spreading dynamics on networks, examined in detail in the text. We will implement this spreading model using our simulation framework.\n\n\n\n\n\nG = nx.gnm_random_graph(20, 50)\nnx.draw(G)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nWe will initially assign every node to the ‘S’ state and then randomly choose one node to infect by setting it to the ‘I’ state. You should experiment with different choices of the “patient zero” node to infect and see how it affects the spreading dynamics, e.g. by selecting a high- or low-degree node.\n\ndef initial_state(G: nx.Graph) -&gt; dict:\n    state = {}\n    for node in G.nodes:\n        state[node] = \"S\"\n\n    patient_zero = random.choice(list(G.nodes))\n    state[patient_zero] = \"I\"\n    return state\n\nLet’s make sure this works:\n\ninitial_state(G)\n\n{0: 'S',\n 1: 'S',\n 2: 'S',\n 3: 'S',\n 4: 'S',\n 5: 'S',\n 6: 'S',\n 7: 'S',\n 8: 'S',\n 9: 'S',\n 10: 'S',\n 11: 'S',\n 12: 'S',\n 13: 'S',\n 14: 'S',\n 15: 'S',\n 16: 'S',\n 17: 'S',\n 18: 'S',\n 19: 'I'}\n\n\n\n\n\nThe SIS model involves two parameters, \\(\\beta\\) is the probability to transition from S to I given an infected neighbor, and \\(\\mu\\), the probability of transitioning from I to S.\nIn pseudocode, the algorithm looks like this:\n\nFor each node in the graph\n\nIf node has state I\n\nThe node transitions to state S with probability \\(\\mu\\)\n\nElse node has state S\n\nFor each neighbor of the node\n\nIf neighbor has state I\n\nThe node transitions to state I with probability \\(\\beta\\)\n\n\n\n\n\nThe logic gets a little deep with the indentations, but the code looks very much like this pseudocode.\n\ndef state_transition(\n    G: nx.Graph, current_state: dict, mu: float = 0.1, beta: float = 0.1\n) -&gt; dict:\n    next_state = {}\n    for node in G.nodes:\n        if current_state[node] == \"I\":\n            if random.random() &lt; mu:\n                next_state[node] = \"S\"\n        else:  # current_state[node] == 'S'\n            for neighbor in G.neighbors(node):\n                if current_state[neighbor] == \"I\":\n                    if random.random() &lt; beta:\n                        next_state[node] = \"I\"\n\n    return next_state\n\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{}\n\n\nIt’s possible, depending on your parameter values, that the first transition results in no state changes. This is okay, even expected. It might take a few tries before any states are updated and a nonempty dict is produced. It’s also okay to skip this, as we’re just checking our code accuracy, but it is easier to debug here than in the simulation proper.\n\n\n\nNow let’s create the simulation and visualize the initial state:\n\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\nsim.run(25)\n\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIt’s probably different from where we started; let’s see how we got here:\n\nsim.plot()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGo ahead and execute the previous few cells again, running the simulation forward and examining the state, until it reaches the long-term steady state: eventually the proportion curves will flatten out as the proportion of each node state will fluctuate around some average value.\nNow go back, adjust the BETA and MU parameter values, and see how the steady state changes!"
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nYou can use NetworkX to construct and draw graphs that are undirected or directed, with weighted or unweighted edges. An array of functions to analyze graphs is available. This tutorial takes you through a few basic examples and exercises.\nNote that many exercises are followed by a block with some assert statements. These assertions may be preceded by some setup code. They are provided to give you feedback that you are on the right path – receiving an AssertionError probably means you’ve done something wrong.\nContents:\n\nCreating and drawing undirected graphs\nGraph methods\nNode names\nAdjacency lists\nDirected graphs\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\n\n# a \"plain\" graph is undirected\nG = nx.Graph()\n\n# give each a node a 'name', which is a letter in this case.\nG.add_node(\"a\")\n\n# the add_nodes_from method allows adding nodes from a sequence, in this case a list\nnodes_to_add = [\"b\", \"c\", \"d\"]\nG.add_nodes_from(nodes_to_add)\n\n# add edge from 'a' to 'b'\n# since this graph is undirected, the order doesn't matter here\nG.add_edge(\"a\", \"b\")\n\n# just like add_nodes_from, we can add edges from a sequence\n# edges should be specified as 2-tuples\nedges_to_add = [(\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\")]\nG.add_edges_from(edges_to_add)\n\n# draw the graph\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nThere are many optional arguments to the draw function to customize the appearance.\n\nnx.draw(\n    G,\n    with_labels=True,\n    node_color=\"blue\",\n    node_size=1600,\n    font_color=\"white\",\n    font_size=16,\n)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nUsually in Python, variables are named in snake_case, i.e. lowercase with underscores separating words. Classes are conventionally named in CamelCase, i.e. with the first letter of each word capitalized.\nObviously NetworkX doesn’t use this convention, often using single capital letters for the names of graphs. This is an example of convention leaking from the world of discrete mathematics. Since most of the documentation you will find online uses this convention, we will follow it as well.\n\n\n\n\n\nThe graph object has some properties and methods giving data about the whole graph.\n\n# List all of the nodes\nG.nodes()\n\nNodeView(('a', 'b', 'c', 'd'))\n\n\n\n# List all of the edges\nG.edges()\n\nEdgeView([('a', 'b'), ('a', 'c'), ('b', 'c'), ('c', 'd')])\n\n\nNote that the edges are given as 2-tuples, the same way we entered them.\nWe can get the number of nodes and edges in a graph using the number_of_ methods.\n\nG.number_of_nodes()\n\n4\n\n\n\nG.number_of_edges()\n\n4\n\n\nSome graph methods take an edge or node as argument. These provide the graph properties of the given edge or node. For example, the .neighbors() method gives the nodes linked to the given node:\n\n# list of neighbors of node 'b'\nlist(G.neighbors(\"b\"))  # neighbors() returns an iterator\n\n['a', 'c']\n\n\n\n\nThe previous data are available via graph methods, i.e. they are called from the graph object:\nG.&lt;method_name&gt;(&lt;arguments&gt;)\nWhile several of the most-used NetworkX functions are provided as methods, many more of them are module functions and are called like this:\nnx.&lt;function_name&gt;(G, &lt;arguments&gt;)\nthat is, with the graph provided as the first, and maybe only, argument. Here are a couple of examples of NetworkX module functions that provide information about a graph:\n\nnx.is_tree(G)\n\nFalse\n\n\n\nnx.is_connected(G)\n\nTrue\n\n\n\n\n\nTo check if a node is present in a graph, you can use the has_node() method:\n\nG.has_node(\"a\")\n\nTrue\n\n\n\nG.has_node(\"x\")\n\nFalse\n\n\nLikewise we can check if two nodes are connected by an edge:\n\nG.has_edge(\"a\", \"b\")\n\nTrue\n\n\n\nG.has_edge(\"a\", \"d\")\n\nFalse\n\n\n\n\n\nOne of the most important questions we can ask about a node in a graph is how many other nodes it connects to.\n\nG.degree(\"a\")\n\n2\n\n\n\n\n\nOften in the context of trees, a node with degree 1 is called a leaf. Write a function named get_leaves that takes a graph as an argument, loops through the nodes, and returns a list of nodes with degree 1.\n\ndef get_leaves(G: nx.Graph):\n\nSyntaxError: incomplete input (2301721220.py, line 1)\n\n\n\nG = nx.Graph()\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"a\", \"d\"),\n        (\"c\", \"d\"),\n    ]\n)\nassert set(get_leaves(G)) == {\"c\", \"b\"}\n\nNameError: name 'get_leaves' is not defined\n\n\n\n\n\n\n\nThe node names don’t have to be single characters – they can be strings or integers or any immutable object, and the types can be mixed. The example below uses strings and integers for names.\n\nG = nx.Graph()\n\nG.add_nodes_from([\"cat\", \"dog\", \"virus\", 13])\n\nG.add_edge(\"cat\", \"dog\")\n\nnx.draw(G, with_labels=True, font_color=\"white\", node_size=1000)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOne compact way to represent a graph is an adjacency list. This is most useful for unweighted graphs, directed or undirected. In an adjacency list, each line contains some number of node names. The first node name is the “source” and each other node name on the line is a “target”. For instance, given the following adjacency list:\na d e\nb c\nc\nd\ne\nthe edges are as follows:\n(a, d)\n(a, e)\n(b, c)\nThe nodes on their own line exist so that we are sure to include any singleton nodes. Note that if our graph is undirected, we only need to specify one direction for each edge. Importantly, whether the graph is directed or undirected is often not contained in the file itself – you have to infer it. This is one limitation of the format.\nIn the data directory, there is a file called friends.adjlist. NetworkX provides a way to read a graph from an adjacency list: nx.read_adjlist(). We will name this graph SG, for social graph.\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\n\nWe know how to draw this graph:\n\nnx.draw(SG, node_size=2000, node_color=\"lightblue\", with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nAnd we know how to get information such as the number of friends linked from a node:\n\nSG.degree(\"Alice\")\n\n3\n\n\n\n\nWrite a function max_degree that takes a graph as its argument, and returns a 2-tuple with the name and degree of the node with highest degree.\n\ndef max_degree(G):\n    \n\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\nassert max_degree(SG) == (\"Claire\", 4)\n\n\n\n\nWrite a function mutual_friends that takes a graph and two nodes as arguments, and returns a list (or set) of nodes that are linked to both given nodes. For example, in the graph SG drawn above,\nmutual_friends(SG, 'Alice', 'Claire') == ['Frank']\nan empty list or set should be returned in the case where two nodes have no mutual friends, e.g. George and Bob in SG drawn above.\n\ndef mutual_friends(G, node_1, node_2):\n\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\nassert mutual_friends(SG, \"Alice\", \"Claire\") == [\"Frank\"]\nassert mutual_friends(SG, \"George\", \"Bob\") == []\nassert sorted(mutual_friends(SG, \"Claire\", \"George\")) == [\"Dennis\", \"Frank\"]\n\n\n\n\n\n\nUnless otherwise specified, we assume graph edges are undirected – they are symmetric and go both ways. But some relationships, e.g. predator-prey relationships, are asymmetric and best represented as directed graphs. NetworkX provides the DiGraph class for directed graphs.\n\nD = nx.DiGraph()\n\nD.add_edges_from(\n    [(1, 2), (2, 3), (3, 2), (3, 4), (3, 5), (4, 5), (4, 6), (5, 6), (6, 4), (4, 2)]\n)\n\nnx.draw(D, with_labels=True)\nplt.show()\n\nNote the asymmetry in graph methods dealing with edges such as has_edge():\n\nD.has_edge(1, 2)\n\nTrue\n\n\n\nD.has_edge(2, 1)\n\nFalse\n\n\nInstead of the symmetric relationship “neighbors”, nodes in directed graphs have predecessors (“in-neighbors”) and successors (“out-neighbors”):\n\nprint(\"Successors of 2:\", list(D.successors(2)))\n\nprint(\"Predecessors of 2:\", list(D.predecessors(2)))\n\nSuccessors of 2: [3]\nPredecessors of 2: [1, 3, 4]\n\n\nDirected graphs have in-degree and out-degree, giving the number of edges pointing to and from the given node, respectively:\n\nD.in_degree(2)\n\n3\n\n\n\nD.out_degree(2)\n\n1\n\n\n\n\nSince NetworkX 2, the .degree() method on a directed graph gives the total degree: in-degree plus out-degree. However, in a bit of confusing nomenclature, the neighbors method is a synonym for successors, giving only the edges originating from the given node. This makes sense if you consider neighbors to be all the nodes reachable from the given node by following links, but it’s easy to make the mistake of writing .neighbors() in your code when you really want both predecessors and successors.\n\nD.degree(2)\n\n4\n\n\n\nprint(\"Successors of 2:\", list(D.successors(2)))\nprint('\"Neighbors\" of 2:', list(D.neighbors(2)))\n\nSuccessors of 2: [3]\n\"Neighbors\" of 2: [3]"
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html#creating-and-drawing-undirected-graphs",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html#creating-and-drawing-undirected-graphs",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "# a \"plain\" graph is undirected\nG = nx.Graph()\n\n# give each a node a 'name', which is a letter in this case.\nG.add_node(\"a\")\n\n# the add_nodes_from method allows adding nodes from a sequence, in this case a list\nnodes_to_add = [\"b\", \"c\", \"d\"]\nG.add_nodes_from(nodes_to_add)\n\n# add edge from 'a' to 'b'\n# since this graph is undirected, the order doesn't matter here\nG.add_edge(\"a\", \"b\")\n\n# just like add_nodes_from, we can add edges from a sequence\n# edges should be specified as 2-tuples\nedges_to_add = [(\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\")]\nG.add_edges_from(edges_to_add)\n\n# draw the graph\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nThere are many optional arguments to the draw function to customize the appearance.\n\nnx.draw(\n    G,\n    with_labels=True,\n    node_color=\"blue\",\n    node_size=1600,\n    font_color=\"white\",\n    font_size=16,\n)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nUsually in Python, variables are named in snake_case, i.e. lowercase with underscores separating words. Classes are conventionally named in CamelCase, i.e. with the first letter of each word capitalized.\nObviously NetworkX doesn’t use this convention, often using single capital letters for the names of graphs. This is an example of convention leaking from the world of discrete mathematics. Since most of the documentation you will find online uses this convention, we will follow it as well."
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html#graph-methods",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html#graph-methods",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "The graph object has some properties and methods giving data about the whole graph.\n\n# List all of the nodes\nG.nodes()\n\nNodeView(('a', 'b', 'c', 'd'))\n\n\n\n# List all of the edges\nG.edges()\n\nEdgeView([('a', 'b'), ('a', 'c'), ('b', 'c'), ('c', 'd')])\n\n\nNote that the edges are given as 2-tuples, the same way we entered them.\nWe can get the number of nodes and edges in a graph using the number_of_ methods.\n\nG.number_of_nodes()\n\n4\n\n\n\nG.number_of_edges()\n\n4\n\n\nSome graph methods take an edge or node as argument. These provide the graph properties of the given edge or node. For example, the .neighbors() method gives the nodes linked to the given node:\n\n# list of neighbors of node 'b'\nlist(G.neighbors(\"b\"))  # neighbors() returns an iterator\n\n['a', 'c']\n\n\n\n\nThe previous data are available via graph methods, i.e. they are called from the graph object:\nG.&lt;method_name&gt;(&lt;arguments&gt;)\nWhile several of the most-used NetworkX functions are provided as methods, many more of them are module functions and are called like this:\nnx.&lt;function_name&gt;(G, &lt;arguments&gt;)\nthat is, with the graph provided as the first, and maybe only, argument. Here are a couple of examples of NetworkX module functions that provide information about a graph:\n\nnx.is_tree(G)\n\nFalse\n\n\n\nnx.is_connected(G)\n\nTrue\n\n\n\n\n\nTo check if a node is present in a graph, you can use the has_node() method:\n\nG.has_node(\"a\")\n\nTrue\n\n\n\nG.has_node(\"x\")\n\nFalse\n\n\nLikewise we can check if two nodes are connected by an edge:\n\nG.has_edge(\"a\", \"b\")\n\nTrue\n\n\n\nG.has_edge(\"a\", \"d\")\n\nFalse\n\n\n\n\n\nOne of the most important questions we can ask about a node in a graph is how many other nodes it connects to.\n\nG.degree(\"a\")\n\n2\n\n\n\n\n\nOften in the context of trees, a node with degree 1 is called a leaf. Write a function named get_leaves that takes a graph as an argument, loops through the nodes, and returns a list of nodes with degree 1.\n\ndef get_leaves(G: nx.Graph):\n\nSyntaxError: incomplete input (2301721220.py, line 1)\n\n\n\nG = nx.Graph()\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"a\", \"d\"),\n        (\"c\", \"d\"),\n    ]\n)\nassert set(get_leaves(G)) == {\"c\", \"b\"}\n\nNameError: name 'get_leaves' is not defined"
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html#node-names",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html#node-names",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "The node names don’t have to be single characters – they can be strings or integers or any immutable object, and the types can be mixed. The example below uses strings and integers for names.\n\nG = nx.Graph()\n\nG.add_nodes_from([\"cat\", \"dog\", \"virus\", 13])\n\nG.add_edge(\"cat\", \"dog\")\n\nnx.draw(G, with_labels=True, font_color=\"white\", node_size=1000)\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html#adjacency-lists",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html#adjacency-lists",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "One compact way to represent a graph is an adjacency list. This is most useful for unweighted graphs, directed or undirected. In an adjacency list, each line contains some number of node names. The first node name is the “source” and each other node name on the line is a “target”. For instance, given the following adjacency list:\na d e\nb c\nc\nd\ne\nthe edges are as follows:\n(a, d)\n(a, e)\n(b, c)\nThe nodes on their own line exist so that we are sure to include any singleton nodes. Note that if our graph is undirected, we only need to specify one direction for each edge. Importantly, whether the graph is directed or undirected is often not contained in the file itself – you have to infer it. This is one limitation of the format.\nIn the data directory, there is a file called friends.adjlist. NetworkX provides a way to read a graph from an adjacency list: nx.read_adjlist(). We will name this graph SG, for social graph.\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\n\nWe know how to draw this graph:\n\nnx.draw(SG, node_size=2000, node_color=\"lightblue\", with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nAnd we know how to get information such as the number of friends linked from a node:\n\nSG.degree(\"Alice\")\n\n3\n\n\n\n\nWrite a function max_degree that takes a graph as its argument, and returns a 2-tuple with the name and degree of the node with highest degree.\n\ndef max_degree(G):\n    \n\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\nassert max_degree(SG) == (\"Claire\", 4)\n\n\n\n\nWrite a function mutual_friends that takes a graph and two nodes as arguments, and returns a list (or set) of nodes that are linked to both given nodes. For example, in the graph SG drawn above,\nmutual_friends(SG, 'Alice', 'Claire') == ['Frank']\nan empty list or set should be returned in the case where two nodes have no mutual friends, e.g. George and Bob in SG drawn above.\n\ndef mutual_friends(G, node_1, node_2):\n\n\nSG = nx.read_adjlist(\"../../data/friends.adjlist\")\nassert mutual_friends(SG, \"Alice\", \"Claire\") == [\"Frank\"]\nassert mutual_friends(SG, \"George\", \"Bob\") == []\nassert sorted(mutual_friends(SG, \"Claire\", \"George\")) == [\"Dennis\", \"Frank\"]"
  },
  {
    "objectID": "references/networkx_indiana/1-networkx-fundamentals.html#directed-graphs",
    "href": "references/networkx_indiana/1-networkx-fundamentals.html#directed-graphs",
    "title": "NetworkX - Fundamentals",
    "section": "",
    "text": "Unless otherwise specified, we assume graph edges are undirected – they are symmetric and go both ways. But some relationships, e.g. predator-prey relationships, are asymmetric and best represented as directed graphs. NetworkX provides the DiGraph class for directed graphs.\n\nD = nx.DiGraph()\n\nD.add_edges_from(\n    [(1, 2), (2, 3), (3, 2), (3, 4), (3, 5), (4, 5), (4, 6), (5, 6), (6, 4), (4, 2)]\n)\n\nnx.draw(D, with_labels=True)\nplt.show()\n\nNote the asymmetry in graph methods dealing with edges such as has_edge():\n\nD.has_edge(1, 2)\n\nTrue\n\n\n\nD.has_edge(2, 1)\n\nFalse\n\n\nInstead of the symmetric relationship “neighbors”, nodes in directed graphs have predecessors (“in-neighbors”) and successors (“out-neighbors”):\n\nprint(\"Successors of 2:\", list(D.successors(2)))\n\nprint(\"Predecessors of 2:\", list(D.predecessors(2)))\n\nSuccessors of 2: [3]\nPredecessors of 2: [1, 3, 4]\n\n\nDirected graphs have in-degree and out-degree, giving the number of edges pointing to and from the given node, respectively:\n\nD.in_degree(2)\n\n3\n\n\n\nD.out_degree(2)\n\n1\n\n\n\n\nSince NetworkX 2, the .degree() method on a directed graph gives the total degree: in-degree plus out-degree. However, in a bit of confusing nomenclature, the neighbors method is a synonym for successors, giving only the edges originating from the given node. This makes sense if you consider neighbors to be all the nodes reachable from the given node by following links, but it’s easy to make the mistake of writing .neighbors() in your code when you really want both predecessors and successors.\n\nD.degree(2)\n\n4\n\n\n\nprint(\"Successors of 2:\", list(D.successors(2)))\nprint('\"Neighbors\" of 2:', list(D.neighbors(2)))\n\nSuccessors of 2: [3]\n\"Neighbors\" of 2: [3]"
  },
  {
    "objectID": "references/networkx_indiana/2-networkx-paths.html",
    "href": "references/networkx_indiana/2-networkx-paths.html",
    "title": "NetworkX - Paths",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nNote that many exercises are followed by a block with some assert statements. These assertions may be preceded by some setup code. They are provided to give you feedback that you are on the right path – receiving an AssertionError probably means you’ve done something wrong.\nContents:\n\nPaths\nConnected components\nDirected paths & components\nDataset: US air traffic network\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\nLet’s start with a very simple, undirected network.\n\nG = nx.Graph()\n\nG.add_nodes_from([1, 2, 3, 4])\n\nG.add_edges_from([(1, 2), (2, 3), (1, 3), (1, 4)])\n\nnx.draw(G, with_labels=True)\nplt.show()\n\nA path in a network is a sequence of edges connecting two nodes. In this simple example, we can easily see that there is indeed at least one path that connects nodes 3 and 4. We can verify this with NetworkX:\n\nnx.has_path(G, 3, 4)\n\nThere can be more than one path between two nodes. Again considering nodes 3 and 4, there are two such “simple” paths:\n\nlist(nx.all_simple_paths(G, 3, 4))\n\nA simple path is one without any cycles. If we allowed cycles, there would be infinitely many paths because one could always just go around the cycle as many times as desired.\nWe are often most interested in shortest paths. In an unweighted network, the shortest path is the one with the fewest edges. We can see that of the two simple paths between nodes 3 and 4, one is shorter than the other. We can get this shortest path with a single NetworkX function:\n\nnx.shortest_path(G, 3, 4)\n\nIf you only care about the path length, there’s a function for that too:\n\nnx.shortest_path_length(G, 3, 4)\n\nNote that a path length is defined here by the number of edges in the path, not the number of nodes, which implies\nnx.shortest_path_length(G, u, v) == len(nx.shortest_path(G, u, v)) - 1\nfor nodes \\(u\\) and \\(v\\).\n\n\n\n\nIn the simple network above, we can see that for every pair of nodes, we can find a path connecting them. This is the definition of a connected graph. We can check this property for a given graph:\n\nnx.is_connected(G)\n\nNot every graph is connected:\n\nG = nx.Graph()\n\nnx.add_cycle(G, (1, 2, 3))\nG.add_edge(4, 5)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\nnx.is_connected(G)\n\nAnd NetworkX will raise an error if you ask for a path between nodes where none exists:\n\nnx.has_path(G, 3, 5)\n\n\nnx.shortest_path(G, 3, 5)\n\nVisually, we can identify two connected components in our graph. Let’s verify this:\n\nnx.number_connected_components(G)\n\nThe nx.connected_components() function takes a graph and returns a list of sets of node names, one such set for each connected component. Verify that the two sets in the following list correspond to the two connected components in the drawing of the graph above:\n\nlist(nx.connected_components(G))\n\nIn case you’re not familiar with Python sets, they are collections of items without duplicates. These are useful for collecting node names because node names should be unique. As with other collections, we can get the number of items in a set with the len function:\n\ncomponents = list(nx.connected_components(G))\nlen(components[0])\n\nWe often care about the largest connected component, which is sometimes referred to as the core of the network. We can make use of Python’s builtin max function in order to obtain the largest connected component. By default, Python’s max function sorts things in lexicographic (i.e. alphabetical) order, which is not helpful here. We want the maximum connected component when sorted in order of their sizes, so we pass len as a key function:\n\nmax(nx.connected_components(G), key=len)\n\nWhile it’s often enough to just have the list of node names, sometimes we need the actual subgraph consisting of the largest connected component. One way to get this is to pass the list of node names to the G.subgraph() function:\n\ncore_nodes = max(nx.connected_components(G), key=len)\ncore = G.subgraph(core_nodes)\n\nnx.draw(core, with_labels=True)\n\nThose of you using tab-completion will also notice a nx.connected_component_subgraphs() function. This can also be used to get the core subgraph but the method shown is more efficient when you only care about the largest connected component.\n\n\n\n\nLet’s extend these ideas about paths and connected components to directed graphs.\n\nD = nx.DiGraph()\nD.add_edges_from(\n    [\n        (1, 2),\n        (2, 3),\n        (3, 2),\n        (3, 4),\n        (3, 5),\n        (4, 2),\n        (4, 5),\n        (4, 6),\n        (5, 6),\n        (6, 4),\n    ]\n)\nnx.draw(D, with_labels=True)\nplt.show()\n\n\n\nWe know that in a directed graph, an edge from an arbitrary node \\(u\\) to an arbitrary node \\(v\\) does not imply that an edge exists from \\(v\\) to \\(u\\). Since paths must follow edge direction in directed graphs, the same asymmetry applies for paths. Observe that this graph has a path from 1 to 4, but not in the reverse direction.\n\nnx.has_path(D, 1, 4)\n\n\nnx.has_path(D, 4, 1)\n\nThe other NetworkX functions dealing with paths take this asymmetry into account as well:\n\nnx.shortest_path(D, 2, 5)\n\n\nnx.shortest_path(D, 5, 2)\n\nSince there is no edge from 5 to 3, the shortest path from 5 to 2 cannot simply backtrack the shortest path from 2 to 5 – it has to go a longer route through nodes 6 and 4.\n\n\n\nDirected networks have two kinds of connectivity. Strongly connected means that there exists a directed path between every pair of nodes, i.e., that from any node we can get to any other node while following edge directionality. Think of cars on a network of one-way streets: they can’t drive against the flow of traffic.\n\nnx.is_strongly_connected(D)\n\nWeakly connected means that there exist a path between every pair of nodes, regardless of direction. Think about pedestrians on a network of one-way streets: they walk on the sidewalks so they don’t care about the direction of traffic.\n\nnx.is_weakly_connected(D)\n\nIf a network is strongly connected, it is also weakly connected. The converse is not always true, as seen in this example.\nThe is_connected function for undirected graphs will raise an error when given a directed graph.\n\n# This will raise an error\nnx.is_connected(D)\n\nIn the directed case, instead of nx.connected_components we now have nx.weakly_connected_components and nx.strongly_connected_components:\n\nlist(nx.weakly_connected_components(D))\n\n\nlist(nx.strongly_connected_components(D))\n\n\n\n\n\n\nThis repository contains several example network datasets. Among these is a network of US air travel routes:\n\nG = nx.read_graphml(\"../../data/openflights/openflights_usa.graphml.gz\")\n\nThe nodes in this graph are airports, represented by their IATA codes; two nodes are connected with an edge if there is a scheduled flight directly connecting these two airports. We’ll assume this graph to be undirected since a flight in one direction usually means there is a return flight.\nThus this graph has edges\n[('HOM', 'ANC'), ('BGM', 'PHL'), ('BGM', 'IAD'), ...]\nwhere ANC is Anchorage, IAD is Washington Dulles, etc.\nThese nodes also have attributes associated with them, containing additional information about the airports:\n\nG.nodes[\"IND\"]\n\nNode attributes are stored as a dictionary, so the values can be accessed individually as such:\n\nG.nodes[\"IND\"][\"name\"]\n\n\n\nIs there a direct flight between Indianapolis and Fairbanks, Alaska (FAI)? A direct flight is one with no intermediate stops.\n\n\n\nIf I wanted to fly from Indianapolis to Fairbanks, Alaska what would be an itinerary with the fewest number of flights?\n\n\n\nIs it possible to travel from any airport in the US to any other airport in the US, possibly using connecting flights? In other words, does there exist a path in the network between every possible pair of airports?"
  },
  {
    "objectID": "references/networkx_indiana/2-networkx-paths.html#paths",
    "href": "references/networkx_indiana/2-networkx-paths.html#paths",
    "title": "NetworkX - Paths",
    "section": "",
    "text": "Let’s start with a very simple, undirected network.\n\nG = nx.Graph()\n\nG.add_nodes_from([1, 2, 3, 4])\n\nG.add_edges_from([(1, 2), (2, 3), (1, 3), (1, 4)])\n\nnx.draw(G, with_labels=True)\nplt.show()\n\nA path in a network is a sequence of edges connecting two nodes. In this simple example, we can easily see that there is indeed at least one path that connects nodes 3 and 4. We can verify this with NetworkX:\n\nnx.has_path(G, 3, 4)\n\nThere can be more than one path between two nodes. Again considering nodes 3 and 4, there are two such “simple” paths:\n\nlist(nx.all_simple_paths(G, 3, 4))\n\nA simple path is one without any cycles. If we allowed cycles, there would be infinitely many paths because one could always just go around the cycle as many times as desired.\nWe are often most interested in shortest paths. In an unweighted network, the shortest path is the one with the fewest edges. We can see that of the two simple paths between nodes 3 and 4, one is shorter than the other. We can get this shortest path with a single NetworkX function:\n\nnx.shortest_path(G, 3, 4)\n\nIf you only care about the path length, there’s a function for that too:\n\nnx.shortest_path_length(G, 3, 4)\n\nNote that a path length is defined here by the number of edges in the path, not the number of nodes, which implies\nnx.shortest_path_length(G, u, v) == len(nx.shortest_path(G, u, v)) - 1\nfor nodes \\(u\\) and \\(v\\)."
  },
  {
    "objectID": "references/networkx_indiana/2-networkx-paths.html#connected-components",
    "href": "references/networkx_indiana/2-networkx-paths.html#connected-components",
    "title": "NetworkX - Paths",
    "section": "",
    "text": "In the simple network above, we can see that for every pair of nodes, we can find a path connecting them. This is the definition of a connected graph. We can check this property for a given graph:\n\nnx.is_connected(G)\n\nNot every graph is connected:\n\nG = nx.Graph()\n\nnx.add_cycle(G, (1, 2, 3))\nG.add_edge(4, 5)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\nnx.is_connected(G)\n\nAnd NetworkX will raise an error if you ask for a path between nodes where none exists:\n\nnx.has_path(G, 3, 5)\n\n\nnx.shortest_path(G, 3, 5)\n\nVisually, we can identify two connected components in our graph. Let’s verify this:\n\nnx.number_connected_components(G)\n\nThe nx.connected_components() function takes a graph and returns a list of sets of node names, one such set for each connected component. Verify that the two sets in the following list correspond to the two connected components in the drawing of the graph above:\n\nlist(nx.connected_components(G))\n\nIn case you’re not familiar with Python sets, they are collections of items without duplicates. These are useful for collecting node names because node names should be unique. As with other collections, we can get the number of items in a set with the len function:\n\ncomponents = list(nx.connected_components(G))\nlen(components[0])\n\nWe often care about the largest connected component, which is sometimes referred to as the core of the network. We can make use of Python’s builtin max function in order to obtain the largest connected component. By default, Python’s max function sorts things in lexicographic (i.e. alphabetical) order, which is not helpful here. We want the maximum connected component when sorted in order of their sizes, so we pass len as a key function:\n\nmax(nx.connected_components(G), key=len)\n\nWhile it’s often enough to just have the list of node names, sometimes we need the actual subgraph consisting of the largest connected component. One way to get this is to pass the list of node names to the G.subgraph() function:\n\ncore_nodes = max(nx.connected_components(G), key=len)\ncore = G.subgraph(core_nodes)\n\nnx.draw(core, with_labels=True)\n\nThose of you using tab-completion will also notice a nx.connected_component_subgraphs() function. This can also be used to get the core subgraph but the method shown is more efficient when you only care about the largest connected component."
  },
  {
    "objectID": "references/networkx_indiana/2-networkx-paths.html#directed-paths-components",
    "href": "references/networkx_indiana/2-networkx-paths.html#directed-paths-components",
    "title": "NetworkX - Paths",
    "section": "",
    "text": "Let’s extend these ideas about paths and connected components to directed graphs.\n\nD = nx.DiGraph()\nD.add_edges_from(\n    [\n        (1, 2),\n        (2, 3),\n        (3, 2),\n        (3, 4),\n        (3, 5),\n        (4, 2),\n        (4, 5),\n        (4, 6),\n        (5, 6),\n        (6, 4),\n    ]\n)\nnx.draw(D, with_labels=True)\nplt.show()\n\n\n\nWe know that in a directed graph, an edge from an arbitrary node \\(u\\) to an arbitrary node \\(v\\) does not imply that an edge exists from \\(v\\) to \\(u\\). Since paths must follow edge direction in directed graphs, the same asymmetry applies for paths. Observe that this graph has a path from 1 to 4, but not in the reverse direction.\n\nnx.has_path(D, 1, 4)\n\n\nnx.has_path(D, 4, 1)\n\nThe other NetworkX functions dealing with paths take this asymmetry into account as well:\n\nnx.shortest_path(D, 2, 5)\n\n\nnx.shortest_path(D, 5, 2)\n\nSince there is no edge from 5 to 3, the shortest path from 5 to 2 cannot simply backtrack the shortest path from 2 to 5 – it has to go a longer route through nodes 6 and 4.\n\n\n\nDirected networks have two kinds of connectivity. Strongly connected means that there exists a directed path between every pair of nodes, i.e., that from any node we can get to any other node while following edge directionality. Think of cars on a network of one-way streets: they can’t drive against the flow of traffic.\n\nnx.is_strongly_connected(D)\n\nWeakly connected means that there exist a path between every pair of nodes, regardless of direction. Think about pedestrians on a network of one-way streets: they walk on the sidewalks so they don’t care about the direction of traffic.\n\nnx.is_weakly_connected(D)\n\nIf a network is strongly connected, it is also weakly connected. The converse is not always true, as seen in this example.\nThe is_connected function for undirected graphs will raise an error when given a directed graph.\n\n# This will raise an error\nnx.is_connected(D)\n\nIn the directed case, instead of nx.connected_components we now have nx.weakly_connected_components and nx.strongly_connected_components:\n\nlist(nx.weakly_connected_components(D))\n\n\nlist(nx.strongly_connected_components(D))"
  },
  {
    "objectID": "references/networkx_indiana/2-networkx-paths.html#dataset-us-air-traffic-network",
    "href": "references/networkx_indiana/2-networkx-paths.html#dataset-us-air-traffic-network",
    "title": "NetworkX - Paths",
    "section": "",
    "text": "This repository contains several example network datasets. Among these is a network of US air travel routes:\n\nG = nx.read_graphml(\"../../data/openflights/openflights_usa.graphml.gz\")\n\nThe nodes in this graph are airports, represented by their IATA codes; two nodes are connected with an edge if there is a scheduled flight directly connecting these two airports. We’ll assume this graph to be undirected since a flight in one direction usually means there is a return flight.\nThus this graph has edges\n[('HOM', 'ANC'), ('BGM', 'PHL'), ('BGM', 'IAD'), ...]\nwhere ANC is Anchorage, IAD is Washington Dulles, etc.\nThese nodes also have attributes associated with them, containing additional information about the airports:\n\nG.nodes[\"IND\"]\n\nNode attributes are stored as a dictionary, so the values can be accessed individually as such:\n\nG.nodes[\"IND\"][\"name\"]\n\n\n\nIs there a direct flight between Indianapolis and Fairbanks, Alaska (FAI)? A direct flight is one with no intermediate stops.\n\n\n\nIf I wanted to fly from Indianapolis to Fairbanks, Alaska what would be an itinerary with the fewest number of flights?\n\n\n\nIs it possible to travel from any airport in the US to any other airport in the US, possibly using connecting flights? In other words, does there exist a path in the network between every possible pair of airports?"
  },
  {
    "objectID": "references/networkx_indiana/3-networkx-centrality.html",
    "href": "references/networkx_indiana/3-networkx-centrality.html",
    "title": "Network X - Centrality",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nContents:\n\nFinding hubs\nCentrality distributions\nTesting robustness\n\n\nfrom collections import Counter\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\nimport random\n\n\n\nOften when looking at a network, we want to find the most “important” nodes, for some definition of important. The most basic measure of centrality is the degree, or number of links attached to a node.\nLet’s look at the Enron executive email graph:\n\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\nprint(G)\nnx.draw(G)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\n\n\nBy default, nx.read_edgelist assumes node names are strings.\nEdge lists are a simple, plain text format for storing graphs. Since this simple file format doesn’t contain information about data types, all node names are assumed to be strings by default. When the node names are given by integers, as they are in this example, we should specify the nodetype=int keyword argument to avoid confusion with the node names.\n\n\n\nWe can apply the max function to get the maximum node according to some criterion. In our case, we want to compare the nodes by their degree:\n\nhighest_degree_node = max(G.nodes, key=G.degree)\nhighest_degree_node\n\n105\n\n\n\nG.degree(highest_degree_node)\n\n42\n\n\nSo we know that node 105 has 42 edges connected to it. Let’s look at that calculation a little closer:\nmax(G.nodes, key=G.degree)\nWe’re telling the max function that we want the item from G.nodes that gives us the highest value when passed to the key function G.degree.\nThis construction works because G.degree is a function. Some other measures of centrality such as betweenness generate all of the nodes’ centrality values at once and return a dict. In this case, we need an extra step:\n\nbetweenness = nx.centrality.betweenness_centrality(G)\nhighest_betweenness_node = max(G.nodes, key=betweenness.get)\nhighest_betweenness_node\n\n105\n\n\n\nbetweenness[highest_betweenness_node]\n\n0.19400604344556296\n\n\nNote that the following will throw an error:\n\nmax(G.nodes, key=betweenness)\n\nTypeError: 'dict' object is not callable\n\n\nThis is because we need to provide a function to the key argument, but betweenness is a dict. To get around this, we use the dict’s get method.\n\n\n\n\n\nWe’ve found the most central node in the network, but often we want to summarize information about the centrality of all nodes. For example, in addition to the maxmimum degree, we often want the mean and median degree in a network.\nThe first step in summarizing this information is to get a sequence of all of the centrality values in the graph. We don’t care about the node names anymore, we just want a sequence of numbers. We can start with the example of degree:\n\ndegree_sequence = [G.degree(n) for n in G.nodes]\n\nTo get the mean and median of this sequence, we can use NumPy:\n\nprint(\"Mean degree:\", np.mean(degree_sequence))\nprint(\"Median degree:\", np.median(degree_sequence))\n\nMean degree: 8.713286713286713\nMedian degree: 8.0\n\n\nFor other measures of centrality, which are calculated for the whole network at once and return a dict, we can use the dict’s .values().\n\nbetweenness = nx.centrality.betweenness_centrality(G)\nbetweenness_sequence = list(betweenness.values())\n\nprint(\"Mean betweenness:\", np.mean(betweenness_sequence))\nprint(\"Median betweenness:\", np.median(betweenness_sequence))\n\nMean betweenness: 0.013950388838012456\nMedian betweenness: 0.0037492834763570323\n\n\n\n\nWe can graphically represent the sequence of centrality values by using a histogram. In its basic form, a histogram plots the degree values on the x-axis, and the number of nodes having that degree on the y-axis. To do this counting, we can make use of Python’s collections.Counter.\n\ndegree_counts = Counter(degree_sequence)\ndegree_counts\n\nCounter({2: 16,\n         9: 16,\n         4: 11,\n         11: 10,\n         10: 9,\n         7: 9,\n         3: 9,\n         5: 8,\n         6: 7,\n         14: 6,\n         8: 6,\n         1: 6,\n         17: 5,\n         12: 5,\n         16: 5,\n         13: 3,\n         18: 3,\n         15: 3,\n         19: 2,\n         30: 1,\n         20: 1,\n         42: 1,\n         23: 1})\n\n\nThe Counter object returned is like a dict, pairing the item counted with the number of times it showed up in the sequence.\nOn this basic histogram plot, we want an x-value for every integer between the minimum and maximum degree in the sequence, inclusive. Note that degree_counts.keys() gives us every distinct value seen in the degree sequence. Also note that we need the +1 in the range below because we want to include the right endpoint.\n\nmin_degree, max_degree = min(degree_counts.keys()), max(degree_counts.keys())\n\nplot_x = list(range(min_degree, max_degree + 1))\n\nOur y-values are then the number of times we counted each x-value in the degree sequence. We can make use of the .get method with a default value in order to count 0 for degree values that don’t show up in the sequence. For example, notice that 32 does not show up in degree_counts above, so degree_counts.get(32, 0) will give us 0.\n\nplot_y = [degree_counts.get(x, 0) for x in plot_x]\n\nTo do the plotting, we use Matplotlib’s pyplot module.\n\nplt.bar(plot_x, plot_y)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nWhen there are more x-values than you can comfortably display, or when your centrality measure is not discrete, as in the case of betweenness centrality, we can make use of histogram “binning.” This just defines a sequence of disjoint intervals called bins, and counts the number of values that fall into each such bin. In the simplest of cases, we can just tell Pyplot’s hist function how many bins we want and it will do the binning for us.\n\ncounts, bins, patches = plt.hist(betweenness_sequence, bins=10)\nplt.show()\n\n\n\n\n\n\n\n\nWe can investigate the returned bins and counts if we want:\n\nbins\n\narray([0.        , 0.0194006 , 0.03880121, 0.05820181, 0.07760242,\n       0.09700302, 0.11640363, 0.13580423, 0.15520483, 0.17460544,\n       0.19400604])\n\n\n\ncounts\n\narray([115.,  13.,   6.,   4.,   3.,   1.,   0.,   0.,   0.,   1.])\n\n\nFrom these, we can see that there are 115 values between 0 and 0.0194006, 13 values between 0.194006 and 0.3880121, etc.\n\n\n\n\n\nAnother way to think about the relative “importance” of nodes in a network is to measure how much it would damage the network structure if particular nodes were to be removed. In real life, node removal might be a person moving away and out of a social network, someone changing jobs and being removed from an email network, internet routers being attacked/overloaded and going down, etc.\nBroadly, we consider two types of network damage: random failure and targeted attack. In a random failure, nodes are chosen randomly for removal. In a targeted attack, we will remove nodes based on some criterion, for example, removing nodes in decreasing order of their degree centrality.\n\n\nIn order to measure “damage,” we will measure the size of the network’s largest connected component, sometimes called core. First we observe that nx.connected_components is a generator that provides the connected components one at a time.\n\nnx.connected_components(G)\n\n&lt;generator object connected_components at 0x7f7d85601f68&gt;\n\n\nSince we often only want the core, or largest connected component, we can use the max function to get it. Each component is provided as a set of node names:\n\ncore = max(nx.connected_components(G), key=len)\ncore\n\n{1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9,\n 10,\n 11,\n 12,\n 13,\n 14,\n 15,\n 16,\n 17,\n 18,\n 19,\n 20,\n 21,\n 22,\n 23,\n 24,\n 25,\n 26,\n 27,\n 28,\n 29,\n 30,\n 31,\n 32,\n 33,\n 34,\n 35,\n 36,\n 37,\n 38,\n 39,\n 40,\n 41,\n 42,\n 43,\n 44,\n 45,\n 46,\n 47,\n 48,\n 49,\n 50,\n 51,\n 52,\n 53,\n 54,\n 55,\n 56,\n 57,\n 58,\n 59,\n 60,\n 61,\n 62,\n 63,\n 64,\n 65,\n 66,\n 67,\n 68,\n 69,\n 70,\n 71,\n 72,\n 73,\n 74,\n 75,\n 76,\n 77,\n 78,\n 79,\n 80,\n 81,\n 82,\n 83,\n 84,\n 85,\n 86,\n 87,\n 88,\n 89,\n 90,\n 91,\n 92,\n 93,\n 94,\n 95,\n 96,\n 97,\n 98,\n 99,\n 100,\n 101,\n 102,\n 103,\n 104,\n 105,\n 106,\n 107,\n 108,\n 109,\n 110,\n 111,\n 112,\n 113,\n 114,\n 115,\n 116,\n 117,\n 118,\n 119,\n 120,\n 121,\n 122,\n 123,\n 124,\n 125,\n 126,\n 127,\n 128,\n 129,\n 130,\n 131,\n 132,\n 133,\n 134,\n 135,\n 136,\n 137,\n 138,\n 139,\n 140,\n 141,\n 142,\n 143}\n\n\nSo the len of this set gives us the number of nodes in this component:\n\nlen(core)\n\n143\n\n\nIf we want all of the connected components, we can get a list of them:\n\ncomponents = list(nx.connected_components(G))\n\nthe length of this list is the number of connected components:\n\nlen(components)\n\n1\n\n\n\n\n\nWhenever we’re going to engage in a distructive process, we want to make a copy of the network graph to attack so that we can easily get back to the original state:\n\nC = G.copy()\n\nTo simulate random failure, we randomly choose some node names and remove them from the graph. We can use random.sample to remove more than one node at at time. Note that we need to make a list of node names from which to randomly sample:\n\nnodes_to_remove = random.sample(list(C.nodes), 2)\nC.remove_nodes_from(nodes_to_remove)\n\nThe full simulation is going to work like this, beginning from a fresh copy of the network:\n\nMeasure size of the network core as compared to the original network size\nSelect M nodes at random and remove them\nRepeat until there are less than M nodes\n\nWe’ll determine M from how many steps we want this process to take. Around 25 steps should be good, so:\n\nnumber_of_steps = 25\nM = G.number_of_nodes() // number_of_steps\nM\n\n5\n\n\nWe can then use range to generate a sequence of the total number of nodes removed at each step:\n\nnum_nodes_removed = range(0, G.number_of_nodes(), M)\n\nThe loop is fairly simple. At each step, we need to record the fraction of remaining nodes in the core.\n\nN = G.number_of_nodes()\nC = G.copy()\nrandom_attack_core_proportions = []\nfor nodes_removed in num_nodes_removed:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / N\n    random_attack_core_proportions.append(core_proportion)\n\n    # If there are more than M nodes, select M nodes at random and remove them\n    if C.number_of_nodes() &gt; M:\n        nodes_to_remove = random.sample(list(C.nodes), M)\n        C.remove_nodes_from(nodes_to_remove)\n\n\nplt.title(\"Random failure\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(num_nodes_removed, random_attack_core_proportions, marker=\"o\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nSimulating a targeted attack is similar, except that instead of choosing randomly, we will select the M most central nodes at each step. To accomplish this we want something like the max function used earler to get the most central node, but able to get the top M nodes. We can use Python’s sorted function in a similar way to max to first sort the nodes by centrality in descending, or reverse, order. Once sorted by degree, we take the first M nodes in the list:\n\nnodes_sorted_by_degree = sorted(G.nodes, key=G.degree, reverse=True)\ntop_degree_nodes = nodes_sorted_by_degree[:M]\ntop_degree_nodes\n\n[105, 17, 95, 48, 132]\n\n\nWith that in mind, the loop looks similar. Let’s put all the pieces together here:\n\nN = G.number_of_nodes()\nnumber_of_steps = 25\nM = N // number_of_steps\n\nnum_nodes_removed = range(0, N, M)\nC = G.copy()\ntargeted_attack_core_proportions = []\nfor nodes_removed in num_nodes_removed:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / N\n    targeted_attack_core_proportions.append(core_proportion)\n\n    # If there are more than M nodes, select top M nodes and remove them\n    if C.number_of_nodes() &gt; M:\n        nodes_sorted_by_degree = sorted(C.nodes, key=C.degree, reverse=True)\n        nodes_to_remove = nodes_sorted_by_degree[:M]\n        C.remove_nodes_from(nodes_to_remove)\n\n\nplt.title(\"Targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(num_nodes_removed, targeted_attack_core_proportions, marker=\"o\")\nplt.show()\n\n\n\n\n\n\n\n\nAs we can see, the effect is dramatic. The network is totally disconnected after removing relatively few central nodes in the graph.\nPyplot can plot these curves on the same plot for additional effect:\n\nplt.title(\"Random failure vs. targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(\n    num_nodes_removed, random_attack_core_proportions, marker=\"o\", label=\"Failures\"\n)\nplt.plot(\n    num_nodes_removed, targeted_attack_core_proportions, marker=\"^\", label=\"Attacks\"\n)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/3-networkx-centrality.html#finding-hubs",
    "href": "references/networkx_indiana/3-networkx-centrality.html#finding-hubs",
    "title": "Network X - Centrality",
    "section": "",
    "text": "Often when looking at a network, we want to find the most “important” nodes, for some definition of important. The most basic measure of centrality is the degree, or number of links attached to a node.\nLet’s look at the Enron executive email graph:\n\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\nprint(G)\nnx.draw(G)\nplt.show()\n\nGraph with 143 nodes and 623 edges\n\n\n\n\n\n\n\n\n\n\n\nBy default, nx.read_edgelist assumes node names are strings.\nEdge lists are a simple, plain text format for storing graphs. Since this simple file format doesn’t contain information about data types, all node names are assumed to be strings by default. When the node names are given by integers, as they are in this example, we should specify the nodetype=int keyword argument to avoid confusion with the node names.\n\n\n\nWe can apply the max function to get the maximum node according to some criterion. In our case, we want to compare the nodes by their degree:\n\nhighest_degree_node = max(G.nodes, key=G.degree)\nhighest_degree_node\n\n105\n\n\n\nG.degree(highest_degree_node)\n\n42\n\n\nSo we know that node 105 has 42 edges connected to it. Let’s look at that calculation a little closer:\nmax(G.nodes, key=G.degree)\nWe’re telling the max function that we want the item from G.nodes that gives us the highest value when passed to the key function G.degree.\nThis construction works because G.degree is a function. Some other measures of centrality such as betweenness generate all of the nodes’ centrality values at once and return a dict. In this case, we need an extra step:\n\nbetweenness = nx.centrality.betweenness_centrality(G)\nhighest_betweenness_node = max(G.nodes, key=betweenness.get)\nhighest_betweenness_node\n\n105\n\n\n\nbetweenness[highest_betweenness_node]\n\n0.19400604344556296\n\n\nNote that the following will throw an error:\n\nmax(G.nodes, key=betweenness)\n\nTypeError: 'dict' object is not callable\n\n\nThis is because we need to provide a function to the key argument, but betweenness is a dict. To get around this, we use the dict’s get method."
  },
  {
    "objectID": "references/networkx_indiana/3-networkx-centrality.html#centrality-distributions",
    "href": "references/networkx_indiana/3-networkx-centrality.html#centrality-distributions",
    "title": "Network X - Centrality",
    "section": "",
    "text": "We’ve found the most central node in the network, but often we want to summarize information about the centrality of all nodes. For example, in addition to the maxmimum degree, we often want the mean and median degree in a network.\nThe first step in summarizing this information is to get a sequence of all of the centrality values in the graph. We don’t care about the node names anymore, we just want a sequence of numbers. We can start with the example of degree:\n\ndegree_sequence = [G.degree(n) for n in G.nodes]\n\nTo get the mean and median of this sequence, we can use NumPy:\n\nprint(\"Mean degree:\", np.mean(degree_sequence))\nprint(\"Median degree:\", np.median(degree_sequence))\n\nMean degree: 8.713286713286713\nMedian degree: 8.0\n\n\nFor other measures of centrality, which are calculated for the whole network at once and return a dict, we can use the dict’s .values().\n\nbetweenness = nx.centrality.betweenness_centrality(G)\nbetweenness_sequence = list(betweenness.values())\n\nprint(\"Mean betweenness:\", np.mean(betweenness_sequence))\nprint(\"Median betweenness:\", np.median(betweenness_sequence))\n\nMean betweenness: 0.013950388838012456\nMedian betweenness: 0.0037492834763570323\n\n\n\n\nWe can graphically represent the sequence of centrality values by using a histogram. In its basic form, a histogram plots the degree values on the x-axis, and the number of nodes having that degree on the y-axis. To do this counting, we can make use of Python’s collections.Counter.\n\ndegree_counts = Counter(degree_sequence)\ndegree_counts\n\nCounter({2: 16,\n         9: 16,\n         4: 11,\n         11: 10,\n         10: 9,\n         7: 9,\n         3: 9,\n         5: 8,\n         6: 7,\n         14: 6,\n         8: 6,\n         1: 6,\n         17: 5,\n         12: 5,\n         16: 5,\n         13: 3,\n         18: 3,\n         15: 3,\n         19: 2,\n         30: 1,\n         20: 1,\n         42: 1,\n         23: 1})\n\n\nThe Counter object returned is like a dict, pairing the item counted with the number of times it showed up in the sequence.\nOn this basic histogram plot, we want an x-value for every integer between the minimum and maximum degree in the sequence, inclusive. Note that degree_counts.keys() gives us every distinct value seen in the degree sequence. Also note that we need the +1 in the range below because we want to include the right endpoint.\n\nmin_degree, max_degree = min(degree_counts.keys()), max(degree_counts.keys())\n\nplot_x = list(range(min_degree, max_degree + 1))\n\nOur y-values are then the number of times we counted each x-value in the degree sequence. We can make use of the .get method with a default value in order to count 0 for degree values that don’t show up in the sequence. For example, notice that 32 does not show up in degree_counts above, so degree_counts.get(32, 0) will give us 0.\n\nplot_y = [degree_counts.get(x, 0) for x in plot_x]\n\nTo do the plotting, we use Matplotlib’s pyplot module.\n\nplt.bar(plot_x, plot_y)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nWhen there are more x-values than you can comfortably display, or when your centrality measure is not discrete, as in the case of betweenness centrality, we can make use of histogram “binning.” This just defines a sequence of disjoint intervals called bins, and counts the number of values that fall into each such bin. In the simplest of cases, we can just tell Pyplot’s hist function how many bins we want and it will do the binning for us.\n\ncounts, bins, patches = plt.hist(betweenness_sequence, bins=10)\nplt.show()\n\n\n\n\n\n\n\n\nWe can investigate the returned bins and counts if we want:\n\nbins\n\narray([0.        , 0.0194006 , 0.03880121, 0.05820181, 0.07760242,\n       0.09700302, 0.11640363, 0.13580423, 0.15520483, 0.17460544,\n       0.19400604])\n\n\n\ncounts\n\narray([115.,  13.,   6.,   4.,   3.,   1.,   0.,   0.,   0.,   1.])\n\n\nFrom these, we can see that there are 115 values between 0 and 0.0194006, 13 values between 0.194006 and 0.3880121, etc."
  },
  {
    "objectID": "references/networkx_indiana/3-networkx-centrality.html#testing-robustness",
    "href": "references/networkx_indiana/3-networkx-centrality.html#testing-robustness",
    "title": "Network X - Centrality",
    "section": "",
    "text": "Another way to think about the relative “importance” of nodes in a network is to measure how much it would damage the network structure if particular nodes were to be removed. In real life, node removal might be a person moving away and out of a social network, someone changing jobs and being removed from an email network, internet routers being attacked/overloaded and going down, etc.\nBroadly, we consider two types of network damage: random failure and targeted attack. In a random failure, nodes are chosen randomly for removal. In a targeted attack, we will remove nodes based on some criterion, for example, removing nodes in decreasing order of their degree centrality.\n\n\nIn order to measure “damage,” we will measure the size of the network’s largest connected component, sometimes called core. First we observe that nx.connected_components is a generator that provides the connected components one at a time.\n\nnx.connected_components(G)\n\n&lt;generator object connected_components at 0x7f7d85601f68&gt;\n\n\nSince we often only want the core, or largest connected component, we can use the max function to get it. Each component is provided as a set of node names:\n\ncore = max(nx.connected_components(G), key=len)\ncore\n\n{1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9,\n 10,\n 11,\n 12,\n 13,\n 14,\n 15,\n 16,\n 17,\n 18,\n 19,\n 20,\n 21,\n 22,\n 23,\n 24,\n 25,\n 26,\n 27,\n 28,\n 29,\n 30,\n 31,\n 32,\n 33,\n 34,\n 35,\n 36,\n 37,\n 38,\n 39,\n 40,\n 41,\n 42,\n 43,\n 44,\n 45,\n 46,\n 47,\n 48,\n 49,\n 50,\n 51,\n 52,\n 53,\n 54,\n 55,\n 56,\n 57,\n 58,\n 59,\n 60,\n 61,\n 62,\n 63,\n 64,\n 65,\n 66,\n 67,\n 68,\n 69,\n 70,\n 71,\n 72,\n 73,\n 74,\n 75,\n 76,\n 77,\n 78,\n 79,\n 80,\n 81,\n 82,\n 83,\n 84,\n 85,\n 86,\n 87,\n 88,\n 89,\n 90,\n 91,\n 92,\n 93,\n 94,\n 95,\n 96,\n 97,\n 98,\n 99,\n 100,\n 101,\n 102,\n 103,\n 104,\n 105,\n 106,\n 107,\n 108,\n 109,\n 110,\n 111,\n 112,\n 113,\n 114,\n 115,\n 116,\n 117,\n 118,\n 119,\n 120,\n 121,\n 122,\n 123,\n 124,\n 125,\n 126,\n 127,\n 128,\n 129,\n 130,\n 131,\n 132,\n 133,\n 134,\n 135,\n 136,\n 137,\n 138,\n 139,\n 140,\n 141,\n 142,\n 143}\n\n\nSo the len of this set gives us the number of nodes in this component:\n\nlen(core)\n\n143\n\n\nIf we want all of the connected components, we can get a list of them:\n\ncomponents = list(nx.connected_components(G))\n\nthe length of this list is the number of connected components:\n\nlen(components)\n\n1\n\n\n\n\n\nWhenever we’re going to engage in a distructive process, we want to make a copy of the network graph to attack so that we can easily get back to the original state:\n\nC = G.copy()\n\nTo simulate random failure, we randomly choose some node names and remove them from the graph. We can use random.sample to remove more than one node at at time. Note that we need to make a list of node names from which to randomly sample:\n\nnodes_to_remove = random.sample(list(C.nodes), 2)\nC.remove_nodes_from(nodes_to_remove)\n\nThe full simulation is going to work like this, beginning from a fresh copy of the network:\n\nMeasure size of the network core as compared to the original network size\nSelect M nodes at random and remove them\nRepeat until there are less than M nodes\n\nWe’ll determine M from how many steps we want this process to take. Around 25 steps should be good, so:\n\nnumber_of_steps = 25\nM = G.number_of_nodes() // number_of_steps\nM\n\n5\n\n\nWe can then use range to generate a sequence of the total number of nodes removed at each step:\n\nnum_nodes_removed = range(0, G.number_of_nodes(), M)\n\nThe loop is fairly simple. At each step, we need to record the fraction of remaining nodes in the core.\n\nN = G.number_of_nodes()\nC = G.copy()\nrandom_attack_core_proportions = []\nfor nodes_removed in num_nodes_removed:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / N\n    random_attack_core_proportions.append(core_proportion)\n\n    # If there are more than M nodes, select M nodes at random and remove them\n    if C.number_of_nodes() &gt; M:\n        nodes_to_remove = random.sample(list(C.nodes), M)\n        C.remove_nodes_from(nodes_to_remove)\n\n\nplt.title(\"Random failure\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(num_nodes_removed, random_attack_core_proportions, marker=\"o\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nSimulating a targeted attack is similar, except that instead of choosing randomly, we will select the M most central nodes at each step. To accomplish this we want something like the max function used earler to get the most central node, but able to get the top M nodes. We can use Python’s sorted function in a similar way to max to first sort the nodes by centrality in descending, or reverse, order. Once sorted by degree, we take the first M nodes in the list:\n\nnodes_sorted_by_degree = sorted(G.nodes, key=G.degree, reverse=True)\ntop_degree_nodes = nodes_sorted_by_degree[:M]\ntop_degree_nodes\n\n[105, 17, 95, 48, 132]\n\n\nWith that in mind, the loop looks similar. Let’s put all the pieces together here:\n\nN = G.number_of_nodes()\nnumber_of_steps = 25\nM = N // number_of_steps\n\nnum_nodes_removed = range(0, N, M)\nC = G.copy()\ntargeted_attack_core_proportions = []\nfor nodes_removed in num_nodes_removed:\n    # Measure the relative size of the network core\n    core = max(nx.connected_components(C), key=len)\n    core_proportion = len(core) / N\n    targeted_attack_core_proportions.append(core_proportion)\n\n    # If there are more than M nodes, select top M nodes and remove them\n    if C.number_of_nodes() &gt; M:\n        nodes_sorted_by_degree = sorted(C.nodes, key=C.degree, reverse=True)\n        nodes_to_remove = nodes_sorted_by_degree[:M]\n        C.remove_nodes_from(nodes_to_remove)\n\n\nplt.title(\"Targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(num_nodes_removed, targeted_attack_core_proportions, marker=\"o\")\nplt.show()\n\n\n\n\n\n\n\n\nAs we can see, the effect is dramatic. The network is totally disconnected after removing relatively few central nodes in the graph.\nPyplot can plot these curves on the same plot for additional effect:\n\nplt.title(\"Random failure vs. targeted attack\")\nplt.xlabel(\"Number of nodes removed\")\nplt.ylabel(\"Proportion of nodes in core\")\nplt.plot(\n    num_nodes_removed, random_attack_core_proportions, marker=\"o\", label=\"Failures\"\n)\nplt.plot(\n    num_nodes_removed, targeted_attack_core_proportions, marker=\"^\", label=\"Attacks\"\n)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/5-networkx-partitions.html",
    "href": "references/networkx_indiana/5-networkx-partitions.html",
    "title": "NetworkX - Partitions",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nContents:\n\nPartitions\nModularity\nZachary’s Karate Club\nGirvan-Newman clustering\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\n\n\nA partition of a graph is a separation of its nodes into disjoint groups. Consider the following graph:\n\nG = nx.Graph()\nnx.add_cycle(G, [0, 1, 2, 3])\nnx.add_cycle(G, [4, 5, 6, 7])\nG.add_edge(0, 7)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nThe following is an example of a partition of these nodes:\n\npartition = [\n    {1, 2, 3},\n    {4, 5, 6},\n    {0, 7},\n]\n\nObserve that every node in the graph is in exactly one of the sets in the partition. Formally, a partition is a list of sets such that every node is in exactly one set. NetworkX can verify that our partition is valid:\n\nnx.community.is_partition(G, partition)\n\nTrue\n\n\nWhen developing community detection algorithms, we often make use of a partition map, which is a dictionary mapping node names to a partition index. This is useful for quickly comparing if two nodes are in the same cluster in the partition:\n\npartition_map = {}\nfor idx, cluster_nodes in enumerate(partition):\n    for node in cluster_nodes:\n        partition_map[node] = idx\n\npartition_map\n\n{1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 0: 2, 7: 2}\n\n\nIn this dictionary, the keys are the node names and two nodes will have the same value if they are in the same partition:\n\npartition_map[0] == partition_map[7]\n\nTrue\n\n\nWe can visualize our partition by drawing the graph with nodes colored by their partition membership:\n\nnode_colors = [partition_map[n] for n in G.nodes]\n\nnx.draw(G, node_color=node_colors, with_labels=True)\n\n\n\n\n\n\n\n\nThere are two trivial partitions:\n\nThe partition with one set containing every node;\nThe partition with N sets, each containing a single node.\n\nA valid partition thus contains between 1 and N sets.\nFeel free to experiment by changing the partition above and running the subsequent cells.\n\n\n\n\nAt a high level, network community detection consists of finding a partition that achieves good separation between the groups of nodes. Before we get into how to find good partitions of a graph, we need an objective – a way to measure how good the partition is. Modularity is one such objective function.\nThe modularity of a graph partition compares the number of intra-group edges with a random baseline. Higher modularity scores correspond to a higher proportion of intra-group edges, therefore fewer inter-group edges and better separation of groups.\nFor weighted undirected networks, as described in the text, we have\n\\[\nQ_w=\\frac{1}{W}\\sum_C \\left(W_C-\\frac{s_C^2}{4W}\\right),\n\\]\nwhere\n\n\\(W\\) is the total weight of the links of the network,\n\\(W_C\\) the total weight of the internal links of cluster \\(C\\), and\n\\(s_C\\) the total strength of the nodes of \\(C\\).\n\nThe total weight \\(W\\) is half the total strength for the same reason that the number of edges \\(L\\) is half the total degree. While this formula may look a bit complicated, it’s straightforward to write code to compute the sum:\n\nnx.community.quality.modularity(G, partition)\n\n0.2222222222222222\n\n\nLet’s compare this to a partition we would suspect to have higher modularity:\n\npartition_2 = [\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n]\nnx.community.quality.modularity(G, partition_2)\n\n0.38888888888888884\n\n\n\n\n\n\nWhen writing and testing community-detection algorithms, it helps to make use of benchmark networks: graphs with a known, “natural” community structure. Perhaps the most famous benchmark graph is Zachary’s Karate Club. It contains 34 nodes, representing members of a karate club whose interactions were monitored over a period of three years by researchers. Links in this graph connect individuals interacting outside club activities, a proxy for social ties.\nDuring the course of the study, a conflict between the instructor Mr. Hi (node 0) and the president, or Officer (node 33) led to a split of the club into separate groups led by Mr. Hi and Officer. In this case we know whom each member of the group followed after the split, providing empirical community labels: those members who followed Mr. Hi are said to be one community and those following the Officer make up the other.\nFor this graph, we assume that the post-split group composition was largely driven by the social ties: members of the same friend groups would want to be part of the same club after the split. We thus expect a good community-detection algorithm to predict the post-split group composition with high accuracy.\nZachary’s karate club is such a popular benchmark graph that it has its own function in NetworkX:\n\nK = nx.karate_club_graph()\nnx.draw(K, with_labels=True)\n\n\n\n\n\n\n\n\nEach node in a NetworkX graph has a dictionary of attributes associated with it. This dictionary can hold arbitrary data about a node. We can get the attributes for a single node by giving the node name to the nodes object.\nEach node in this graph has a 'club' attribute, indicating whether the member followed the instructor or the president after the split:\n\nK.nodes[0]\n\n{'club': 'Mr. Hi'}\n\n\n\nK.nodes[9]\n\n{'club': 'Officer'}\n\n\nWe can visualize these labels by coloring each node according to its 'club' attribute:\n\nK = nx.karate_club_graph()\nclub_color = {\n    \"Mr. Hi\": \"orange\",\n    \"Officer\": \"lightblue\",\n}\nnode_colors = [club_color[K.nodes[n][\"club\"]] for n in K.nodes]\nnx.draw(K, node_color=node_colors, with_labels=True)\n\n\n\n\n\n\n\n\nThis separation looks good, in that there are relatively few inter-community links as opposed to intra-community links. Let’s create a graph partition based on these labels and measure its modularity.\nWe can do this by creating a dictionary of two sets, one for each value of the nodes’ 'club' attribute, then assigning the nodes to the corresponding set.\n\ngroups = {\n    \"Mr. Hi\": set(),\n    \"Officer\": set(),\n}\n\nfor n in K.nodes:\n    club = K.nodes[n][\"club\"]\n    groups[club].add(n)\n\ngroups\n\n{'Mr. Hi': {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21},\n 'Officer': {9,\n  14,\n  15,\n  18,\n  20,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33}}\n\n\nBy using the dictionary’s .values() method, we can get a list of sets that define our partition:\n\nempirical_partition = list(groups.values())\nempirical_partition\n\n[{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21},\n {9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33}]\n\n\n\nnx.community.is_partition(K, empirical_partition)\n\nTrue\n\n\nSince our partition is indeed a valid partition, we can get the modularity of this partition:\n\nnx.community.quality.modularity(K, empirical_partition)\n\n0.39143756676224206\n\n\nThis is a relatively high modularity, which is what we expect.\n\n\nFor the sake of comparison, let’s generate a random partition of this network and check its modularity. We would expect a modularity close to zero in this case.\nFirst we generate a sample of 17 nodes, half the total number of nodes, and assign them to one community. Our second community then includes the nodes in the graph not in the first community. We can use some set arithmetic to do this concisely:\n\nrandom_nodes = random.sample(sorted(K.nodes), 17)\nrandom_partition = [set(random_nodes), set(K.nodes) - set(random_nodes)]\nrandom_partition\n\n[{6, 8, 9, 10, 11, 12, 13, 14, 15, 18, 19, 20, 22, 25, 28, 29, 32},\n {0, 1, 2, 3, 4, 5, 7, 16, 17, 21, 23, 24, 26, 27, 30, 31, 33}]\n\n\nWe can visualize this partition and observe that the communities are much less natural-looking, as we would expect from a random assignment.\n\nrandom_node_colors = [\"orange\" if n in random_nodes else \"lightblue\" for n in K.nodes]\nnx.draw(K, node_color=random_node_colors)\n\n\n\n\n\n\n\n\nAnd finally we can test the modularity of this partition:\n\nnx.community.quality.modularity(K, random_partition)\n\n-0.09059987631416207\n\n\nSince this is a random process the modularity won’t be exactly zero, but it should be fairly close. Go ahead and repeat the process of generating a random partition and testing its modularity – it will fluctuate around its mean value of zero.\n\n\n\n\n\nRecall from the text the Girvan-Newman clustering algorithm:\n\nCreate a partition sequence\nCalculate the betweenness centrality for all links.\nRemove the link with largest betweenness and create a partition using connected components.\nRecalculate the betweenness centrality of the links of the resulting graph.\nRepeat from step B until no links remain.\nEvaluate each partition in the sequence and choose the one with the highest modularity.\n\nDuring this process, the number of connected components in the graph will increase monotonically as clusters are broken up. Since we are removing one link at a time, the number of connected components can increase by at most one between steps in the sequence – it’s not possible for a single edge to connect more than two nodes, and thus components.\nWe hope that the resulting partition of the graph will approximate its underlying community structure. We’ll use the Karate Club graph here because we know the ground-truth community labels and can compare the result obtained from the algorithm.\nnx.community.girvan_newman(G) will generate a sequence containing one partition of each size greater than one. Here we can see the first several are the same as those we generated:\n\nlist(nx.community.girvan_newman(G))[:5]\n\n[({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n  {2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33}),\n ({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n  {2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33},\n  {9}),\n ({0, 1, 3, 7, 11, 12, 13, 17, 19, 21},\n  {2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33},\n  {4, 5, 6, 10, 16},\n  {9}),\n ({0, 1, 3, 7, 11, 12, 13, 17, 19, 21},\n  {2, 24, 25, 27, 28, 31},\n  {4, 5, 6, 10, 16},\n  {8, 14, 15, 18, 20, 22, 23, 26, 29, 30, 32, 33},\n  {9}),\n ({0, 1, 3, 7, 12, 13, 17, 19, 21},\n  {2, 24, 25, 27, 28, 31},\n  {4, 5, 6, 10, 16},\n  {8, 14, 15, 18, 20, 22, 23, 26, 29, 30, 32, 33},\n  {9},\n  {11})]\n\n\nThe two cluster partition is:\n\ntwo_cluster_partition = next(nx.community.girvan_newman(G))\n\ntwo_cluster_partition\n\n({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n {2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33})\n\n\nHow good is this partition? We can get its modularity:\n\nnx.community.quality.modularity(G, two_cluster_partition)\n\n0.3476602762317048\n\n\nPretty good – comparable to the ground truth community labels. Let’s compare these side-by-side:\n\npos = nx.layout.spring_layout(G)\nfig = plt.figure(figsize=(15, 6))\n\nplt.subplot(1, 2, 1)\ntwo_cluster_partition = next(nx.community.girvan_newman(G))\nnode_colors = [0 if n in two_cluster_partition[0] else 1 for n in G.nodes()]\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Predicted communities\")\n\nplt.subplot(1, 2, 2)\nnode_colors = [G.nodes[n][\"club\"] == \"Officer\" for n in G.nodes()]\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Actual communities\")\nplt.show()\n\nText(0.5, 1.0, 'Actual communities')\n\n\n\n\n\n\n\n\n\nWe can see that the predicted community labels are pretty accurate, only differing on a couple nodes that, visually, seem like they could plausibly beling to either group. Zachary’s original paper even explains the practical considerations of one of these mispredicted nodes: student 8 was very near receiving his black belt from Mr. Hi and thus did not want to leave the group even though several of his friends did.\n\nG.nodes[8]\n\n{'club': 'Mr. Hi'}"
  },
  {
    "objectID": "references/networkx_indiana/5-networkx-partitions.html#partitions",
    "href": "references/networkx_indiana/5-networkx-partitions.html#partitions",
    "title": "NetworkX - Partitions",
    "section": "",
    "text": "A partition of a graph is a separation of its nodes into disjoint groups. Consider the following graph:\n\nG = nx.Graph()\nnx.add_cycle(G, [0, 1, 2, 3])\nnx.add_cycle(G, [4, 5, 6, 7])\nG.add_edge(0, 7)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\nThe following is an example of a partition of these nodes:\n\npartition = [\n    {1, 2, 3},\n    {4, 5, 6},\n    {0, 7},\n]\n\nObserve that every node in the graph is in exactly one of the sets in the partition. Formally, a partition is a list of sets such that every node is in exactly one set. NetworkX can verify that our partition is valid:\n\nnx.community.is_partition(G, partition)\n\nTrue\n\n\nWhen developing community detection algorithms, we often make use of a partition map, which is a dictionary mapping node names to a partition index. This is useful for quickly comparing if two nodes are in the same cluster in the partition:\n\npartition_map = {}\nfor idx, cluster_nodes in enumerate(partition):\n    for node in cluster_nodes:\n        partition_map[node] = idx\n\npartition_map\n\n{1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 0: 2, 7: 2}\n\n\nIn this dictionary, the keys are the node names and two nodes will have the same value if they are in the same partition:\n\npartition_map[0] == partition_map[7]\n\nTrue\n\n\nWe can visualize our partition by drawing the graph with nodes colored by their partition membership:\n\nnode_colors = [partition_map[n] for n in G.nodes]\n\nnx.draw(G, node_color=node_colors, with_labels=True)\n\n\n\n\n\n\n\n\nThere are two trivial partitions:\n\nThe partition with one set containing every node;\nThe partition with N sets, each containing a single node.\n\nA valid partition thus contains between 1 and N sets.\nFeel free to experiment by changing the partition above and running the subsequent cells."
  },
  {
    "objectID": "references/networkx_indiana/5-networkx-partitions.html#modularity",
    "href": "references/networkx_indiana/5-networkx-partitions.html#modularity",
    "title": "NetworkX - Partitions",
    "section": "",
    "text": "At a high level, network community detection consists of finding a partition that achieves good separation between the groups of nodes. Before we get into how to find good partitions of a graph, we need an objective – a way to measure how good the partition is. Modularity is one such objective function.\nThe modularity of a graph partition compares the number of intra-group edges with a random baseline. Higher modularity scores correspond to a higher proportion of intra-group edges, therefore fewer inter-group edges and better separation of groups.\nFor weighted undirected networks, as described in the text, we have\n\\[\nQ_w=\\frac{1}{W}\\sum_C \\left(W_C-\\frac{s_C^2}{4W}\\right),\n\\]\nwhere\n\n\\(W\\) is the total weight of the links of the network,\n\\(W_C\\) the total weight of the internal links of cluster \\(C\\), and\n\\(s_C\\) the total strength of the nodes of \\(C\\).\n\nThe total weight \\(W\\) is half the total strength for the same reason that the number of edges \\(L\\) is half the total degree. While this formula may look a bit complicated, it’s straightforward to write code to compute the sum:\n\nnx.community.quality.modularity(G, partition)\n\n0.2222222222222222\n\n\nLet’s compare this to a partition we would suspect to have higher modularity:\n\npartition_2 = [\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n]\nnx.community.quality.modularity(G, partition_2)\n\n0.38888888888888884"
  },
  {
    "objectID": "references/networkx_indiana/5-networkx-partitions.html#zacharys-karate-club",
    "href": "references/networkx_indiana/5-networkx-partitions.html#zacharys-karate-club",
    "title": "NetworkX - Partitions",
    "section": "",
    "text": "When writing and testing community-detection algorithms, it helps to make use of benchmark networks: graphs with a known, “natural” community structure. Perhaps the most famous benchmark graph is Zachary’s Karate Club. It contains 34 nodes, representing members of a karate club whose interactions were monitored over a period of three years by researchers. Links in this graph connect individuals interacting outside club activities, a proxy for social ties.\nDuring the course of the study, a conflict between the instructor Mr. Hi (node 0) and the president, or Officer (node 33) led to a split of the club into separate groups led by Mr. Hi and Officer. In this case we know whom each member of the group followed after the split, providing empirical community labels: those members who followed Mr. Hi are said to be one community and those following the Officer make up the other.\nFor this graph, we assume that the post-split group composition was largely driven by the social ties: members of the same friend groups would want to be part of the same club after the split. We thus expect a good community-detection algorithm to predict the post-split group composition with high accuracy.\nZachary’s karate club is such a popular benchmark graph that it has its own function in NetworkX:\n\nK = nx.karate_club_graph()\nnx.draw(K, with_labels=True)\n\n\n\n\n\n\n\n\nEach node in a NetworkX graph has a dictionary of attributes associated with it. This dictionary can hold arbitrary data about a node. We can get the attributes for a single node by giving the node name to the nodes object.\nEach node in this graph has a 'club' attribute, indicating whether the member followed the instructor or the president after the split:\n\nK.nodes[0]\n\n{'club': 'Mr. Hi'}\n\n\n\nK.nodes[9]\n\n{'club': 'Officer'}\n\n\nWe can visualize these labels by coloring each node according to its 'club' attribute:\n\nK = nx.karate_club_graph()\nclub_color = {\n    \"Mr. Hi\": \"orange\",\n    \"Officer\": \"lightblue\",\n}\nnode_colors = [club_color[K.nodes[n][\"club\"]] for n in K.nodes]\nnx.draw(K, node_color=node_colors, with_labels=True)\n\n\n\n\n\n\n\n\nThis separation looks good, in that there are relatively few inter-community links as opposed to intra-community links. Let’s create a graph partition based on these labels and measure its modularity.\nWe can do this by creating a dictionary of two sets, one for each value of the nodes’ 'club' attribute, then assigning the nodes to the corresponding set.\n\ngroups = {\n    \"Mr. Hi\": set(),\n    \"Officer\": set(),\n}\n\nfor n in K.nodes:\n    club = K.nodes[n][\"club\"]\n    groups[club].add(n)\n\ngroups\n\n{'Mr. Hi': {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21},\n 'Officer': {9,\n  14,\n  15,\n  18,\n  20,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33}}\n\n\nBy using the dictionary’s .values() method, we can get a list of sets that define our partition:\n\nempirical_partition = list(groups.values())\nempirical_partition\n\n[{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21},\n {9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33}]\n\n\n\nnx.community.is_partition(K, empirical_partition)\n\nTrue\n\n\nSince our partition is indeed a valid partition, we can get the modularity of this partition:\n\nnx.community.quality.modularity(K, empirical_partition)\n\n0.39143756676224206\n\n\nThis is a relatively high modularity, which is what we expect.\n\n\nFor the sake of comparison, let’s generate a random partition of this network and check its modularity. We would expect a modularity close to zero in this case.\nFirst we generate a sample of 17 nodes, half the total number of nodes, and assign them to one community. Our second community then includes the nodes in the graph not in the first community. We can use some set arithmetic to do this concisely:\n\nrandom_nodes = random.sample(sorted(K.nodes), 17)\nrandom_partition = [set(random_nodes), set(K.nodes) - set(random_nodes)]\nrandom_partition\n\n[{6, 8, 9, 10, 11, 12, 13, 14, 15, 18, 19, 20, 22, 25, 28, 29, 32},\n {0, 1, 2, 3, 4, 5, 7, 16, 17, 21, 23, 24, 26, 27, 30, 31, 33}]\n\n\nWe can visualize this partition and observe that the communities are much less natural-looking, as we would expect from a random assignment.\n\nrandom_node_colors = [\"orange\" if n in random_nodes else \"lightblue\" for n in K.nodes]\nnx.draw(K, node_color=random_node_colors)\n\n\n\n\n\n\n\n\nAnd finally we can test the modularity of this partition:\n\nnx.community.quality.modularity(K, random_partition)\n\n-0.09059987631416207\n\n\nSince this is a random process the modularity won’t be exactly zero, but it should be fairly close. Go ahead and repeat the process of generating a random partition and testing its modularity – it will fluctuate around its mean value of zero."
  },
  {
    "objectID": "references/networkx_indiana/5-networkx-partitions.html#girvan-newman-clustering",
    "href": "references/networkx_indiana/5-networkx-partitions.html#girvan-newman-clustering",
    "title": "NetworkX - Partitions",
    "section": "",
    "text": "Recall from the text the Girvan-Newman clustering algorithm:\n\nCreate a partition sequence\nCalculate the betweenness centrality for all links.\nRemove the link with largest betweenness and create a partition using connected components.\nRecalculate the betweenness centrality of the links of the resulting graph.\nRepeat from step B until no links remain.\nEvaluate each partition in the sequence and choose the one with the highest modularity.\n\nDuring this process, the number of connected components in the graph will increase monotonically as clusters are broken up. Since we are removing one link at a time, the number of connected components can increase by at most one between steps in the sequence – it’s not possible for a single edge to connect more than two nodes, and thus components.\nWe hope that the resulting partition of the graph will approximate its underlying community structure. We’ll use the Karate Club graph here because we know the ground-truth community labels and can compare the result obtained from the algorithm.\nnx.community.girvan_newman(G) will generate a sequence containing one partition of each size greater than one. Here we can see the first several are the same as those we generated:\n\nlist(nx.community.girvan_newman(G))[:5]\n\n[({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n  {2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33}),\n ({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n  {2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33},\n  {9}),\n ({0, 1, 3, 7, 11, 12, 13, 17, 19, 21},\n  {2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33},\n  {4, 5, 6, 10, 16},\n  {9}),\n ({0, 1, 3, 7, 11, 12, 13, 17, 19, 21},\n  {2, 24, 25, 27, 28, 31},\n  {4, 5, 6, 10, 16},\n  {8, 14, 15, 18, 20, 22, 23, 26, 29, 30, 32, 33},\n  {9}),\n ({0, 1, 3, 7, 12, 13, 17, 19, 21},\n  {2, 24, 25, 27, 28, 31},\n  {4, 5, 6, 10, 16},\n  {8, 14, 15, 18, 20, 22, 23, 26, 29, 30, 32, 33},\n  {9},\n  {11})]\n\n\nThe two cluster partition is:\n\ntwo_cluster_partition = next(nx.community.girvan_newman(G))\n\ntwo_cluster_partition\n\n({0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21},\n {2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33})\n\n\nHow good is this partition? We can get its modularity:\n\nnx.community.quality.modularity(G, two_cluster_partition)\n\n0.3476602762317048\n\n\nPretty good – comparable to the ground truth community labels. Let’s compare these side-by-side:\n\npos = nx.layout.spring_layout(G)\nfig = plt.figure(figsize=(15, 6))\n\nplt.subplot(1, 2, 1)\ntwo_cluster_partition = next(nx.community.girvan_newman(G))\nnode_colors = [0 if n in two_cluster_partition[0] else 1 for n in G.nodes()]\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Predicted communities\")\n\nplt.subplot(1, 2, 2)\nnode_colors = [G.nodes[n][\"club\"] == \"Officer\" for n in G.nodes()]\nnx.draw(G, with_labels=True, node_color=node_colors, pos=pos)\nplt.title(\"Actual communities\")\nplt.show()\n\nText(0.5, 1.0, 'Actual communities')\n\n\n\n\n\n\n\n\n\nWe can see that the predicted community labels are pretty accurate, only differing on a couple nodes that, visually, seem like they could plausibly beling to either group. Zachary’s original paper even explains the practical considerations of one of these mispredicted nodes: student 8 was very near receiving his black belt from Mr. Hi and thus did not want to leave the group even though several of his friends did.\n\nG.nodes[8]\n\n{'club': 'Mr. Hi'}"
  },
  {
    "objectID": "references/networkx_indiana/4-networkx-generating.html",
    "href": "references/networkx_indiana/4-networkx-generating.html",
    "title": "NetworkX - Generating Graphs",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nContents:\n\nRandom network model\nSmall-World model\nPreferential attachment model\n\nFor each of the models presented in this tutorial, we present the algorithm, and the corresponding NetworkX code function to generate the model.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\nThe random network model, as formulated by Gilbert, has two parameters: the number of nodes \\(N\\), and the link probability \\(p\\). As in the book text, the algorithm for creating this network is as follows:\n\nSelect a pair of nodes, say i and j.\nGenerate a random number r between 0 and 1. If r &lt; p, then add a link between i and j.\nRepeat (1) and (2) for all pairs of nodes.\n\n\n# Gilbert random graph with n=10 nodes and p=0.3\nG = nx.gnp_random_graph(n=10, p=0.3)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nInstead of specifying the link probability \\(p\\), we can also generate a graph of \\(N\\) nodes with exactly \\(M\\) edges by using random.sample() to choose M of the possible edges generated with itertools.combinations():\n\n# Erdos-Renyi graph with n nodes and m edges\nG = nx.gnm_random_graph(n=10, m=20)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe algorithm for generating a small-world network is as such:\n\nBegin with a ring of \\(N\\) nodes\nConnect each node to its \\(k\\) nearest neighbors (or \\(k-1\\) if k is odd).\nFor each edge \\((u, v)\\), with probability \\(p\\), replace edge \\((u, v)\\) with \\((u, w)\\) where \\(w\\) is not a neighbor of \\(u\\).\n\n\n# Watts-Strogatz small-world graph with n=16 nodes, k=4 neighbors, and p=0.2\nG = nx.watts_strogatz_graph(n=16, k=4, p=0.2)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nThe Barabási-Albert preferential attachment model has two parameters: the number of nodes \\(N\\), and the number of links added at each step \\(m\\). Given these parameters, the algorithm is as follows:\n\nStart with a clique of \\(m + 1\\) nodes.\nSelect \\(m\\) different nodes at random, weighted by their degree.\nAdd a new node \\(i\\) and link it with the \\(m\\) nodes from the previous step.\nRepeat 2-3 until there are N nodes in the graph.\n\n\n# Barabasi-Albert preferential attachment graph with n=10 nodes and m=2 edges\nG = nx.barabasi_albert_graph(n=10, m=2)\n\nnx.draw(G, with_labels=True)\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/4-networkx-generating.html#random-network-model",
    "href": "references/networkx_indiana/4-networkx-generating.html#random-network-model",
    "title": "NetworkX - Generating Graphs",
    "section": "",
    "text": "The random network model, as formulated by Gilbert, has two parameters: the number of nodes \\(N\\), and the link probability \\(p\\). As in the book text, the algorithm for creating this network is as follows:\n\nSelect a pair of nodes, say i and j.\nGenerate a random number r between 0 and 1. If r &lt; p, then add a link between i and j.\nRepeat (1) and (2) for all pairs of nodes.\n\n\n# Gilbert random graph with n=10 nodes and p=0.3\nG = nx.gnp_random_graph(n=10, p=0.3)\n\nnx.draw(G, with_labels=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nInstead of specifying the link probability \\(p\\), we can also generate a graph of \\(N\\) nodes with exactly \\(M\\) edges by using random.sample() to choose M of the possible edges generated with itertools.combinations():\n\n# Erdos-Renyi graph with n nodes and m edges\nG = nx.gnm_random_graph(n=10, m=20)\n\nnx.draw(G, with_labels=True)\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/4-networkx-generating.html#small-world-model",
    "href": "references/networkx_indiana/4-networkx-generating.html#small-world-model",
    "title": "NetworkX - Generating Graphs",
    "section": "",
    "text": "The algorithm for generating a small-world network is as such:\n\nBegin with a ring of \\(N\\) nodes\nConnect each node to its \\(k\\) nearest neighbors (or \\(k-1\\) if k is odd).\nFor each edge \\((u, v)\\), with probability \\(p\\), replace edge \\((u, v)\\) with \\((u, w)\\) where \\(w\\) is not a neighbor of \\(u\\).\n\n\n# Watts-Strogatz small-world graph with n=16 nodes, k=4 neighbors, and p=0.2\nG = nx.watts_strogatz_graph(n=16, k=4, p=0.2)\n\nnx.draw(G, with_labels=True)\nplt.show()"
  },
  {
    "objectID": "references/networkx_indiana/4-networkx-generating.html#preferential-attachment-model",
    "href": "references/networkx_indiana/4-networkx-generating.html#preferential-attachment-model",
    "title": "NetworkX - Generating Graphs",
    "section": "",
    "text": "The Barabási-Albert preferential attachment model has two parameters: the number of nodes \\(N\\), and the number of links added at each step \\(m\\). Given these parameters, the algorithm is as follows:\n\nStart with a clique of \\(m + 1\\) nodes.\nSelect \\(m\\) different nodes at random, weighted by their degree.\nAdd a new node \\(i\\) and link it with the \\(m\\) nodes from the previous step.\nRepeat 2-3 until there are N nodes in the graph.\n\n\n# Barabasi-Albert preferential attachment graph with n=10 nodes and m=2 edges\nG = nx.barabasi_albert_graph(n=10, m=2)\n\nnx.draw(G, with_labels=True)\nplt.show()"
  },
  {
    "objectID": "references/networkx_kaggle/6-networkx-community-detection.html",
    "href": "references/networkx_kaggle/6-networkx-community-detection.html",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\n\n\n# karate club network\ngraph_karate = nx.karate_club_graph()\n\n# compute the communities using the Label Propagation algorithm\ncommunities = nx.algorithms.community.label_propagation.label_propagation_communities(\n    graph_karate\n)\n\n# print the communities\nfor i, c in enumerate(communities):\n    print(f\"Community {i}: {c}\")\n\nCommunity 0: {0, 1, 3, 4, 7, 10, 11, 12, 13, 17, 19, 21, 24, 25, 31}\nCommunity 1: {32, 33, 2, 8, 9, 14, 15, 18, 20, 22, 23, 26, 27, 28, 29, 30}\nCommunity 2: {16, 5, 6}\n\n\n\n# create a node color list based on the partition\n\nnode_colors = []\nfor n in graph_karate.nodes():\n    if n in list(communities)[0]:\n        node_colors.append(1)\n    elif n in list(communities)[1]:\n        node_colors.append(2)\n    else:\n        node_colors.append(3)\n\n# draw the graph with node colors based on the partition\npos = nx.spring_layout(graph_karate)\nnx.draw(\n    graph_karate,\n    pos,\n    node_color=node_colors,\n    cmap=plt.cm.get_cmap(\"viridis\"),\n    with_labels=True,\n)\nplt.show()\n\nC:\\Users\\Daniel\\AppData\\Local\\Temp\\ipykernel_7324\\3742204271.py:18: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n  cmap=plt.cm.get_cmap(\"viridis\"),"
  },
  {
    "objectID": "references/networkx_kaggle/6-networkx-community-detection.html#installing-networkx",
    "href": "references/networkx_kaggle/6-networkx-community-detection.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx"
  },
  {
    "objectID": "references/networkx_kaggle/6-networkx-community-detection.html#community-detection",
    "href": "references/networkx_kaggle/6-networkx-community-detection.html#community-detection",
    "title": "NetworkX",
    "section": "",
    "text": "# karate club network\ngraph_karate = nx.karate_club_graph()\n\n# compute the communities using the Label Propagation algorithm\ncommunities = nx.algorithms.community.label_propagation.label_propagation_communities(\n    graph_karate\n)\n\n# print the communities\nfor i, c in enumerate(communities):\n    print(f\"Community {i}: {c}\")\n\nCommunity 0: {0, 1, 3, 4, 7, 10, 11, 12, 13, 17, 19, 21, 24, 25, 31}\nCommunity 1: {32, 33, 2, 8, 9, 14, 15, 18, 20, 22, 23, 26, 27, 28, 29, 30}\nCommunity 2: {16, 5, 6}\n\n\n\n# create a node color list based on the partition\n\nnode_colors = []\nfor n in graph_karate.nodes():\n    if n in list(communities)[0]:\n        node_colors.append(1)\n    elif n in list(communities)[1]:\n        node_colors.append(2)\n    else:\n        node_colors.append(3)\n\n# draw the graph with node colors based on the partition\npos = nx.spring_layout(graph_karate)\nnx.draw(\n    graph_karate,\n    pos,\n    node_color=node_colors,\n    cmap=plt.cm.get_cmap(\"viridis\"),\n    with_labels=True,\n)\nplt.show()\n\nC:\\Users\\Daniel\\AppData\\Local\\Temp\\ipykernel_7324\\3742204271.py:18: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n  cmap=plt.cm.get_cmap(\"viridis\"),"
  },
  {
    "objectID": "references/networkx_kaggle/2-networkx-files.html",
    "href": "references/networkx_kaggle/2-networkx-files.html",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport networkx as nx\nimport numpy as np\n\n\n\n\n\n\n\ngraph = nx.read_edgelist(\"../../data/sample1.txt\")\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nAn adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.\n\ngraph_mat = np.array(\n    [\n        [0, 1, 1, 1, 0, 1, 0, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],\n        [1, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    ]\n)\ngraph_mat\n\narray([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],\n       [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],\n       [1, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]])\n\n\nConverting the adjacency matrix to a networkx graph using nx.Graph:\n\ngraphG = nx.Graph(graph_mat)\nnx.draw_networkx(graph)\n\n\n\n\n\n\n\n\nTo import from an adjacency matrix file:\n\nadj_matrix = np.loadtxt(\"../../data/sample2.txt\")\n\ngraph = nx.Graph()\n\n# adding edges\nfor i in range(adj_matrix.shape[0]):\n    for j in range(adj_matrix.shape[1]):\n        if adj_matrix[i][j] == 1:\n            graph.add_edge(i, j)\n\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nIf you have a network file in the GEXF format, which is a popular format for exchanging graph data between different software packages, you can import it into a NetworkX graph using the read_gexf function as follows:\n\ngraph = nx.read_gexf(\"../../data/sample3.gexf\")\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\nSave the graph as a GEXF file:\n\nnx.write_gexf(graph, \"../../data/sample3.gexf\")"
  },
  {
    "objectID": "references/networkx_kaggle/2-networkx-files.html#installing-networkx",
    "href": "references/networkx_kaggle/2-networkx-files.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport networkx as nx\nimport numpy as np"
  },
  {
    "objectID": "references/networkx_kaggle/2-networkx-files.html#importing-network-information",
    "href": "references/networkx_kaggle/2-networkx-files.html#importing-network-information",
    "title": "NetworkX",
    "section": "",
    "text": "graph = nx.read_edgelist(\"../../data/sample1.txt\")\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nAn adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.\n\ngraph_mat = np.array(\n    [\n        [0, 1, 1, 1, 0, 1, 0, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],\n        [1, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    ]\n)\ngraph_mat\n\narray([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],\n       [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],\n       [1, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]])\n\n\nConverting the adjacency matrix to a networkx graph using nx.Graph:\n\ngraphG = nx.Graph(graph_mat)\nnx.draw_networkx(graph)\n\n\n\n\n\n\n\n\nTo import from an adjacency matrix file:\n\nadj_matrix = np.loadtxt(\"../../data/sample2.txt\")\n\ngraph = nx.Graph()\n\n# adding edges\nfor i in range(adj_matrix.shape[0]):\n    for j in range(adj_matrix.shape[1]):\n        if adj_matrix[i][j] == 1:\n            graph.add_edge(i, j)\n\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nIf you have a network file in the GEXF format, which is a popular format for exchanging graph data between different software packages, you can import it into a NetworkX graph using the read_gexf function as follows:\n\ngraph = nx.read_gexf(\"../../data/sample3.gexf\")\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\nSave the graph as a GEXF file:\n\nnx.write_gexf(graph, \"../../data/sample3.gexf\")"
  },
  {
    "objectID": "references/networkx_kaggle/1-networkx-types.html",
    "href": "references/networkx_kaggle/1-networkx-types.html",
    "title": "NetworkX",
    "section": "",
    "text": "NetworkX is a Python library for working with graphs or networks. It provides tools for creating, manipulating, and analyzing complex networks.\nNetworkX is widely used in various fields, including:\n\nSocial network analysis\nBiology\nPhysics\nComputer science\n\nIt is an open-source library, which means that it is free to use, modify, and distribute.\nThese notebooks are based on the following tutorial from Kaggle: https://www.kaggle.com/code/alireza151/networkx-tutorial\n\n\nIf you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\nfrom networkx.algorithms import bipartite\n\n\n\n\n\n\nA network or graph is a collection of nodes (vertices) and edges (links between nodes).\nA simple network is a network where the edges are undirected and unweighted. We will understand these two concepts later.\nTo create a simple network, we can use the Graph class from NetworkX.\n\n# We initialize an empty graph\ngraph = nx.Graph()\n\n# We add an edge between node A and node B\n# As these nodes do not exist yet, they will be created\ngraph.add_edge(\"A\", \"B\")\n\n# Networkx library can be used to visualize the graph\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nThe weight of an edge is a number assigned to the edge, which can represent a distance, a cost, a capacity, or any other quantity.\nA weighted graph is a graph in which a number (the weight) is assigned to each edge.\n\n# Initialize an empty graph\ngraph_weighted = nx.Graph()\n\n# Add several edges, and specify the weight of each edge\ngraph_weighted.add_edge(\"A\", \"B\", weight=6)\ngraph_weighted.add_edge(\"A\", \"D\", weight=3)\ngraph_weighted.add_edge(\"A\", \"C\", weight=0.5)\ngraph_weighted.add_edge(\"B\", \"D\", weight=1)\n\n# Draw the nodes with labels\nnx.draw(graph_weighted, with_labels=True)\n\n\n\n\n\n\n\n\nThe method edges() of the graph object returns a list of tuples\nEach tuple represents an edge, and contains the names of the nodes it connects.\n\nlist(graph_weighted.edges())\n\n[('A', 'B'), ('A', 'D'), ('A', 'C'), ('B', 'D')]\n\n\nAlternatively, you can use the argument edges(data=True) to return a list of tuples, where each tuple contains the names of the nodes and a dictionary with the edge attributes.\n\nlist(graph_weighted.edges(data=True))\n\n[('A', 'B', {'weight': 6}),\n ('A', 'D', {'weight': 3}),\n ('A', 'C', {'weight': 0.5}),\n ('B', 'D', {'weight': 1})]\n\n\nWe can also index the edges by using the node names. This way, we can access the attributes of a specific edge.\n\ngraph_weighted.edges[\"A\", \"B\"]\n\n{'weight': 6}\n\n\n\ngraph_weighted.edges[\"A\", \"B\"][\"weight\"]\n\n6\n\n\n\n\n\nGraph edges can have a direction. This means that the edge goes from one node to another, and not necessarily in the opposite direction.\nIn this case, the graph is called a directed graph or digraph.\n\n# Initialize an empty directed graph\ngraph_di = nx.DiGraph()\n\n# Add several edges, and specify the weight of each edge\n# In this case, the order of the nodes matters\ngraph_di.add_edge(\"A\", \"B\", weight=1)  # A -&gt; B\ngraph_di.add_edge(\"A\", \"D\", weight=3)  # A -&gt; D\ngraph_di.add_edge(\"A\", \"C\", weight=1)  # A -&gt; C\ngraph_di.add_edge(\"B\", \"D\", weight=2)  # B -&gt; D\n\n# Draw the nodes with labels\nnx.draw(graph_weighted, with_labels=True)\n\n\n\n\n\n\n\n\nAs you can see, the library does not plot the edge direction by default. In order to plot the edge direction, we need to use the nx.draw_networkx_edges() function, which requires us to specify the position of the nodes in the 2D plane.\nFirst, we can call the nx.spring_layout() function to get the positions of the nodes. This function returns a dictionary where the keys are the node names and the values are the 2D coordinates of the nodes. There are many other layout functions, listed at the end of this subsection.\n\n# Create a dictionary of positions for the nodes\npos = nx.spring_layout(graph_di)\n\nprint(pos)\n\n{'A': array([-0.03291149,  0.00235939]), 'B': array([0.03616769, 0.48347818]), 'D': array([-0.20513248,  0.51416242]), 'C': array([ 0.20187628, -1.        ])}\n\n\nThen, we can pass this dictionary to the nx.draw_networkx_edges() function, along with the graph object and the edge list.\nWe will also need to specify the edge labels, which can be done with the nx.draw_networkx_edge_labels() function.\n\n# Draw the graph\nnx.draw_networkx_nodes(graph_di, pos)\nnx.draw_networkx_edges(graph_di, pos)\nnx.draw_networkx_labels(graph_di, pos)\n\n# Create a dictionary of edge labels\nedge_labels = {(u, v): d[\"weight\"] for u, v, d in graph_di.edges(data=True)}\n\n# Draw the edge labels\nnx.draw_networkx_edge_labels(graph_di, pos, edge_labels=edge_labels)\n\n# Show the plot\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\nIn NetworkX, there are several layout algorithms that can be used to position the nodes of a graph in a visualization, including:\n\nnx.spring_layout(): This algorithm uses a force-directed approach to layout the nodes. Nodes that are connected by edges are attracted to each other, while nodes that are not connected are repelled. The algorithm tries to minimize the energy of the system by adjusting the position of the nodes.\nnx.circular_layout(): This algorithm positions the nodes evenly around a circle.\nnx.spectral_layout(): This algorithm uses the eigenvectors of the graph’s adjacency matrix to position the nodes. The eigenvectors are used to project the nodes into a lower-dimensional space, and the positions of the nodes are then determined by optimizing a cost function.\nnx.random_layout(): This algorithm positions the nodes randomly in a given bounding box.\nnx.shell_layout(): This algorithm positions the nodes in concentric circles or shells, with nodes in the same shell having the same distance to the center.\nnx.kamada_kawai_layout(): This algorithm uses an iterative optimization approach to layout the nodes. The algorithm tries to minimize the stress of the system by adjusting the position of the nodes.\nnx.fruchterman_reingold_layout(): This algorithm is a variation of the nx.spring_layout() algorithm, and also uses a force-directed approach to layout the nodes.\n\nEach layout algorithm has its strengths and weaknesses, and the best one to use depends on the characteristics of the graph and the goals of the visualization. NetworkX allows you to easily apply these layout algorithms to your graphs and create visualizations that help you understand and communicate the structure of the network.\n\n\n\nA signed network is a network in which the edges have a sign, which can be positive or negative.\n\n# Initialize an empty graph\ngraph_signed = nx.Graph()\n\n# Add several edges, and specify the sign of each edge\ngraph_signed.add_edge(\"A\", \"B\", sign=\"*\")\ngraph_signed.add_edge(\"A\", \"C\", sign=\"-\")\ngraph_signed.add_edge(\"A\", \"d\", sign=\"+\")\n\n# Choose a layout for the nodes\npos = nx.random_layout(graph_signed)\n\n# Create a dictionary of edge colors based on the sign of each edge\nedge_colors = {\"+\": \"green\", \"-\": \"red\", \"*\": \"black\"}\ncolors = [edge_colors[graph_signed[u][v][\"sign\"]] for u, v in graph_signed.edges()]\n\n# Create a dictionary of edge styles based on the sign of each edge\nedge_styles = {\"+\": \"solid\", \"-\": \"dashed\", \"*\": \"dashed\"}\nstyles = [edge_styles[graph_signed[u][v][\"sign\"]] for u, v in graph_signed.edges()]\n\n# Draw the graph with colored and styled edges\nnx.draw_networkx_nodes(graph_signed, pos, node_color=\"blue\")\nnx.draw_networkx_edges(graph_signed, pos, edge_color=colors, style=styles)\nnx.draw_networkx_labels(graph_signed, pos)\n\n# Show the plot\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nA MultiGraph is a type of graph in NetworkX that allows multiple edges between a pair of nodes. In other words, a MultiGraph can have parallel edges, while a standard Graph can only have a single edge between any pair of nodes.\nIn simpler terms, a MultiGraph is a network where multiple edges can connect the same nodes.\n\n# Initialize an empty multigraph\ngraph_multi = nx.MultiGraph()\n\n# Add several edges, and specify the relation and weight of each edge\ngraph_multi.add_edge(\"A\", \"B\", relation=\"family\", weight=1)\ngraph_multi.add_edge(\"A\", \"C\", relation=\"family\", weight=2)\ngraph_multi.add_edge(\"A\", \"B\", relation=\"Work\", weight=3)\ngraph_multi.add_edge(\"D\", \"B\", relation=\"Work\", weight=1)\ngraph_multi.add_edge(\"B\", \"E\", relation=\"Friend\", weight=2)\n\nnx.draw(graph_multi, with_labels=True)\n\n\n\n\n\n\n\n\nFor a better visualization of the multigraph, we can use the nx.draw_networkx_edges() function, as we did for the directed graph.\n\n# Decide on a layout for the nodes\npos = nx.spring_layout(graph_multi)\n\n# Draw the nodes\nnx.draw_networkx_nodes(graph_multi, pos, node_color=\"lightblue\", node_size=500)\n\n# Draw the edges\nedge_labels = {}\nfor u, v, d in graph_multi.edges(data=True):\n    if (u, v) in edge_labels:\n        edge_labels[(u, v)] += \"\\n\" + d[\"relation\"] + \": \" + str(d[\"weight\"])\n    else:\n        edge_labels[(u, v)] = d[\"relation\"] + \": \" + str(d[\"weight\"])\n\nnx.draw_networkx_edge_labels(graph_multi, pos, edge_labels=edge_labels)\nnx.draw_networkx_edges(graph_multi, pos, width=1, alpha=0.7)\n\n# Draw the labels\nnx.draw_networkx_labels(graph_multi, pos, font_size=10, font_family=\"sans-serif\")\n\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\nWe can list the edges of a multigraph using the edges() method, same as we did for the simple graph.\n\nlist(graph_multi.edges())\n\n[('A', 'B'), ('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E')]\n\n\nSimilarly, we can list the edges with their attributes by using the edges(data=True) method.\n\nlist(graph_multi.edges(data=True))\n\n[('A', 'B', {'relation': 'family', 'weight': 1}),\n ('A', 'B', {'relation': 'Work', 'weight': 3}),\n ('A', 'C', {'relation': 'family', 'weight': 2}),\n ('B', 'D', {'relation': 'Work', 'weight': 1}),\n ('B', 'E', {'relation': 'Friend', 'weight': 2})]\n\n\nIf instead of True we pass a string, we can access that attribute of the edges.\n\nlist(graph_multi.edges(data=\"relation\"))\n\n[('A', 'B', 'family'),\n ('A', 'B', 'Work'),\n ('A', 'C', 'family'),\n ('B', 'D', 'Work'),\n ('B', 'E', 'Friend')]\n\n\nHowever, contrary to simple graphs, we cannot index the edges by using the node names.\n\n# graph_multi.edges[\"A\", \"B\"]  # error\n\nInstead, we need to index by the edge key.\n\ndict(graph_multi[\"A\"][\"B\"])\n\n{0: {'relation': 'family', 'weight': 1}, 1: {'relation': 'Work', 'weight': 3}}\n\n\nWe can get all the edges related to a specific node by using the edges() method with the node name as an argument.\n\nlist(graph_multi.edges(\"B\"))\n\n[('B', 'A'), ('B', 'A'), ('B', 'D'), ('B', 'E')]\n\n\nExercise. Get the relation of nodes “A” and “B” in the multigraph.\n\ngraph_multi[\"A\"][\"B\"][0][\"relation\"]\n\n'family'\n\n\n\n\n\nA bipartite graph is a type of graph in which the nodes can be divided into two disjoint sets, such that all edges connect a node from one set to a node in the other set. In other words, there are no edges that connect nodes within the same set.\nBipartite graphs are useful for modeling relationships between two different types of entities, such as buyers and sellers in a market, or actors and movies in a film industry.\nIn NetworkX, you can create and manipulate bipartite graphs using the bipartite module, which provides various functions and algorithms for bipartite graphs. Additionally, there are several visualization techniques that can be used to display bipartite graphs, such as the bipartite layout, which arranges the nodes in two distinct rows.\nstockholders and stocks Example:\n\n# List of stockholders\nstockholders = [\n    \"Alice\",\n    \"Bob\",\n    \"Charlie\",\n    \"David\",\n    \"Eve\",\n    \"Frank\",\n    \"Grace\",\n    \"Harry\",\n    \"Ivy\",\n    \"John\",\n]\n\n# List of stocks\nstocks = [\"AAPL\", \"GOOG\", \"TSLA\", \"AMZN\", \"FB\", \"MSFT\", \"NVDA\", \"PYPL\", \"NFLX\", \"TWTR\"]\n\n# Create a bipartite graph\ngraph_bipartite = nx.Graph()\n\n# Adding nodes from list\ngraph_bipartite.add_nodes_from(stockholders, bipartite=0)\ngraph_bipartite.add_nodes_from(stocks, bipartite=1)\n\n# Adding edges randomly until the graph is connected\nwhile not nx.is_connected(graph_bipartite):\n    graph_bipartite.add_edge(random.choice(stockholders), random.choice(stocks))\n\n# Draw the bipartite graph\npos = nx.bipartite_layout(graph_bipartite, stockholders)\nnx.draw(graph_bipartite, pos, with_labels=True)\n\n# show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# Two sets of a bipartite network\nbipartite.sets(graph_bipartite)\n\n({'Alice',\n  'Bob',\n  'Charlie',\n  'David',\n  'Eve',\n  'Frank',\n  'Grace',\n  'Harry',\n  'Ivy',\n  'John'},\n {'AAPL',\n  'AMZN',\n  'FB',\n  'GOOG',\n  'MSFT',\n  'NFLX',\n  'NVDA',\n  'PYPL',\n  'TSLA',\n  'TWTR'})\n\n\n\n# L-partite graph (stockholders)\n# L=left , R=right\n\n# 2 stockholders that have a stock in common are connected\n\n# L-partite graph\ngraph_projected = bipartite.projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# R-partite graph\ngraph_projected = bipartite.projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[1]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# A wighted L-partite\n# how many in common\ngraph_projected = bipartite.weighted_projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# better visualization\ngraph_projected = bipartite.weighted_projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\npos = nx.circular_layout(graph_projected)\n\n# draw the graph\nnx.draw_networkx_nodes(graph_projected, pos)\nnx.draw_networkx_edges(graph_projected, pos)\nnx.draw_networkx_labels(graph_projected, pos)\n\n# create a dictionary of edge labels\nedge_labels = {(u, v): d[\"weight\"] for u, v, d in graph_projected.edges(data=True)}\n\n# draw the edge labels\nnx.draw_networkx_edge_labels(graph_projected, pos, edge_labels=edge_labels)\n\n# show the plot\nplt.figure(figsize=(50, 30))\nplt.show()\n\n\n\n\n\n\n\n\n&lt;Figure size 5000x3000 with 0 Axes&gt;"
  },
  {
    "objectID": "references/networkx_kaggle/1-networkx-types.html#installing-networkx",
    "href": "references/networkx_kaggle/1-networkx-types.html#installing-networkx",
    "title": "NetworkX",
    "section": "",
    "text": "If you are running this notebook online (in Google Colaboratory, for example), you can install NetworkX by running the following command:\n\n# !pip install networkx\n\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\nfrom networkx.algorithms import bipartite"
  },
  {
    "objectID": "references/networkx_kaggle/1-networkx-types.html#types-of-networks",
    "href": "references/networkx_kaggle/1-networkx-types.html#types-of-networks",
    "title": "NetworkX",
    "section": "",
    "text": "A network or graph is a collection of nodes (vertices) and edges (links between nodes).\nA simple network is a network where the edges are undirected and unweighted. We will understand these two concepts later.\nTo create a simple network, we can use the Graph class from NetworkX.\n\n# We initialize an empty graph\ngraph = nx.Graph()\n\n# We add an edge between node A and node B\n# As these nodes do not exist yet, they will be created\ngraph.add_edge(\"A\", \"B\")\n\n# Networkx library can be used to visualize the graph\nnx.draw(graph, with_labels=True)\n\n\n\n\n\n\n\n\n\n\n\nThe weight of an edge is a number assigned to the edge, which can represent a distance, a cost, a capacity, or any other quantity.\nA weighted graph is a graph in which a number (the weight) is assigned to each edge.\n\n# Initialize an empty graph\ngraph_weighted = nx.Graph()\n\n# Add several edges, and specify the weight of each edge\ngraph_weighted.add_edge(\"A\", \"B\", weight=6)\ngraph_weighted.add_edge(\"A\", \"D\", weight=3)\ngraph_weighted.add_edge(\"A\", \"C\", weight=0.5)\ngraph_weighted.add_edge(\"B\", \"D\", weight=1)\n\n# Draw the nodes with labels\nnx.draw(graph_weighted, with_labels=True)\n\n\n\n\n\n\n\n\nThe method edges() of the graph object returns a list of tuples\nEach tuple represents an edge, and contains the names of the nodes it connects.\n\nlist(graph_weighted.edges())\n\n[('A', 'B'), ('A', 'D'), ('A', 'C'), ('B', 'D')]\n\n\nAlternatively, you can use the argument edges(data=True) to return a list of tuples, where each tuple contains the names of the nodes and a dictionary with the edge attributes.\n\nlist(graph_weighted.edges(data=True))\n\n[('A', 'B', {'weight': 6}),\n ('A', 'D', {'weight': 3}),\n ('A', 'C', {'weight': 0.5}),\n ('B', 'D', {'weight': 1})]\n\n\nWe can also index the edges by using the node names. This way, we can access the attributes of a specific edge.\n\ngraph_weighted.edges[\"A\", \"B\"]\n\n{'weight': 6}\n\n\n\ngraph_weighted.edges[\"A\", \"B\"][\"weight\"]\n\n6\n\n\n\n\n\nGraph edges can have a direction. This means that the edge goes from one node to another, and not necessarily in the opposite direction.\nIn this case, the graph is called a directed graph or digraph.\n\n# Initialize an empty directed graph\ngraph_di = nx.DiGraph()\n\n# Add several edges, and specify the weight of each edge\n# In this case, the order of the nodes matters\ngraph_di.add_edge(\"A\", \"B\", weight=1)  # A -&gt; B\ngraph_di.add_edge(\"A\", \"D\", weight=3)  # A -&gt; D\ngraph_di.add_edge(\"A\", \"C\", weight=1)  # A -&gt; C\ngraph_di.add_edge(\"B\", \"D\", weight=2)  # B -&gt; D\n\n# Draw the nodes with labels\nnx.draw(graph_weighted, with_labels=True)\n\n\n\n\n\n\n\n\nAs you can see, the library does not plot the edge direction by default. In order to plot the edge direction, we need to use the nx.draw_networkx_edges() function, which requires us to specify the position of the nodes in the 2D plane.\nFirst, we can call the nx.spring_layout() function to get the positions of the nodes. This function returns a dictionary where the keys are the node names and the values are the 2D coordinates of the nodes. There are many other layout functions, listed at the end of this subsection.\n\n# Create a dictionary of positions for the nodes\npos = nx.spring_layout(graph_di)\n\nprint(pos)\n\n{'A': array([-0.03291149,  0.00235939]), 'B': array([0.03616769, 0.48347818]), 'D': array([-0.20513248,  0.51416242]), 'C': array([ 0.20187628, -1.        ])}\n\n\nThen, we can pass this dictionary to the nx.draw_networkx_edges() function, along with the graph object and the edge list.\nWe will also need to specify the edge labels, which can be done with the nx.draw_networkx_edge_labels() function.\n\n# Draw the graph\nnx.draw_networkx_nodes(graph_di, pos)\nnx.draw_networkx_edges(graph_di, pos)\nnx.draw_networkx_labels(graph_di, pos)\n\n# Create a dictionary of edge labels\nedge_labels = {(u, v): d[\"weight\"] for u, v, d in graph_di.edges(data=True)}\n\n# Draw the edge labels\nnx.draw_networkx_edge_labels(graph_di, pos, edge_labels=edge_labels)\n\n# Show the plot\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\nIn NetworkX, there are several layout algorithms that can be used to position the nodes of a graph in a visualization, including:\n\nnx.spring_layout(): This algorithm uses a force-directed approach to layout the nodes. Nodes that are connected by edges are attracted to each other, while nodes that are not connected are repelled. The algorithm tries to minimize the energy of the system by adjusting the position of the nodes.\nnx.circular_layout(): This algorithm positions the nodes evenly around a circle.\nnx.spectral_layout(): This algorithm uses the eigenvectors of the graph’s adjacency matrix to position the nodes. The eigenvectors are used to project the nodes into a lower-dimensional space, and the positions of the nodes are then determined by optimizing a cost function.\nnx.random_layout(): This algorithm positions the nodes randomly in a given bounding box.\nnx.shell_layout(): This algorithm positions the nodes in concentric circles or shells, with nodes in the same shell having the same distance to the center.\nnx.kamada_kawai_layout(): This algorithm uses an iterative optimization approach to layout the nodes. The algorithm tries to minimize the stress of the system by adjusting the position of the nodes.\nnx.fruchterman_reingold_layout(): This algorithm is a variation of the nx.spring_layout() algorithm, and also uses a force-directed approach to layout the nodes.\n\nEach layout algorithm has its strengths and weaknesses, and the best one to use depends on the characteristics of the graph and the goals of the visualization. NetworkX allows you to easily apply these layout algorithms to your graphs and create visualizations that help you understand and communicate the structure of the network.\n\n\n\nA signed network is a network in which the edges have a sign, which can be positive or negative.\n\n# Initialize an empty graph\ngraph_signed = nx.Graph()\n\n# Add several edges, and specify the sign of each edge\ngraph_signed.add_edge(\"A\", \"B\", sign=\"*\")\ngraph_signed.add_edge(\"A\", \"C\", sign=\"-\")\ngraph_signed.add_edge(\"A\", \"d\", sign=\"+\")\n\n# Choose a layout for the nodes\npos = nx.random_layout(graph_signed)\n\n# Create a dictionary of edge colors based on the sign of each edge\nedge_colors = {\"+\": \"green\", \"-\": \"red\", \"*\": \"black\"}\ncolors = [edge_colors[graph_signed[u][v][\"sign\"]] for u, v in graph_signed.edges()]\n\n# Create a dictionary of edge styles based on the sign of each edge\nedge_styles = {\"+\": \"solid\", \"-\": \"dashed\", \"*\": \"dashed\"}\nstyles = [edge_styles[graph_signed[u][v][\"sign\"]] for u, v in graph_signed.edges()]\n\n# Draw the graph with colored and styled edges\nnx.draw_networkx_nodes(graph_signed, pos, node_color=\"blue\")\nnx.draw_networkx_edges(graph_signed, pos, edge_color=colors, style=styles)\nnx.draw_networkx_labels(graph_signed, pos)\n\n# Show the plot\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nA MultiGraph is a type of graph in NetworkX that allows multiple edges between a pair of nodes. In other words, a MultiGraph can have parallel edges, while a standard Graph can only have a single edge between any pair of nodes.\nIn simpler terms, a MultiGraph is a network where multiple edges can connect the same nodes.\n\n# Initialize an empty multigraph\ngraph_multi = nx.MultiGraph()\n\n# Add several edges, and specify the relation and weight of each edge\ngraph_multi.add_edge(\"A\", \"B\", relation=\"family\", weight=1)\ngraph_multi.add_edge(\"A\", \"C\", relation=\"family\", weight=2)\ngraph_multi.add_edge(\"A\", \"B\", relation=\"Work\", weight=3)\ngraph_multi.add_edge(\"D\", \"B\", relation=\"Work\", weight=1)\ngraph_multi.add_edge(\"B\", \"E\", relation=\"Friend\", weight=2)\n\nnx.draw(graph_multi, with_labels=True)\n\n\n\n\n\n\n\n\nFor a better visualization of the multigraph, we can use the nx.draw_networkx_edges() function, as we did for the directed graph.\n\n# Decide on a layout for the nodes\npos = nx.spring_layout(graph_multi)\n\n# Draw the nodes\nnx.draw_networkx_nodes(graph_multi, pos, node_color=\"lightblue\", node_size=500)\n\n# Draw the edges\nedge_labels = {}\nfor u, v, d in graph_multi.edges(data=True):\n    if (u, v) in edge_labels:\n        edge_labels[(u, v)] += \"\\n\" + d[\"relation\"] + \": \" + str(d[\"weight\"])\n    else:\n        edge_labels[(u, v)] = d[\"relation\"] + \": \" + str(d[\"weight\"])\n\nnx.draw_networkx_edge_labels(graph_multi, pos, edge_labels=edge_labels)\nnx.draw_networkx_edges(graph_multi, pos, width=1, alpha=0.7)\n\n# Draw the labels\nnx.draw_networkx_labels(graph_multi, pos, font_size=10, font_family=\"sans-serif\")\n\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\nWe can list the edges of a multigraph using the edges() method, same as we did for the simple graph.\n\nlist(graph_multi.edges())\n\n[('A', 'B'), ('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E')]\n\n\nSimilarly, we can list the edges with their attributes by using the edges(data=True) method.\n\nlist(graph_multi.edges(data=True))\n\n[('A', 'B', {'relation': 'family', 'weight': 1}),\n ('A', 'B', {'relation': 'Work', 'weight': 3}),\n ('A', 'C', {'relation': 'family', 'weight': 2}),\n ('B', 'D', {'relation': 'Work', 'weight': 1}),\n ('B', 'E', {'relation': 'Friend', 'weight': 2})]\n\n\nIf instead of True we pass a string, we can access that attribute of the edges.\n\nlist(graph_multi.edges(data=\"relation\"))\n\n[('A', 'B', 'family'),\n ('A', 'B', 'Work'),\n ('A', 'C', 'family'),\n ('B', 'D', 'Work'),\n ('B', 'E', 'Friend')]\n\n\nHowever, contrary to simple graphs, we cannot index the edges by using the node names.\n\n# graph_multi.edges[\"A\", \"B\"]  # error\n\nInstead, we need to index by the edge key.\n\ndict(graph_multi[\"A\"][\"B\"])\n\n{0: {'relation': 'family', 'weight': 1}, 1: {'relation': 'Work', 'weight': 3}}\n\n\nWe can get all the edges related to a specific node by using the edges() method with the node name as an argument.\n\nlist(graph_multi.edges(\"B\"))\n\n[('B', 'A'), ('B', 'A'), ('B', 'D'), ('B', 'E')]\n\n\nExercise. Get the relation of nodes “A” and “B” in the multigraph.\n\ngraph_multi[\"A\"][\"B\"][0][\"relation\"]\n\n'family'\n\n\n\n\n\nA bipartite graph is a type of graph in which the nodes can be divided into two disjoint sets, such that all edges connect a node from one set to a node in the other set. In other words, there are no edges that connect nodes within the same set.\nBipartite graphs are useful for modeling relationships between two different types of entities, such as buyers and sellers in a market, or actors and movies in a film industry.\nIn NetworkX, you can create and manipulate bipartite graphs using the bipartite module, which provides various functions and algorithms for bipartite graphs. Additionally, there are several visualization techniques that can be used to display bipartite graphs, such as the bipartite layout, which arranges the nodes in two distinct rows.\nstockholders and stocks Example:\n\n# List of stockholders\nstockholders = [\n    \"Alice\",\n    \"Bob\",\n    \"Charlie\",\n    \"David\",\n    \"Eve\",\n    \"Frank\",\n    \"Grace\",\n    \"Harry\",\n    \"Ivy\",\n    \"John\",\n]\n\n# List of stocks\nstocks = [\"AAPL\", \"GOOG\", \"TSLA\", \"AMZN\", \"FB\", \"MSFT\", \"NVDA\", \"PYPL\", \"NFLX\", \"TWTR\"]\n\n# Create a bipartite graph\ngraph_bipartite = nx.Graph()\n\n# Adding nodes from list\ngraph_bipartite.add_nodes_from(stockholders, bipartite=0)\ngraph_bipartite.add_nodes_from(stocks, bipartite=1)\n\n# Adding edges randomly until the graph is connected\nwhile not nx.is_connected(graph_bipartite):\n    graph_bipartite.add_edge(random.choice(stockholders), random.choice(stocks))\n\n# Draw the bipartite graph\npos = nx.bipartite_layout(graph_bipartite, stockholders)\nnx.draw(graph_bipartite, pos, with_labels=True)\n\n# show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# Two sets of a bipartite network\nbipartite.sets(graph_bipartite)\n\n({'Alice',\n  'Bob',\n  'Charlie',\n  'David',\n  'Eve',\n  'Frank',\n  'Grace',\n  'Harry',\n  'Ivy',\n  'John'},\n {'AAPL',\n  'AMZN',\n  'FB',\n  'GOOG',\n  'MSFT',\n  'NFLX',\n  'NVDA',\n  'PYPL',\n  'TSLA',\n  'TWTR'})\n\n\n\n# L-partite graph (stockholders)\n# L=left , R=right\n\n# 2 stockholders that have a stock in common are connected\n\n# L-partite graph\ngraph_projected = bipartite.projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# R-partite graph\ngraph_projected = bipartite.projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[1]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# A wighted L-partite\n# how many in common\ngraph_projected = bipartite.weighted_projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\nnx.draw(graph_projected, with_labels=True, node_size=10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# better visualization\ngraph_projected = bipartite.weighted_projected_graph(\n    graph_bipartite, bipartite.sets(graph_bipartite)[0]\n)\npos = nx.circular_layout(graph_projected)\n\n# draw the graph\nnx.draw_networkx_nodes(graph_projected, pos)\nnx.draw_networkx_edges(graph_projected, pos)\nnx.draw_networkx_labels(graph_projected, pos)\n\n# create a dictionary of edge labels\nedge_labels = {(u, v): d[\"weight\"] for u, v, d in graph_projected.edges(data=True)}\n\n# draw the edge labels\nnx.draw_networkx_edge_labels(graph_projected, pos, edge_labels=edge_labels)\n\n# show the plot\nplt.figure(figsize=(50, 30))\nplt.show()\n\n\n\n\n\n\n\n\n&lt;Figure size 5000x3000 with 0 Axes&gt;"
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html",
    "href": "sessions/s07_networks/networkx_fundamentals.html",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.\nThis notebook serves as a brief introduction to the NetworkX package. It covers the following topics:\n\nCreating a graph.\nGraph elements: nodes and edges.\nGraph visualization.\nBasic graph properties: number of nodes and edges, degree, path length.\n\nThis tutorial is based on “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.. Please take a look at the folder references/networkx_indiana for more information.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n\n\n\n\n# Initialize an empty (undirected) graph\nG = nx.Graph()\n\n# Give each a node a 'name', which is a letter in this case.\nG.add_node(\"a\")\n\n# The add_nodes_from method allows adding nodes from a sequence, in this case a list\nnodes_to_add = [\"b\", \"c\", \"d\"]\nG.add_nodes_from(nodes_to_add)\n\n# Add edge from 'a' to 'b'\n# Since this graph is undirected, the order doesn't matter here\nG.add_edge(\"a\", \"b\")\n\n# Just like add_nodes_from, we can add edges from a sequence\n# Edges should be specified as 2-tuples\nedges_to_add = [(\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\")]\nG.add_edges_from(edges_to_add)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Print basic information about the graph\nprint(G)\n\n# List all nodes\nprint(\"Nodes:\", G.nodes())\n\n# List all edges\nprint(\"Edges:\", G.edges())\n\nGraph with 4 nodes and 4 edges\nNodes: ['a', 'b', 'c', 'd']\nEdges: [('a', 'b'), ('a', 'c'), ('b', 'c'), ('c', 'd')]\n\n\n\n\nWe can see the properties of a specific node.\nDegree: The degree of a node \\(k\\) is the number of edges connected to it.\n\n# Degree of a node\nprint(\"Degree of 'a':\", G.degree(\"a\"))\n\nDegree of 'a': 2\n\n\nThe average degree of a graph is given by:\n\\[\\langle k \\rangle = \\frac{2E}{N}\\]\nwhere \\(E\\) is the number of edges and \\(N\\) is the number of nodes.\n\n# Average degree of the graph\nls_degrees = [G.degree(node) for node in G.nodes()]\navg_degree = sum(ls_degrees) / len(ls_degrees)\nprint(\"Average degree:\", avg_degree)\n\nAverage degree: 2.0\n\n\n\n\n\nA graph density is the ratio of the number of edges to the number of possible edges. It is a measure of how many edges are present in the graph compared to the maximum possible number of edges. The density of a graph can be calculated as follows:\n\\[\nD = \\frac{2|E|}{|V|(|V| - 1)}\n\\]\nwhere \\(|E|\\) is the number of edges and \\(|V|\\) is the number of nodes in the graph.\n\n# Density\nprint(\"Density:\", nx.density(G))\n\nDensity: 0.6666666666666666\n\n\nA graph is sparse when \\(D &lt;&lt; 1\\) and dense when \\(D \\approx 1\\).\n\n\n\n\n\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges. The order of the tuple matters here because this is a directed graph\n# If a node is not already in the graph, it will be added automatically\nD.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nWe can see the same properties of the undirected graph in the directed graph. However, the directed graph has a direction in the edges.\n\n# Print basic information about the graph\nprint(D)\n\n# List all nodes\nprint(\"Nodes:\", D.nodes())\n\n# List all edges\nprint(\"Edges:\", D.edges())\n\nDiGraph with 5 nodes and 6 edges\nNodes: ['a', 'b', 'c', 'd', 'e']\nEdges: [('a', 'b'), ('a', 'e'), ('b', 'c'), ('c', 'd'), ('c', 'a'), ('d', 'a')]\n\n\n\n\nSame with a node. It has an in-degree and an out-degree.\n\nprint(\"In-degree of 'a':\", D.in_degree(\"a\"))\nprint(\"Out-degree of 'a':\", D.out_degree(\"a\"))\n\nIn-degree of 'a': 2\nOut-degree of 'a': 2\n\n\n\n\n\nThe formula for the density of a directed graph is the same as the formula for the density of an undirected graph, but in this case there are two times more possible edges. The density of a directed graph can be calculated as follows:\n\\[\nD = \\frac{|E|}{|V|(|V| - 1)}\n\\]\nwhere \\(|E|\\) is the number of edges and \\(|V|\\) is the number of nodes in the graph.\n\n# Density of a directed graph\nprint(\"Density:\", nx.density(D))\n\nDensity: 0.3\n\n\n\n\n\n\n\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nA path in a network is a sequence of edges connecting two nodes.\n\nprint(nx.has_path(G, \"c\", \"e\"))\nprint(nx.shortest_path(G, \"c\", \"e\"))\n# The second command will raise an error if the graph is not connected\n\nTrue\n['c', 'a', 'e']\n\n\nThere can be more than one path between two nodes.\n\nlist(nx.all_simple_paths(G, \"c\", \"e\"))\n# This command will raise an error if the graph is not connected\n\n[['c', 'b', 'a', 'e'], ['c', 'd', 'a', 'e'], ['c', 'a', 'e']]\n\n\nThe diameter of a graph is the longest shortest path between any two nodes.\n\nprint(\"Diameter:\", nx.diameter(G))\n\nDiameter: 2\n\n\nThe average path length (APL) is the average of the shortest paths between all pairs of nodes.\n\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G))\n\nAverage shortest path length: 1.4\n\n\n\n\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges\nD.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n        (\"e\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Can we reach 'c' from 'z'?\nnx.has_path(D, \"c\", \"z\")\n\nTrue\n\n\n\n# Can we reach 'z' from 'c'?\nnx.has_path(D, \"z\", \"c\")\n\nFalse\n\n\nExercise. Create a path from “z” to “c” in the directed graph D, so that the shortest path has a length of 4.\n\n\n\nA graph is connected when we can reach any node from any other node by following the edges. This means, there exists a path between any two nodes.\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nprint(\"Is connected:\", nx.is_connected(G))\n\n\n\n\n\n\n\n\nIs connected: True\n\n\n\n# Remove a node\nif \"a\" in G.nodes():\n    G.remove_node(\"a\")\n\n# Is connected now?\nprint(\"Is connected:\", nx.is_connected(G))\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nIs connected: False\n\n\n\n\n\n\n\n\n\n\n\n\nThe connectivity of a directed graph is defined by the strongly connected components. A directed graph is strongly connected if there is a directed path from any node to any other node. Conversely, a directed graph is weakly connected if there is an undirected path from any node to any other node.\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges. The order of the tuple matters here because this is a directed graph\n# If a node is not already in the graph, it will be added automatically\nD.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\nprint(\"Is strongly connected:\", nx.is_strongly_connected(D))\nprint(\"Is weakly connected:\", nx.is_weakly_connected(D))\n\n\n\n\n\n\n\n\nIs strongly connected: False\nIs weakly connected: True\n\n\nExercise. Make a copy of graph D and name it D_strong. Turn it into a strongly connected graph.\nExercise. Make a copy of graph D and name it D_uncon. Turn it into a unconnected graph.\n\n\n\nA connected component is a connected subnetwork.\nThe largest one is called giant component; it often includes a substantial portion of the network.\nA singleton is the smallest-possible connected component.\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nThe nx.connected_components() function takes a graph and returns a list of sets of node names, one such set for each connected component. Verify that the two sets in the following list correspond to the two connected components in the drawing of the graph above:\n\nlist(nx.connected_components(G))\n\n[{'a', 'b', 'c', 'd', 'e'}, {'x', 'y', 'z'}]\n\n\nExercise. How many connected components are there in the graph G below?\n\nlist_edges = [(\"x\", \"y\"), (\"y\", \"z\"), (\"z\", \"x\"), (\"r\", \"s\")]\n\nG.add_edges_from(list_edges)\n\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nIn a directed graph, we can have strongly connected components and weakly connected components.\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges\nD.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nA directed graph is strongly connected if there is a directed path from any node to any other node.\n\nprint(\"Is strongly connected:\", nx.is_strongly_connected(D))\nprint(list(nx.strongly_connected_components(D)))\n\nIs strongly connected: False\n[{'e'}, {'d', 'b', 'a', 'c'}, {'x', 'z', 'y'}]\n\n\nA directed graph is weakly connected if there is an undirected path from any node to any other node.\n\nprint(\"Is weakly connected:\", nx.is_weakly_connected(D))\nprint(list(nx.weakly_connected_components(D)))\n\nIs weakly connected: False\n[{'e', 'a', 'd', 'b', 'c'}, {'x', 'z', 'y'}]\n\n\n\n\n\n\n\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add weighted edges\nD.add_weighted_edges_from(\n    [\n        (\"a\", \"b\", 1),\n        (\"b\", \"c\", 2),\n        (\"c\", \"d\", 3),\n        (\"d\", \"a\", 4),\n        (\"a\", \"e\", 5),\n        (\"c\", \"a\", 6),\n    ]\n)\n\n# Choose a layout (required to add the weights)\npos = nx.circular_layout(D)\n# Draw the graph\nnx.draw(D, with_labels=True, pos=pos)\n# Draw the edge labels\nedge_labels = nx.get_edge_attributes(D, \"weight\")\nnx.draw_networkx_edge_labels(D, pos=pos, edge_labels=edge_labels)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\nThis repository contains several example network datasets. Among these is a network of US air travel routes:\n\nG = nx.read_graphml(\"../../data/openflights/openflights_usa.graphml.gz\")\n\nprint(G)\nprint(\"Nodes:\", G.nodes())\n\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 546 nodes and 2781 edges\nNodes: ['RDD', 'EUG', 'IDA', 'MFR', 'RDM', 'OOK', 'ABL', 'BKC', 'ITO', 'OBU', 'ORV', 'WLK', 'KTS', 'CAK', 'HSV', 'PKB', 'MGM', 'TRI', 'PAH', 'KKA', 'SMK', 'SKK', 'TNC', 'AKB', 'PGA', 'FCA', 'MBS', 'BGM', 'KFP', 'NLG', 'KLW', 'KWN', 'HNM', 'KYU', 'SCM', 'BTI', 'NME', 'KKH', 'NIB', 'PSG', 'AIN', 'CIC', 'KUK', 'WNA', 'IRC', 'SFB', 'SLQ', 'JST', 'HKB', 'MLY', 'CLM', 'KWT', 'ELI', 'GLV', 'PSM', 'TLA', 'WAA', 'MSO', 'HVR', 'HHH', 'GRK', 'TVF', 'SGY', 'MLL', 'RBY', 'EGE', 'CSG', 'LAW', 'FLG', 'ANV', 'TWF', 'MVY', 'KVC', 'STC', 'GTR', 'ERI', 'HYA', 'PTH', 'AUK', 'MGW', 'CRW', 'AVP', 'BJI', 'FAR', 'KPN', 'GCC', 'SVA', 'SCE', 'HGR', 'KOT', 'MEI', 'SPI', 'CEZ', 'HDN', 'LBL', 'COD', 'SGF', 'JLN', 'ABE', 'XNA', 'SBN', 'CKB', 'LRD', 'ORH', 'ACV', 'OAJ', 'DBQ', 'GGG', 'PVC', 'KTN', 'GGW', 'OGD', 'PIH', 'PDT', 'LUR', 'PIZ', 'RAP', 'BTT', 'FYU', 'ATK', 'TLJ', 'SNP', 'IGG', 'STG', 'ILI', 'PTU', 'AZA', 'FSM', 'KAL', 'GFK', 'KSM', 'PRC', 'TTN', 'BOS', 'KVL', 'OAK', 'OMA', 'HOT', 'OGG', 'ICT', 'MCI', 'MSN', 'DLG', 'HRO', 'PHX', 'BGR', 'BUF', 'GEG', 'SFO', 'GNV', 'MEM', 'ELD', 'PVU', 'LAX', 'CLE', 'WTK', 'CVG', 'AIA', 'JNU', 'LFT', 'EWR', 'BOI', 'GCK', 'MOT', 'DAL', 'HLN', 'LCH', 'KOA', 'MYR', 'ACK', 'DCA', 'LAM', 'ACY', 'PUB', 'PQI', 'ADQ', 'FLL', 'INL', 'SLC', 'HON', 'MDT', 'LNK', 'LAN', 'MUE', 'MSS', 'IAH', 'SOW', 'BFL', 'ELP', 'HRL', 'MMU', 'PNS', 'HOU', 'PIT', 'BRW', 'ECP', 'MMH', 'MIA', 'SEA', 'CHA', 'JAN', 'GAM', 'LGB', 'IPT', 'IND', 'KQA', 'HPN', 'JBR', 'ALW', 'YUM', 'CNM', 'DLH', 'BET', 'PKA', 'LIH', 'YAK', 'ATY', 'RIC', 'SHV', 'CDV', 'ORF', 'BPT', 'SAV', 'OME', 'PIE', 'MQT', 'SCC', 'SAT', 'ROC', 'TEB', 'BKW', 'RDU', 'DAY', 'ENA', 'LAS', 'IAG', 'IAN', 'PHF', 'TUS', 'BRL', 'AKP', 'PVD', 'SBY', 'CEC', 'BUR', 'DTW', 'TPA', 'EEK', 'MYU', 'SPS', 'HIB', 'SHH', 'MAF', 'GRB', 'LUK', 'ARC', 'AGS', 'ISN', 'LIT', 'SWF', 'HOM', 'TBN', 'ABR', 'ABY', 'AHN', 'DFW', 'MLB', 'APN', 'AUS', 'BFD', 'BFF', 'TYS', 'BQK', 'STL', 'GRR', 'CGI', 'CIU', 'ATL', 'DRG', 'CMX', 'DDC', 'DUJ', 'EAU', 'EKO', 'EWB', 'BNA', 'FAT', 'GRI', 'OTZ', 'HTS', 'TOG', 'IRK', 'LGA', 'TLH', 'LBE', 'LBF', 'AUG', 'LMT', 'IPL', 'MKL', 'LYH', 'MKG', 'MSL', 'FAY', 'OWB', 'BTV', 'JAX', 'DRO', 'IAD', 'CLL', 'MKE', 'ABI', 'COU', 'PDX', 'SHR', 'PBI', 'SLN', 'SMX', 'TUP', 'UIN', 'VCT', 'HNL', 'DSM', 'EWN', 'SAN', 'MLU', 'AOO', 'ONT', 'ROW', 'BRO', 'DHN', 'FMN', 'CRP', 'SYR', 'MDW', 'SJC', 'HOB', 'DEN', 'PHL', 'SUX', 'MCN', 'NUL', 'LAR', 'CMH', 'GAL', 'IMT', 'AET', 'ACT', 'TXK', 'PBG', 'VEE', 'ANC', 'LEB', 'BLI', 'WBQ', 'MOB', 'SAF', 'CEM', 'LNS', 'ALO', 'BLV', 'SHG', 'RSW', 'AKN', 'JHM', 'JFK', 'MKK', 'CYS', 'SCK', 'CHS', 'RNO', 'MTJ', 'RIW', 'BHM', 'VIS', 'MOD', 'SMF', 'COS', 'SDP', 'MCE', 'OTH', 'CDC', 'BDL', 'MFE', 'GCN', 'LBB', 'ORD', 'FAI', 'PIB', 'ART', 'PSP', 'AMA', 'SJT', 'FOE', 'EAT', 'ILM', 'BTR', 'PIR', 'TYR', 'BWI', 'LNY', 'AEX', 'PLN', 'CDB', 'TUL', 'SIT', 'ISP', 'MSP', 'ILG', 'DUT', 'MSY', 'PWM', 'OKC', 'ALB', 'VDZ', 'SNA', 'RHI', 'CPR', 'VPS', 'EYW', 'CLT', 'RKS', 'MCO', 'FLO', 'GTF', 'YNG', 'ESD', 'RUT', 'BRD', 'LWB', 'PGV', 'CYF', 'SBP', 'WSN', 'AGN', 'SLK', 'WMO', 'ELV', 'ADK', 'GST', 'OGS', 'HCR', 'HNS', 'KLG', 'MCG', 'ESC', 'ANI', 'STS', 'WRG', 'BFI', 'ASE', 'VLD', 'HPB', 'EMK', 'WRL', 'PUW', 'LWS', 'ELM', 'ITH', 'MRY', 'SBA', 'DAB', 'RSH', 'YKM', 'CAE', 'LCK', 'UNK', 'UST', 'GUC', 'MBL', 'PGD', 'JHW', 'CLD', 'SHD', 'DIK', 'SDY', 'CDR', 'KPV', 'MCK', 'GDV', 'OLF', 'ALS', 'CNY', 'VEL', 'HVN', 'AVL', 'GSO', 'FSD', 'FRD', 'MHT', 'APF', 'EGX', 'SDF', 'CHO', 'ROA', 'LEX', 'EVV', 'ABQ', 'BZN', 'BIL', 'BTM', 'TVC', 'KWK', 'BHB', 'RKD', 'JAC', 'RFD', 'SHX', 'CIK', 'GSP', 'HUS', 'HSL', 'BMI', 'GPT', 'AZO', 'TOL', 'FWA', 'DEC', 'CID', 'LSE', 'CWA', 'PIA', 'ATW', 'RST', 'CMI', 'MHK', 'MOU', 'FNT', 'FKL', 'GJT', 'SGU', 'VAK', 'SRQ', 'HNH', 'MLI', 'MTM', 'HYG', 'GLH', 'BIS', 'PSC', 'PIP', 'MWA', 'AKK', 'KYK', 'KLN', 'NUI']\n\n\n\n\n\n\n\n\n\nThe nodes in this graph are airports, represented by their IATA codes; two nodes are connected with an edge if there is a scheduled flight directly connecting these two airports. We’ll assume this graph to be undirected since a flight in one direction usually means there is a return flight.\nThus this graph has edges\n[('HOM', 'ANC'), ('BGM', 'PHL'), ('BGM', 'IAD'), ...]\nwhere ANC is Anchorage, IAD is Washington Dulles, etc.\nThese nodes also have attributes associated with them, containing additional information about the airports, in the form of a dictionary:\n\nG.nodes[\"IND\"]\n\n{'name': 'Indianapolis International Airport',\n 'latitude': 39.7173,\n 'longitude': -86.294403,\n 'IATA': 'IND'}\n\n\nExercise. Is there a direct flight between Indianapolis and Fairbanks, Alaska (FAI)? A direct flight is one with no intermediate stops.\nExercise. If I wanted to fly from Indianapolis (IND) to Fairbanks, Alaska (FAI) what would be an itinerary with the fewest number of flights?\nExercise. Is it possible to travel from any airport in the US to any other airport in the US, possibly using connecting flights? In other words, does there exist a path in the network between every possible pair of airports (is the graph connected)?\nExercise. Which airports are the most important for connectivity?\nExercise. What happens if a major hub is removed?\n\n\n\n\nNow you understand the basics of NetworkX. You can use this knowledge to analyze and visualize networks. You can also use this knowledge to create your own networks and analyze them.\nYour next step is to open the notebook “structural properties” and learn new concepts such as clustering coefficient, centrality, and robustness.\nYou can also check the notebook “models” to learn how to create specific types of networks, such as random networks, small-world networks, and scale-free networks."
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#undirected-graphs",
    "href": "sessions/s07_networks/networkx_fundamentals.html#undirected-graphs",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "# Initialize an empty (undirected) graph\nG = nx.Graph()\n\n# Give each a node a 'name', which is a letter in this case.\nG.add_node(\"a\")\n\n# The add_nodes_from method allows adding nodes from a sequence, in this case a list\nnodes_to_add = [\"b\", \"c\", \"d\"]\nG.add_nodes_from(nodes_to_add)\n\n# Add edge from 'a' to 'b'\n# Since this graph is undirected, the order doesn't matter here\nG.add_edge(\"a\", \"b\")\n\n# Just like add_nodes_from, we can add edges from a sequence\n# Edges should be specified as 2-tuples\nedges_to_add = [(\"a\", \"c\"), (\"b\", \"c\"), (\"c\", \"d\")]\nG.add_edges_from(edges_to_add)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Print basic information about the graph\nprint(G)\n\n# List all nodes\nprint(\"Nodes:\", G.nodes())\n\n# List all edges\nprint(\"Edges:\", G.edges())\n\nGraph with 4 nodes and 4 edges\nNodes: ['a', 'b', 'c', 'd']\nEdges: [('a', 'b'), ('a', 'c'), ('b', 'c'), ('c', 'd')]\n\n\n\n\nWe can see the properties of a specific node.\nDegree: The degree of a node \\(k\\) is the number of edges connected to it.\n\n# Degree of a node\nprint(\"Degree of 'a':\", G.degree(\"a\"))\n\nDegree of 'a': 2\n\n\nThe average degree of a graph is given by:\n\\[\\langle k \\rangle = \\frac{2E}{N}\\]\nwhere \\(E\\) is the number of edges and \\(N\\) is the number of nodes.\n\n# Average degree of the graph\nls_degrees = [G.degree(node) for node in G.nodes()]\navg_degree = sum(ls_degrees) / len(ls_degrees)\nprint(\"Average degree:\", avg_degree)\n\nAverage degree: 2.0\n\n\n\n\n\nA graph density is the ratio of the number of edges to the number of possible edges. It is a measure of how many edges are present in the graph compared to the maximum possible number of edges. The density of a graph can be calculated as follows:\n\\[\nD = \\frac{2|E|}{|V|(|V| - 1)}\n\\]\nwhere \\(|E|\\) is the number of edges and \\(|V|\\) is the number of nodes in the graph.\n\n# Density\nprint(\"Density:\", nx.density(G))\n\nDensity: 0.6666666666666666\n\n\nA graph is sparse when \\(D &lt;&lt; 1\\) and dense when \\(D \\approx 1\\)."
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#directed-graphs",
    "href": "sessions/s07_networks/networkx_fundamentals.html#directed-graphs",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges. The order of the tuple matters here because this is a directed graph\n# If a node is not already in the graph, it will be added automatically\nD.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nWe can see the same properties of the undirected graph in the directed graph. However, the directed graph has a direction in the edges.\n\n# Print basic information about the graph\nprint(D)\n\n# List all nodes\nprint(\"Nodes:\", D.nodes())\n\n# List all edges\nprint(\"Edges:\", D.edges())\n\nDiGraph with 5 nodes and 6 edges\nNodes: ['a', 'b', 'c', 'd', 'e']\nEdges: [('a', 'b'), ('a', 'e'), ('b', 'c'), ('c', 'd'), ('c', 'a'), ('d', 'a')]\n\n\n\n\nSame with a node. It has an in-degree and an out-degree.\n\nprint(\"In-degree of 'a':\", D.in_degree(\"a\"))\nprint(\"Out-degree of 'a':\", D.out_degree(\"a\"))\n\nIn-degree of 'a': 2\nOut-degree of 'a': 2\n\n\n\n\n\nThe formula for the density of a directed graph is the same as the formula for the density of an undirected graph, but in this case there are two times more possible edges. The density of a directed graph can be calculated as follows:\n\\[\nD = \\frac{|E|}{|V|(|V| - 1)}\n\\]\nwhere \\(|E|\\) is the number of edges and \\(|V|\\) is the number of nodes in the graph.\n\n# Density of a directed graph\nprint(\"Density:\", nx.density(D))\n\nDensity: 0.3"
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#paths-in-a-graph",
    "href": "sessions/s07_networks/networkx_fundamentals.html#paths-in-a-graph",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nA path in a network is a sequence of edges connecting two nodes.\n\nprint(nx.has_path(G, \"c\", \"e\"))\nprint(nx.shortest_path(G, \"c\", \"e\"))\n# The second command will raise an error if the graph is not connected\n\nTrue\n['c', 'a', 'e']\n\n\nThere can be more than one path between two nodes.\n\nlist(nx.all_simple_paths(G, \"c\", \"e\"))\n# This command will raise an error if the graph is not connected\n\n[['c', 'b', 'a', 'e'], ['c', 'd', 'a', 'e'], ['c', 'a', 'e']]\n\n\nThe diameter of a graph is the longest shortest path between any two nodes.\n\nprint(\"Diameter:\", nx.diameter(G))\n\nDiameter: 2\n\n\nThe average path length (APL) is the average of the shortest paths between all pairs of nodes.\n\nprint(\"Average shortest path length:\", nx.average_shortest_path_length(G))\n\nAverage shortest path length: 1.4\n\n\n\n\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges\nD.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n        (\"e\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Can we reach 'c' from 'z'?\nnx.has_path(D, \"c\", \"z\")\n\nTrue\n\n\n\n# Can we reach 'z' from 'c'?\nnx.has_path(D, \"z\", \"c\")\n\nFalse\n\n\nExercise. Create a path from “z” to “c” in the directed graph D, so that the shortest path has a length of 4.\n\n\n\nA graph is connected when we can reach any node from any other node by following the edges. This means, there exists a path between any two nodes.\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nprint(\"Is connected:\", nx.is_connected(G))\n\n\n\n\n\n\n\n\nIs connected: True\n\n\n\n# Remove a node\nif \"a\" in G.nodes():\n    G.remove_node(\"a\")\n\n# Is connected now?\nprint(\"Is connected:\", nx.is_connected(G))\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\nIs connected: False\n\n\n\n\n\n\n\n\n\n\n\n\nThe connectivity of a directed graph is defined by the strongly connected components. A directed graph is strongly connected if there is a directed path from any node to any other node. Conversely, a directed graph is weakly connected if there is an undirected path from any node to any other node.\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges. The order of the tuple matters here because this is a directed graph\n# If a node is not already in the graph, it will be added automatically\nD.add_edges_from(\n    [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"a\"), (\"a\", \"e\"), (\"c\", \"a\")]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\nprint(\"Is strongly connected:\", nx.is_strongly_connected(D))\nprint(\"Is weakly connected:\", nx.is_weakly_connected(D))\n\n\n\n\n\n\n\n\nIs strongly connected: False\nIs weakly connected: True\n\n\nExercise. Make a copy of graph D and name it D_strong. Turn it into a strongly connected graph.\nExercise. Make a copy of graph D and name it D_uncon. Turn it into a unconnected graph.\n\n\n\nA connected component is a connected subnetwork.\nThe largest one is called giant component; it often includes a substantial portion of the network.\nA singleton is the smallest-possible connected component.\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Add edges\nG.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nThe nx.connected_components() function takes a graph and returns a list of sets of node names, one such set for each connected component. Verify that the two sets in the following list correspond to the two connected components in the drawing of the graph above:\n\nlist(nx.connected_components(G))\n\n[{'a', 'b', 'c', 'd', 'e'}, {'x', 'y', 'z'}]\n\n\nExercise. How many connected components are there in the graph G below?\n\nlist_edges = [(\"x\", \"y\"), (\"y\", \"z\"), (\"z\", \"x\"), (\"r\", \"s\")]\n\nG.add_edges_from(list_edges)\n\npos = nx.circular_layout(G)\nnx.draw(G, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nIn a directed graph, we can have strongly connected components and weakly connected components.\n\n# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add edges\nD.add_edges_from(\n    [\n        (\"a\", \"b\"),\n        (\"b\", \"c\"),\n        (\"c\", \"d\"),\n        (\"d\", \"a\"),\n        (\"a\", \"e\"),\n        (\"c\", \"a\"),\n        (\"x\", \"y\"),\n        (\"y\", \"z\"),\n        (\"z\", \"x\"),\n    ]\n)\n\n# Draw the graph\npos = nx.circular_layout(D)\nnx.draw(D, with_labels=True, pos=pos)\nplt.show()\n\n\n\n\n\n\n\n\nA directed graph is strongly connected if there is a directed path from any node to any other node.\n\nprint(\"Is strongly connected:\", nx.is_strongly_connected(D))\nprint(list(nx.strongly_connected_components(D)))\n\nIs strongly connected: False\n[{'e'}, {'d', 'b', 'a', 'c'}, {'x', 'z', 'y'}]\n\n\nA directed graph is weakly connected if there is an undirected path from any node to any other node.\n\nprint(\"Is weakly connected:\", nx.is_weakly_connected(D))\nprint(list(nx.weakly_connected_components(D)))\n\nIs weakly connected: False\n[{'e', 'a', 'd', 'b', 'c'}, {'x', 'z', 'y'}]"
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#weighted-edges",
    "href": "sessions/s07_networks/networkx_fundamentals.html#weighted-edges",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "# Initialize a directed graph\nD = nx.DiGraph()\n\n# Add weighted edges\nD.add_weighted_edges_from(\n    [\n        (\"a\", \"b\", 1),\n        (\"b\", \"c\", 2),\n        (\"c\", \"d\", 3),\n        (\"d\", \"a\", 4),\n        (\"a\", \"e\", 5),\n        (\"c\", \"a\", 6),\n    ]\n)\n\n# Choose a layout (required to add the weights)\npos = nx.circular_layout(D)\n# Draw the graph\nnx.draw(D, with_labels=True, pos=pos)\n# Draw the edge labels\nedge_labels = nx.get_edge_attributes(D, \"weight\")\nnx.draw_networkx_edge_labels(D, pos=pos, edge_labels=edge_labels)\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#exercise-openflights-network",
    "href": "sessions/s07_networks/networkx_fundamentals.html#exercise-openflights-network",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "This repository contains several example network datasets. Among these is a network of US air travel routes:\n\nG = nx.read_graphml(\"../../data/openflights/openflights_usa.graphml.gz\")\n\nprint(G)\nprint(\"Nodes:\", G.nodes())\n\npos = nx.circular_layout(G)\nnx.draw(G, pos=pos, node_size=10)\nplt.show()\n\nGraph with 546 nodes and 2781 edges\nNodes: ['RDD', 'EUG', 'IDA', 'MFR', 'RDM', 'OOK', 'ABL', 'BKC', 'ITO', 'OBU', 'ORV', 'WLK', 'KTS', 'CAK', 'HSV', 'PKB', 'MGM', 'TRI', 'PAH', 'KKA', 'SMK', 'SKK', 'TNC', 'AKB', 'PGA', 'FCA', 'MBS', 'BGM', 'KFP', 'NLG', 'KLW', 'KWN', 'HNM', 'KYU', 'SCM', 'BTI', 'NME', 'KKH', 'NIB', 'PSG', 'AIN', 'CIC', 'KUK', 'WNA', 'IRC', 'SFB', 'SLQ', 'JST', 'HKB', 'MLY', 'CLM', 'KWT', 'ELI', 'GLV', 'PSM', 'TLA', 'WAA', 'MSO', 'HVR', 'HHH', 'GRK', 'TVF', 'SGY', 'MLL', 'RBY', 'EGE', 'CSG', 'LAW', 'FLG', 'ANV', 'TWF', 'MVY', 'KVC', 'STC', 'GTR', 'ERI', 'HYA', 'PTH', 'AUK', 'MGW', 'CRW', 'AVP', 'BJI', 'FAR', 'KPN', 'GCC', 'SVA', 'SCE', 'HGR', 'KOT', 'MEI', 'SPI', 'CEZ', 'HDN', 'LBL', 'COD', 'SGF', 'JLN', 'ABE', 'XNA', 'SBN', 'CKB', 'LRD', 'ORH', 'ACV', 'OAJ', 'DBQ', 'GGG', 'PVC', 'KTN', 'GGW', 'OGD', 'PIH', 'PDT', 'LUR', 'PIZ', 'RAP', 'BTT', 'FYU', 'ATK', 'TLJ', 'SNP', 'IGG', 'STG', 'ILI', 'PTU', 'AZA', 'FSM', 'KAL', 'GFK', 'KSM', 'PRC', 'TTN', 'BOS', 'KVL', 'OAK', 'OMA', 'HOT', 'OGG', 'ICT', 'MCI', 'MSN', 'DLG', 'HRO', 'PHX', 'BGR', 'BUF', 'GEG', 'SFO', 'GNV', 'MEM', 'ELD', 'PVU', 'LAX', 'CLE', 'WTK', 'CVG', 'AIA', 'JNU', 'LFT', 'EWR', 'BOI', 'GCK', 'MOT', 'DAL', 'HLN', 'LCH', 'KOA', 'MYR', 'ACK', 'DCA', 'LAM', 'ACY', 'PUB', 'PQI', 'ADQ', 'FLL', 'INL', 'SLC', 'HON', 'MDT', 'LNK', 'LAN', 'MUE', 'MSS', 'IAH', 'SOW', 'BFL', 'ELP', 'HRL', 'MMU', 'PNS', 'HOU', 'PIT', 'BRW', 'ECP', 'MMH', 'MIA', 'SEA', 'CHA', 'JAN', 'GAM', 'LGB', 'IPT', 'IND', 'KQA', 'HPN', 'JBR', 'ALW', 'YUM', 'CNM', 'DLH', 'BET', 'PKA', 'LIH', 'YAK', 'ATY', 'RIC', 'SHV', 'CDV', 'ORF', 'BPT', 'SAV', 'OME', 'PIE', 'MQT', 'SCC', 'SAT', 'ROC', 'TEB', 'BKW', 'RDU', 'DAY', 'ENA', 'LAS', 'IAG', 'IAN', 'PHF', 'TUS', 'BRL', 'AKP', 'PVD', 'SBY', 'CEC', 'BUR', 'DTW', 'TPA', 'EEK', 'MYU', 'SPS', 'HIB', 'SHH', 'MAF', 'GRB', 'LUK', 'ARC', 'AGS', 'ISN', 'LIT', 'SWF', 'HOM', 'TBN', 'ABR', 'ABY', 'AHN', 'DFW', 'MLB', 'APN', 'AUS', 'BFD', 'BFF', 'TYS', 'BQK', 'STL', 'GRR', 'CGI', 'CIU', 'ATL', 'DRG', 'CMX', 'DDC', 'DUJ', 'EAU', 'EKO', 'EWB', 'BNA', 'FAT', 'GRI', 'OTZ', 'HTS', 'TOG', 'IRK', 'LGA', 'TLH', 'LBE', 'LBF', 'AUG', 'LMT', 'IPL', 'MKL', 'LYH', 'MKG', 'MSL', 'FAY', 'OWB', 'BTV', 'JAX', 'DRO', 'IAD', 'CLL', 'MKE', 'ABI', 'COU', 'PDX', 'SHR', 'PBI', 'SLN', 'SMX', 'TUP', 'UIN', 'VCT', 'HNL', 'DSM', 'EWN', 'SAN', 'MLU', 'AOO', 'ONT', 'ROW', 'BRO', 'DHN', 'FMN', 'CRP', 'SYR', 'MDW', 'SJC', 'HOB', 'DEN', 'PHL', 'SUX', 'MCN', 'NUL', 'LAR', 'CMH', 'GAL', 'IMT', 'AET', 'ACT', 'TXK', 'PBG', 'VEE', 'ANC', 'LEB', 'BLI', 'WBQ', 'MOB', 'SAF', 'CEM', 'LNS', 'ALO', 'BLV', 'SHG', 'RSW', 'AKN', 'JHM', 'JFK', 'MKK', 'CYS', 'SCK', 'CHS', 'RNO', 'MTJ', 'RIW', 'BHM', 'VIS', 'MOD', 'SMF', 'COS', 'SDP', 'MCE', 'OTH', 'CDC', 'BDL', 'MFE', 'GCN', 'LBB', 'ORD', 'FAI', 'PIB', 'ART', 'PSP', 'AMA', 'SJT', 'FOE', 'EAT', 'ILM', 'BTR', 'PIR', 'TYR', 'BWI', 'LNY', 'AEX', 'PLN', 'CDB', 'TUL', 'SIT', 'ISP', 'MSP', 'ILG', 'DUT', 'MSY', 'PWM', 'OKC', 'ALB', 'VDZ', 'SNA', 'RHI', 'CPR', 'VPS', 'EYW', 'CLT', 'RKS', 'MCO', 'FLO', 'GTF', 'YNG', 'ESD', 'RUT', 'BRD', 'LWB', 'PGV', 'CYF', 'SBP', 'WSN', 'AGN', 'SLK', 'WMO', 'ELV', 'ADK', 'GST', 'OGS', 'HCR', 'HNS', 'KLG', 'MCG', 'ESC', 'ANI', 'STS', 'WRG', 'BFI', 'ASE', 'VLD', 'HPB', 'EMK', 'WRL', 'PUW', 'LWS', 'ELM', 'ITH', 'MRY', 'SBA', 'DAB', 'RSH', 'YKM', 'CAE', 'LCK', 'UNK', 'UST', 'GUC', 'MBL', 'PGD', 'JHW', 'CLD', 'SHD', 'DIK', 'SDY', 'CDR', 'KPV', 'MCK', 'GDV', 'OLF', 'ALS', 'CNY', 'VEL', 'HVN', 'AVL', 'GSO', 'FSD', 'FRD', 'MHT', 'APF', 'EGX', 'SDF', 'CHO', 'ROA', 'LEX', 'EVV', 'ABQ', 'BZN', 'BIL', 'BTM', 'TVC', 'KWK', 'BHB', 'RKD', 'JAC', 'RFD', 'SHX', 'CIK', 'GSP', 'HUS', 'HSL', 'BMI', 'GPT', 'AZO', 'TOL', 'FWA', 'DEC', 'CID', 'LSE', 'CWA', 'PIA', 'ATW', 'RST', 'CMI', 'MHK', 'MOU', 'FNT', 'FKL', 'GJT', 'SGU', 'VAK', 'SRQ', 'HNH', 'MLI', 'MTM', 'HYG', 'GLH', 'BIS', 'PSC', 'PIP', 'MWA', 'AKK', 'KYK', 'KLN', 'NUI']\n\n\n\n\n\n\n\n\n\nThe nodes in this graph are airports, represented by their IATA codes; two nodes are connected with an edge if there is a scheduled flight directly connecting these two airports. We’ll assume this graph to be undirected since a flight in one direction usually means there is a return flight.\nThus this graph has edges\n[('HOM', 'ANC'), ('BGM', 'PHL'), ('BGM', 'IAD'), ...]\nwhere ANC is Anchorage, IAD is Washington Dulles, etc.\nThese nodes also have attributes associated with them, containing additional information about the airports, in the form of a dictionary:\n\nG.nodes[\"IND\"]\n\n{'name': 'Indianapolis International Airport',\n 'latitude': 39.7173,\n 'longitude': -86.294403,\n 'IATA': 'IND'}\n\n\nExercise. Is there a direct flight between Indianapolis and Fairbanks, Alaska (FAI)? A direct flight is one with no intermediate stops.\nExercise. If I wanted to fly from Indianapolis (IND) to Fairbanks, Alaska (FAI) what would be an itinerary with the fewest number of flights?\nExercise. Is it possible to travel from any airport in the US to any other airport in the US, possibly using connecting flights? In other words, does there exist a path in the network between every possible pair of airports (is the graph connected)?\nExercise. Which airports are the most important for connectivity?\nExercise. What happens if a major hub is removed?"
  },
  {
    "objectID": "sessions/s07_networks/networkx_fundamentals.html#next-steps",
    "href": "sessions/s07_networks/networkx_fundamentals.html#next-steps",
    "title": "Network X - Fundamentals",
    "section": "",
    "text": "Now you understand the basics of NetworkX. You can use this knowledge to analyze and visualize networks. You can also use this knowledge to create your own networks and analyze them.\nYour next step is to open the notebook “structural properties” and learn new concepts such as clustering coefficient, centrality, and robustness.\nYou can also check the notebook “models” to learn how to create specific types of networks, such as random networks, small-world networks, and scale-free networks."
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html",
    "href": "sessions/s09_networkx_data/facebook.html",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "This notebook contains a social network analysis mainly executed with the library of NetworkX. In detail, the facebook circles (friends lists) of ten people will be examined and scrutinized in order to extract all kinds of valuable information. The dataset can be found at this link: Stanford Facebook Dataset. Moreover, as known, a facebook network is undirected and has no weights because one user can become friends with another user just once. Looking at the dataset from a graph analysis perspective:\n\nEach node represents an anonymized facebook user that belongs to one of those ten friends lists.\nEach edge corresponds to the friendship of two facebook users that belong to this network. In other words, two users must become friends on facebook in order for them to be connected in the particular network.\n\nNote: Nodes \\(0, 107, 348, 414, 686, 698, 1684, 1912, 3437, 3980\\) are the ones whose friends list will be examined. That means that they are in the spotlight of this analysis. Those nodes are considered the spotlight nodes\n\n\n\nimport pandas as pd\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom random import randint\n\n\n\n\nThe edges are loaded from the data folder and saved in a dataframe. Each edge is a new row and for each edge there is a start_node and an end_node column\n\nfacebook = pd.read_csv(\n    \"../../data/facebook_combined.txt.gz\",\n    compression=\"gzip\",\n    sep=\" \",\n    names=[\"start_node\", \"end_node\"],\n)\nfacebook\n\n\n\n\n\n\n\n\nstart_node\nend_node\n\n\n\n\n0\n0\n1\n\n\n1\n0\n2\n\n\n2\n0\n3\n\n\n3\n0\n4\n\n\n4\n0\n5\n\n\n...\n...\n...\n\n\n88229\n4026\n4030\n\n\n88230\n4027\n4031\n\n\n88231\n4027\n4032\n\n\n88232\n4027\n4038\n\n\n88233\n4031\n4038\n\n\n\n\n88234 rows × 2 columns\n\n\n\nThe graph is created from the facebook dataframe of the edges:\n\nG = nx.from_pandas_edgelist(facebook, \"start_node\", \"end_node\")\n\n\n\n\nLet’s start our exploration by visualizing the graph. Visualization plays a central role in exploratory data analysis to help get a qualitative feel for the data.\nSince we don’t have any real sense of structure in the data, let’s start by viewing the graph with random_layout, which is among the fastest of the layout functions.\n\nfig, ax = plt.subplots(figsize=(15, 9))\nax.axis(\"off\")\nplot_options = {\"node_size\": 10, \"with_labels\": False, \"width\": 0.15}\nnx.draw_networkx(G, pos=nx.random_layout(G), ax=ax, **plot_options)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe resulting image is… not very useful. Graph visualizations of this kind are sometimes colloquially referred to as “hairballs” due to the overlapping edges resulting in an entangled mess.\nIt’s clear that we need to impose more structure on the positioning of the if we want to get a sense for the data. For this, we can use the spring_layout function which is the default layout function for the networkx drawing module. The spring_layout function has the advantage that it takes into account the nodes and edges to compute locations of the nodes. The downside however, is that this process is much more computationally expensive, and can be quite slow for graphs with 100’s of nodes and 1000’s of edges.\nSince our dataset has over 80k edges, we will limit the number of iterations used in the spring_layout function to reduce the computation time. We will also save the computed layout so we can use it for future visualizations.\n\npos = nx.spring_layout(G, iterations=15, seed=1721)\nfig, ax = plt.subplots(figsize=(15, 9))\nax.axis(\"off\")\nnx.draw_networkx(G, pos=pos, ax=ax, **plot_options)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThis visualization is much more useful than the previous one! Already we can glean something about the structure of the network; for example, many of the nodes seem to be highly connected, as we might expect for a social network. We also get a sense that the nodes tend to form clusters. The spring_layout serves to give a qualitative sense of clustering, but it is not designed for repeatable, qualitative clustering analysis. We’ll revisit evaluating network clustering later in the analysis\n\n\n\nTotal number of nodes in network:\n\nG.number_of_nodes()\n\n4039\n\n\nTotal number of edges:\n\nG.number_of_edges()\n\n88234\n\n\nAlso, the average degree of a node can be seen.\n\nOn average, a node is connected to almost 44 other nodes, also known as neighbors of the node.\nThis has been calculated by creating a list of all the degrees of the nodes and using numpy.array to find the mean of the created list.\n\n\nnp.mean([d for _, d in G.degree()])\n\n43.69101262688784\n\n\nThere are many interesting properties related to the distribution of paths through the graph. For example, the diameter of a graph represents the longest of the shortest-paths that connect any node to another node in the Graph. Similarly, the average path length gives a measure of the average number of edges to be traversed to get from one node to another in the network. These attributes can be calculated with the nx.diameter and nx.average_shortest_path_length functions, respectively. Note however that these analyses require computing the shortest path between every pair of nodes in the network: this can be quite expensive for networks of this size! Since we’re interested in several analyses involving the shortest path length for all nodes in the network, we can instead compute this once and reuse the information to save computation time.\nLet’s start by computing the shortest path length for all pairs of nodes in the network:\n\nshortest_path_lengths = dict(nx.all_pairs_shortest_path_length(G))\n\nnx.all_pairs_shortest_path_length returns a dict-of-dict that maps a node u to all other nodes in the network, where the inner-most mapping returns the length of the shortest path between the two nodes. In other words, shortest_path_lengths[u][v] will return the shortest path length between any two pair of nodes u and v:\n\nshortest_path_lengths[0][42]  # Length of shortest path between nodes 0 and 42\n\n1\n\n\nNow let’s use shortest_path_lengths to perform our analyses, starting with the diameter of G. If we look carefully at the docstring for nx.diameter, we see that it is equivalent to the maximum eccentricity of the graph. It turns out that nx.eccentricity has an optional argument sp where we can pass in our pre-computed shortest_path_lengths to save the extra computation:\n\n# This is equivalent to `diameter = nx.diameter(G), but much more efficient since we're\n# reusing the pre-computed shortest path lengths!\ndiameter = max(nx.eccentricity(G, sp=shortest_path_lengths).values())\ndiameter\n\n8\n\n\nIn order to connect from one node to any other one we would have to traverse 8 edges or fewer.\nNext up, the average path length is found. Again, we could use nx.average_shortest_path_length to compute this directly, but it’s much more efficient to use the shortest_path_length that we’ve already computed:\n\n# Compute the average shortest path length for each node\naverage_path_lengths = [\n    np.mean(list(spl.values())) for spl in shortest_path_lengths.values()\n]\n# The average over all nodes\nnp.mean(average_path_lengths)\n\n3.691592636562027\n\n\nThis represents the average of the shortest path length for all pairs of nodes: in order to reach from one node to another node, roughly 3.6 edges will be traversed on average.\nThe above measures capture useful information about the network, but metrics like the average value represent only a moment of the distribution; it is also often valuable to look at the distribution itself. Again, we can construct a visualization of the distribution of shortest path lengths from our pre-computed dict-of-dicts:\n\n# We know the maximum shortest path length (the diameter), so create an array\n# to store values from 0 up to (and including) diameter\npath_lengths = np.zeros(diameter + 1, dtype=int)\n\n# Extract the frequency of shortest path lengths between two nodes\nfor pls in shortest_path_lengths.values():\n    pl, cnts = np.unique(list(pls.values()), return_counts=True)\n    path_lengths[pl] += cnts\n\n# Express frequency distribution as a percentage (ignoring path lengths of 0)\nfreq_percent = 100 * path_lengths[1:] / path_lengths[1:].sum()\n\n# Plot the frequency distribution (ignoring path lengths of 0) as a percentage\nfig, ax = plt.subplots(figsize=(12, 6))\nax.bar(np.arange(1, diameter + 1), height=freq_percent)\nax.set_title(\n    \"Distribution of shortest path length in G\", fontdict={\"size\": 22}, loc=\"center\"\n)\nax.set_xlabel(\"Shortest Path Length\", fontdict={\"size\": 16})\nax.set_ylabel(\"Frequency (%)\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe majority of the shortest path lengths are from \\(2\\) to \\(5\\) edges long. Also, it’s highly unlikely for a pair of nodes to have a shortest path of length 8 (diameter length) as the likelihood is less than \\(0.1\\)%.\nThe graph’s density is calculated here. Clearly, the graph is a very sparse one as: \\(density &lt; 1\\)\n\nnx.density(G)\n\n0.010819963503439287\n\n\nThe graph’s number of components are found below. As expected, the network consists of one giant component:\n\nnx.number_connected_components(G)\n\n1\n\n\n\n\n\nNow the centrality measures will be examined for the facebook graph\n\n\nDegree centrality assigns an importance score based simply on the number of links held by each node. In this analysis, that means that the higher the degree centrality of a node is, the more edges are connected to the particular node and thus the more neighbor nodes (facebook friends) this node has. In fact, the degree of centrality of a node is the fraction of nodes it is connected to. In other words, it is the percentage of the network that the particular node is connected to meaning being friends with.\nStarting, we find the nodes with the highest degree centralities. Specifically, the nodes with the 8 highest degree centralities are shown below together with the degree centrality:\n\ndegree_centrality = nx.centrality.degree_centrality(G)\n(sorted(degree_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.258791480931154),\n (1684, 0.1961367013372957),\n (1912, 0.18697374938088163),\n (3437, 0.13546310054482416),\n (0, 0.08593363051015354),\n (2543, 0.07280832095096582),\n (2347, 0.07206537890044576),\n (1888, 0.0629024269440317)]\n\n\nThat means that node \\(107\\) has the highest degree centrality with \\(0.259\\), meaning that this facebook user is friends with around the 26% of the whole network. Similarly, nodes \\(1684, 1912, 3437\\) and \\(0\\) also have very high degree centralities. However, that is well expected as those nodes are the ones whose facebook circles we examine. Very interesting is the fact that the nodes \\(2543, 2347, 1888\\) have some of the top 8 highest degree centralities even though we do not investigate their circles. In other words, those three nodes are very popular among the circles we examine now, meaning they have the most facebook friends inside this network apart from the spotlight nodes.\n\nNow we can also see the number of neighbors for the nodes with the highest degree centralities:\n\n\n(sorted(G.degree, key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 1045),\n (1684, 792),\n (1912, 755),\n (3437, 547),\n (0, 347),\n (2543, 294),\n (2347, 291),\n (1888, 254)]\n\n\nAs expected, node \\(107\\) has \\(1045\\) facebook friends which is the most any facebook user has in this analysis. Moreover, nodes \\(1684\\) and \\(1912\\) have more than \\(750\\) facebook friends in this network. Also, nodes \\(3437\\) and \\(0\\) have the following highest number of facebook friends in this network with \\(547\\) and \\(347\\) respectively. Lastly, the two most popular friends of spotlight nodes have around \\(290\\) facebook friends in this network.\nNow the distribution of degree centralities will be plotted:\n\nplt.figure(figsize=(12, 6))\nplt.hist(degree_centrality.values(), bins=25)\nplt.xticks(ticks=[0, 0.025, 0.05, 0.1, 0.15, 0.2])  # set the x axis ticks\nplt.title(\"Degree Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Degree Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIt is visible that the vast majority of facebook users have degree centralities of less than \\(0.05\\). In fact the majority has less than \\(0.0125\\). Actually, that makes sense because the network consists of friends lists of particular nodes, which are obviously the ones with the highest degree centralities. In other words, because only the friends list of particular nodes were used to create this particular network, plenty of nodes have extremely low degree centralities as they are not very interconnected in this network\nNow let’s check the users with highest degree centralities from the size of their nodes:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 1000 for v in degree_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nBetweenness centrality measures the number of times a node lies on the shortest path between other nodes, meaning it acts as a bridge. In detail, betweenness centrality of a node \\(v\\) is the percentage of all the shortest paths of any two nodes (apart from \\(v\\)), which pass through \\(v\\). Specifically, in the facebook graph this measure is associated with the user’s ability to influence others. A user with a high betweenness centrality acts as a bridge to many users that are not friends and thus has the ability to influence them by conveying information (e.g. by posting something or sharing a post) or even connect them via the user’s circle (which would reduce the user’s betweeness centrality after).\nNow, the nodes with the \\(8\\) highest betweenness centralities will be calculated and shown with their centrality values:\n\nbetweenness_centrality = nx.centrality.betweenness_centrality(G)\n(sorted(betweenness_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.4805180785560152),\n (1684, 0.3377974497301992),\n (3437, 0.23611535735892905),\n (1912, 0.2292953395868782),\n (1085, 0.14901509211665306),\n (0, 0.14630592147442917),\n (698, 0.11533045020560802),\n (567, 0.09631033121856215)]\n\n\nLooking at the results, the node \\(107\\) has a betweenness centrality of \\(0.48\\), meaning it lies on almost half of the total shortest paths between other nodes. Also, combining the knowledge of the degree centrality:\n\nNodes \\(0, 107, 1684, 1912, 3437\\) have both the highest degree and betweenness centralities and are spotlight nodes. That indicates that those nodes are both the most popular ones in this network and can also influence and spread information in the network. However, those are some of the nodes whose friends list consist the network and as a result it is an expected finding.\nNodes \\(567, 1085\\) are not spotlight nodes, have some of the highest betweenness centralities and have not the highest degree centralities. That means that even though those nodes are not the most popular users in the network, they have the most influence in this network among friends of spotlight nodes when it comes to spreading information.\nNode \\(698\\) is a spotlight node and has a very high betweenness centrality even though it has not the highest degree centralities. In other words, this node does not have a very large friends list on facebook. However, the user’s whole friend list is a part of the network and thus the user could connect different circles in this network by being the middleman.\n\nMoving on, the distribution of betweenness centralities will be plotted:\n\nplt.figure(figsize=(12, 6))\nplt.hist(betweenness_centrality.values(), bins=100)\nplt.xticks(ticks=[0, 0.02, 0.1, 0.2, 0.3, 0.4, 0.5])  # set the x axis ticks\nplt.title(\"Betweenness Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Betweenness Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAs we can see, the vast majority of betweenness centralities is below \\(0.01\\). That makes sense as the graph is very sparse and thus most nodes do not act as bridges in shortest paths. However, that also results in some nodes having extremely high betweenness centralities as for example node \\(107\\) with \\(0.48\\) and node \\(1684\\) with \\(0.34\\) betweenness centrality.\nWe can also get an image on the nodes with the highest betweenness centralities and where they are located in the network. It is clear that they are the bridges from one community to another:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 1200 for v in betweenness_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nCloseness centrality scores each node based on their ‘closeness’ to all other nodes in the network. For a node \\(v\\), its closeness centrality measures the average farness to all other nodes. In other words, the higher the closeness centrality of \\(v\\), the closer it is located to the center of the network.\nThe closeness centrality measure is very important for the monitoring of the spread of false information (e.g. fake news) or viruses (e.g. malicious links that gain control of the facebook account in this case). Let’s examine the example of fake news. If the user with the highest closeness centrality measure started spreading some fake news information (sharing or creating a post), the whole network would get missinformed the quickest possible. However, if a user with very low closeness centrality would try the same, the spread of the missinformation to the whole network would be much slower. That is because the false information would have to firstly reach a user with high closeness centrality that would spread it to many different parts of the network.\nThe nodes with the highest closeness centralities will be found now:\n\ncloseness_centrality = nx.centrality.closeness_centrality(G)\n(sorted(closeness_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.45969945355191255),\n (58, 0.3974018305284913),\n (428, 0.3948371956585509),\n (563, 0.3939127889961955),\n (1684, 0.39360561458231796),\n (171, 0.37049270575282134),\n (348, 0.36991572004397216),\n (483, 0.3698479575013739)]\n\n\nInspecting the users with the highest closeness centralities, we understand that there is not a huge gap between them in contrast to the previous metrics. Also, the nodes \\(107, 1684, 348\\) are the only spotlight nodes found in the ones with the highest closeness centralities. That means that a node that has many friends is not necessary close to the center of the network.\nAlso, the average distance of a particular node \\(v\\) to any other node can be found easily with the formula:\n\\[\\frac{1}{\\text{closeness centrality}(v)}\\]\n\n1 / closeness_centrality[107]\n\n2.1753343239227343\n\n\nThe distance from node \\(107\\) to a random node is around two hops\nFurthermore, the distribution of the closeness centralities:\n\nplt.figure(figsize=(12, 6))\nplt.hist(closeness_centrality.values(), bins=60)\nplt.title(\"Closeness Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Closeness Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe closeness centralities are distributed over various values from \\(0.17\\) to \\(0.46\\). In fact, the majority of them are found between \\(0.25\\) and \\(0.3\\). That means that the majority of nodes are relatively close to the center of the network and thus close to other nodes in general. However, there are some communities that are located further away, whose nodes would have the minimum closeness centralities, as seen below:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 50 for v in closeness_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nEigenvector centrality is the metric to show how connected a node is to other important nodes in the network. It measures a node’s influence based on how well it is connected inside the network and how many links its connections have and so on. This measure can identify the nodes with the most influence over the whole network. A high eigenvector centrality means that the node is connected to other nodes who themselves have high eigenvector centralities. In this facebook analysis, the measure is associated with the users ability to influence the whole graph and thus the users with the highest eigenvector centralities are the most important nodes in this network.\nThe nodes with the highest eigenvector centralities will be examined now:\n\neigenvector_centrality = nx.centrality.eigenvector_centrality(G)\n(sorted(eigenvector_centrality.items(), key=lambda item: item[1], reverse=True))[:10]\n\n[(1912, 0.09540696149067629),\n (2266, 0.08698327767886552),\n (2206, 0.08605239270584342),\n (2233, 0.08517340912756598),\n (2464, 0.08427877475676092),\n (2142, 0.08419311897991795),\n (2218, 0.0841557356805503),\n (2078, 0.08413617041724977),\n (2123, 0.08367141238206224),\n (1993, 0.0835324284081597)]\n\n\nChecking the results:\n\nNode \\(1912\\) has the highest eigenvector centrality with \\(0.095\\). This node is also a spotlight node and can surely be considered the most important node in this network in terms of overall influence to the whole network. In fact, this node also has some of the highest degree centralities and betweenness centralities, making the user very popular and influencious to other nodes.\nNodes \\(1993, 2078, 2206, 2123, 2142, 2218, 2233, 2266, 2464\\), even though they are not spotlight nodes, have some of the highest eigenvector centralities with around \\(0.83-0.87\\). Very interesting is the fact that all those nodes are identified for the first time, meaning they have neither the heighest degree, betweenness or closeness centralities in this graph. That leads to the conclusion that those nodes are very likely to be connected to the node \\(1912\\) and as a result have very high eigenvector centralities.\n\nChecking if those nodes are connected to the most important node \\(1912\\), the hypothesis is correct:\n\nhigh_eigenvector_centralities = (\n    sorted(eigenvector_centrality.items(), key=lambda item: item[1], reverse=True)\n)[1:10]  # 2nd to 10th nodes with heighest eigenvector centralities\nhigh_eigenvector_nodes = [\n    tuple[0] for tuple in high_eigenvector_centralities\n]  # set list as [2266, 2206, 2233, 2464, 2142, 2218, 2078, 2123, 1993]\nneighbors_1912 = [n for n in G.neighbors(1912)]  # list with all nodes connected to 1912\nall(\n    item in neighbors_1912 for item in high_eigenvector_nodes\n)  # check if items in list high_eigenvector_nodes exist in list neighbors_1912\n\nTrue\n\n\nLet’s check the distribution of the eigenvector centralities:\n\nplt.figure(figsize=(12, 6))\nplt.hist(eigenvector_centrality.values(), bins=60)\nplt.xticks(ticks=[0, 0.01, 0.02, 0.04, 0.06, 0.08])  # set the x axis ticks\nplt.title(\"Eigenvector Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Eigenvector Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAs shown in the distribution histogram, the vast majority of eigenvector centralities are below \\(0.005\\) and are actually almost \\(0\\). However, we can also see different values of eigenvector centralities as there are tiny bins all over the x axis.\nNow we can identify the eigenvector centralities of nodes based on their size in the following representation:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 4000 for v in eigenvector_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\nThe clustering coefficient of a node \\(v\\) is defined as the probability that two randomly selected friends of \\(v\\) are friends with each other. As a result, the average clustering coefficient is the average of clustering coefficients of all the nodes. The closer the average clustering coefficient is to \\(1\\), the more complete the graph will be because there’s just one giant component. Lastly, it is a sign of triadic closure because the more complete the graph is, the more triangles will usually arise.\n\nnx.average_clustering(G)\n\n0.6055467186200876\n\n\nNow the clustering coefficient distribution will be displayed:\n\nplt.figure(figsize=(12, 6))\nplt.hist(nx.clustering(G).values(), bins=50)\nplt.title(\"Clustering Coefficient Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Clustering Coefficient\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\\(50\\) bins were used to showcase the distribution. The bin with the highest counts concerns nodes with clustering coefficient close to \\(1\\) as there are more than two-hundred-fifty nodes in that bin. In addition, the bins of clustering coefficient between \\(0.4\\) and \\(0.8\\) contain the majority of nodes by far.\nThe number of unique triangles in the network are found next:\n\ntriangles_per_node = list(nx.triangles(G).values())\n# divide by 3 because each triangle is counted once for each node\nsum(triangles_per_node) / 3\n\n1612010.0\n\n\nNow the average number of triangles that a node is a part of:\n\nnp.mean(triangles_per_node)\n\n1197.3334983906907\n\n\nDue to having some nodes that belong to a great many triangles, the metric of median will give us a better understanding:\n\nnp.median(triangles_per_node)\n\n161.0\n\n\nIn fact, the median value is just \\(161\\) triangles, when the mean is around \\(1197\\) triangles that a node is part of. That means that the majority of nodes of the network belong to extremely few triangles, whereas some nodes are part of a plethora of triangles (which are extreme values that increase the mean)\nIn conclusion, the high average clustering coefficient together with the huge number of triangles are signs of the triadic closure. In detail, the triadic closure means that as time goes on, new edges tend to form between two users that have one or more mutual friends. That can be explained by the fact that Facebook usually suggests new friends to a user when there are many mutual friends between the user and the new friend to be added. Also, there is a source of latent stress. For example, if node \\(A\\) is friends with node \\(B\\) and \\(C\\), some tension builds up if \\(B\\) and \\(C\\) are not friends with each other.\n\n\n\nFirst of all, an edge joining two nodes A and B in the graph is considered a bridge, if deleting the edge would cause A and B to lie in two different components. Now it is checked if there are any bridges in this network:\n\nnx.has_bridges(G)\n\nTrue\n\n\nActually, there are bridges in the network. Now the edges that are bridges will be saved in a list and the number of them is printed:\n\nbridges = list(nx.bridges(G))\nlen(bridges)\n\n75\n\n\nThe existence of so many bridges is due to the fact that this network only contains the spotlight nodes and the friends of them. As a result, some friends of spotlight nodes are only connected to a spotlight node, making that edge a bridge.\nAlso, the edges that are local bridges are saved in a list and their number is printed. In detaill, an edge joining two nodes \\(C\\) and \\(D\\) in a graph is a local bridge, if its endpoints \\(C\\) and \\(D\\) have no friends in common. Very importantly, an edge that is a bridge is also a local bridge. Thus, this list contains all the above bridges as well:\n\nlocal_bridges = list(nx.local_bridges(G, with_span=False))\nlen(local_bridges)\n\n78\n\n\nShowcasing the bridges and local bridges in the network now. The bridges can be seen with the red color and the local bridges with the green color. Black edges are neither local bridges nor bridges.\nIt is clear that all the bridges concern nodes that are only connected to a spotlight node (have a degree of \\(1\\))\n\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=10, with_labels=False, width=0.15)\nnx.draw_networkx_edges(\n    G, pos, edgelist=local_bridges, width=0.5, edge_color=\"lawngreen\"\n)  # green color for local bridges\nnx.draw_networkx_edges(\n    G, pos, edgelist=bridges, width=0.5, edge_color=\"r\"\n)  # red color for bridges\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nAssortativity describes the preference for a network’s nodes to attach to others that are similar in some way.\nThe assortativity in terms of nodes degrees is found with two ways:\n\nnx.degree_assortativity_coefficient(G)\n\n0.06357722918564943\n\n\n\n# use the potentially faster scipy.stats.pearsonr function.\nnx.degree_pearson_correlation_coefficient(G)\n\n0.06357722918564918\n\n\nIn fact, the assortativity coefficient is the Pearson correlation coefficient of degree between pairs of linked nodes. That means that it takes values from \\(-1\\) to \\(1\\). In detail, a positive assortativity coefficient indicates a correlation between nodes of similar degree, while a negative indicates correlation between nodes of different degrees.\nIn our case the assortativity coefficient is around \\(0.064\\), which is almost 0. That means that the network is almost non-assortative, and we cannot correlate linked nodes based on their degrees. In other words, we can not draw conclusions on the number of friends of a user from his/her friends’ number of friends (friends degree). That makes sense since we only use the friends list of spotlight nodes, non spotlight nodes will tend to have much fewer friends.\n\n\n\nA community is a group of nodes, so that nodes inside the group are connected with many more edges than between groups. Two different algorithms will be used for communities detection in this network\nFirstly, a semi-synchronous label propagation method 1 is used to detect the communities.\nThis function determines by itself the number of communities that will be detected. Now the communities will be iterated through and a colors list will be created to contain the same color for nodes that belong to the same community. Also, the number of communities is printed:\n\ncolors = [\"\" for x in range(G.number_of_nodes())]  # initialize colors list\ncounter = 0\nfor com in nx.community.label_propagation_communities(G):\n    color = \"#%06X\" % randint(0, 0xFFFFFF)  # creates random RGB color\n    counter += 1\n    for node in list(\n        com\n    ):  # fill colors list with the particular color for the community nodes\n        colors[node] = color\ncounter\n\n44\n\n\nIn detail, \\(44\\) communities were detected. Now the communities are showcased in the graph. Each community is depicted with a different color and its nodes are usually located close to each other:\n\nplt.figure(figsize=(15, 9))\nplt.axis(\"off\")\nnx.draw_networkx(\n    G, pos=pos, node_size=10, with_labels=False, width=0.15, node_color=colors\n)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nNext, the asynchronous fluid communities algorithm 2 is used.\nWith this function, we can decide the number of communities to be detected. Let’s say that \\(8\\) communities is the number we want. Again, the communities will be iterated through and a colors list will be created to contain the same color for nodes that belong to the same community.\n\ncolors = [\"\" for x in range(G.number_of_nodes())]\nfor com in nx.community.asyn_fluidc(G, 8, seed=0):\n    color = \"#%06X\" % randint(0, 0xFFFFFF)  # creates random RGB color\n    for node in list(com):\n        colors[node] = color\n\nNow the \\(8\\) communities are shown in the graph. Again, each community is depicted with a different color:\n\nplt.figure(figsize=(15, 9))\nplt.axis(\"off\")\nnx.draw_networkx(\n    G, pos=pos, node_size=10, with_labels=False, width=0.15, node_color=colors\n)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nCambridge-intelligence"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#import-packages",
    "href": "sessions/s09_networkx_data/facebook.html#import-packages",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom random import randint"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#analysis",
    "href": "sessions/s09_networkx_data/facebook.html#analysis",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "The edges are loaded from the data folder and saved in a dataframe. Each edge is a new row and for each edge there is a start_node and an end_node column\n\nfacebook = pd.read_csv(\n    \"../../data/facebook_combined.txt.gz\",\n    compression=\"gzip\",\n    sep=\" \",\n    names=[\"start_node\", \"end_node\"],\n)\nfacebook\n\n\n\n\n\n\n\n\nstart_node\nend_node\n\n\n\n\n0\n0\n1\n\n\n1\n0\n2\n\n\n2\n0\n3\n\n\n3\n0\n4\n\n\n4\n0\n5\n\n\n...\n...\n...\n\n\n88229\n4026\n4030\n\n\n88230\n4027\n4031\n\n\n88231\n4027\n4032\n\n\n88232\n4027\n4038\n\n\n88233\n4031\n4038\n\n\n\n\n88234 rows × 2 columns\n\n\n\nThe graph is created from the facebook dataframe of the edges:\n\nG = nx.from_pandas_edgelist(facebook, \"start_node\", \"end_node\")"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#visualizing-the-graph",
    "href": "sessions/s09_networkx_data/facebook.html#visualizing-the-graph",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "Let’s start our exploration by visualizing the graph. Visualization plays a central role in exploratory data analysis to help get a qualitative feel for the data.\nSince we don’t have any real sense of structure in the data, let’s start by viewing the graph with random_layout, which is among the fastest of the layout functions.\n\nfig, ax = plt.subplots(figsize=(15, 9))\nax.axis(\"off\")\nplot_options = {\"node_size\": 10, \"with_labels\": False, \"width\": 0.15}\nnx.draw_networkx(G, pos=nx.random_layout(G), ax=ax, **plot_options)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe resulting image is… not very useful. Graph visualizations of this kind are sometimes colloquially referred to as “hairballs” due to the overlapping edges resulting in an entangled mess.\nIt’s clear that we need to impose more structure on the positioning of the if we want to get a sense for the data. For this, we can use the spring_layout function which is the default layout function for the networkx drawing module. The spring_layout function has the advantage that it takes into account the nodes and edges to compute locations of the nodes. The downside however, is that this process is much more computationally expensive, and can be quite slow for graphs with 100’s of nodes and 1000’s of edges.\nSince our dataset has over 80k edges, we will limit the number of iterations used in the spring_layout function to reduce the computation time. We will also save the computed layout so we can use it for future visualizations.\n\npos = nx.spring_layout(G, iterations=15, seed=1721)\nfig, ax = plt.subplots(figsize=(15, 9))\nax.axis(\"off\")\nnx.draw_networkx(G, pos=pos, ax=ax, **plot_options)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThis visualization is much more useful than the previous one! Already we can glean something about the structure of the network; for example, many of the nodes seem to be highly connected, as we might expect for a social network. We also get a sense that the nodes tend to form clusters. The spring_layout serves to give a qualitative sense of clustering, but it is not designed for repeatable, qualitative clustering analysis. We’ll revisit evaluating network clustering later in the analysis"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#basic-topological-attributes",
    "href": "sessions/s09_networkx_data/facebook.html#basic-topological-attributes",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "Total number of nodes in network:\n\nG.number_of_nodes()\n\n4039\n\n\nTotal number of edges:\n\nG.number_of_edges()\n\n88234\n\n\nAlso, the average degree of a node can be seen.\n\nOn average, a node is connected to almost 44 other nodes, also known as neighbors of the node.\nThis has been calculated by creating a list of all the degrees of the nodes and using numpy.array to find the mean of the created list.\n\n\nnp.mean([d for _, d in G.degree()])\n\n43.69101262688784\n\n\nThere are many interesting properties related to the distribution of paths through the graph. For example, the diameter of a graph represents the longest of the shortest-paths that connect any node to another node in the Graph. Similarly, the average path length gives a measure of the average number of edges to be traversed to get from one node to another in the network. These attributes can be calculated with the nx.diameter and nx.average_shortest_path_length functions, respectively. Note however that these analyses require computing the shortest path between every pair of nodes in the network: this can be quite expensive for networks of this size! Since we’re interested in several analyses involving the shortest path length for all nodes in the network, we can instead compute this once and reuse the information to save computation time.\nLet’s start by computing the shortest path length for all pairs of nodes in the network:\n\nshortest_path_lengths = dict(nx.all_pairs_shortest_path_length(G))\n\nnx.all_pairs_shortest_path_length returns a dict-of-dict that maps a node u to all other nodes in the network, where the inner-most mapping returns the length of the shortest path between the two nodes. In other words, shortest_path_lengths[u][v] will return the shortest path length between any two pair of nodes u and v:\n\nshortest_path_lengths[0][42]  # Length of shortest path between nodes 0 and 42\n\n1\n\n\nNow let’s use shortest_path_lengths to perform our analyses, starting with the diameter of G. If we look carefully at the docstring for nx.diameter, we see that it is equivalent to the maximum eccentricity of the graph. It turns out that nx.eccentricity has an optional argument sp where we can pass in our pre-computed shortest_path_lengths to save the extra computation:\n\n# This is equivalent to `diameter = nx.diameter(G), but much more efficient since we're\n# reusing the pre-computed shortest path lengths!\ndiameter = max(nx.eccentricity(G, sp=shortest_path_lengths).values())\ndiameter\n\n8\n\n\nIn order to connect from one node to any other one we would have to traverse 8 edges or fewer.\nNext up, the average path length is found. Again, we could use nx.average_shortest_path_length to compute this directly, but it’s much more efficient to use the shortest_path_length that we’ve already computed:\n\n# Compute the average shortest path length for each node\naverage_path_lengths = [\n    np.mean(list(spl.values())) for spl in shortest_path_lengths.values()\n]\n# The average over all nodes\nnp.mean(average_path_lengths)\n\n3.691592636562027\n\n\nThis represents the average of the shortest path length for all pairs of nodes: in order to reach from one node to another node, roughly 3.6 edges will be traversed on average.\nThe above measures capture useful information about the network, but metrics like the average value represent only a moment of the distribution; it is also often valuable to look at the distribution itself. Again, we can construct a visualization of the distribution of shortest path lengths from our pre-computed dict-of-dicts:\n\n# We know the maximum shortest path length (the diameter), so create an array\n# to store values from 0 up to (and including) diameter\npath_lengths = np.zeros(diameter + 1, dtype=int)\n\n# Extract the frequency of shortest path lengths between two nodes\nfor pls in shortest_path_lengths.values():\n    pl, cnts = np.unique(list(pls.values()), return_counts=True)\n    path_lengths[pl] += cnts\n\n# Express frequency distribution as a percentage (ignoring path lengths of 0)\nfreq_percent = 100 * path_lengths[1:] / path_lengths[1:].sum()\n\n# Plot the frequency distribution (ignoring path lengths of 0) as a percentage\nfig, ax = plt.subplots(figsize=(12, 6))\nax.bar(np.arange(1, diameter + 1), height=freq_percent)\nax.set_title(\n    \"Distribution of shortest path length in G\", fontdict={\"size\": 22}, loc=\"center\"\n)\nax.set_xlabel(\"Shortest Path Length\", fontdict={\"size\": 16})\nax.set_ylabel(\"Frequency (%)\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe majority of the shortest path lengths are from \\(2\\) to \\(5\\) edges long. Also, it’s highly unlikely for a pair of nodes to have a shortest path of length 8 (diameter length) as the likelihood is less than \\(0.1\\)%.\nThe graph’s density is calculated here. Clearly, the graph is a very sparse one as: \\(density &lt; 1\\)\n\nnx.density(G)\n\n0.010819963503439287\n\n\nThe graph’s number of components are found below. As expected, the network consists of one giant component:\n\nnx.number_connected_components(G)\n\n1"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#centrality-measures",
    "href": "sessions/s09_networkx_data/facebook.html#centrality-measures",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "Now the centrality measures will be examined for the facebook graph\n\n\nDegree centrality assigns an importance score based simply on the number of links held by each node. In this analysis, that means that the higher the degree centrality of a node is, the more edges are connected to the particular node and thus the more neighbor nodes (facebook friends) this node has. In fact, the degree of centrality of a node is the fraction of nodes it is connected to. In other words, it is the percentage of the network that the particular node is connected to meaning being friends with.\nStarting, we find the nodes with the highest degree centralities. Specifically, the nodes with the 8 highest degree centralities are shown below together with the degree centrality:\n\ndegree_centrality = nx.centrality.degree_centrality(G)\n(sorted(degree_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.258791480931154),\n (1684, 0.1961367013372957),\n (1912, 0.18697374938088163),\n (3437, 0.13546310054482416),\n (0, 0.08593363051015354),\n (2543, 0.07280832095096582),\n (2347, 0.07206537890044576),\n (1888, 0.0629024269440317)]\n\n\nThat means that node \\(107\\) has the highest degree centrality with \\(0.259\\), meaning that this facebook user is friends with around the 26% of the whole network. Similarly, nodes \\(1684, 1912, 3437\\) and \\(0\\) also have very high degree centralities. However, that is well expected as those nodes are the ones whose facebook circles we examine. Very interesting is the fact that the nodes \\(2543, 2347, 1888\\) have some of the top 8 highest degree centralities even though we do not investigate their circles. In other words, those three nodes are very popular among the circles we examine now, meaning they have the most facebook friends inside this network apart from the spotlight nodes.\n\nNow we can also see the number of neighbors for the nodes with the highest degree centralities:\n\n\n(sorted(G.degree, key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 1045),\n (1684, 792),\n (1912, 755),\n (3437, 547),\n (0, 347),\n (2543, 294),\n (2347, 291),\n (1888, 254)]\n\n\nAs expected, node \\(107\\) has \\(1045\\) facebook friends which is the most any facebook user has in this analysis. Moreover, nodes \\(1684\\) and \\(1912\\) have more than \\(750\\) facebook friends in this network. Also, nodes \\(3437\\) and \\(0\\) have the following highest number of facebook friends in this network with \\(547\\) and \\(347\\) respectively. Lastly, the two most popular friends of spotlight nodes have around \\(290\\) facebook friends in this network.\nNow the distribution of degree centralities will be plotted:\n\nplt.figure(figsize=(12, 6))\nplt.hist(degree_centrality.values(), bins=25)\nplt.xticks(ticks=[0, 0.025, 0.05, 0.1, 0.15, 0.2])  # set the x axis ticks\nplt.title(\"Degree Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Degree Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nIt is visible that the vast majority of facebook users have degree centralities of less than \\(0.05\\). In fact the majority has less than \\(0.0125\\). Actually, that makes sense because the network consists of friends lists of particular nodes, which are obviously the ones with the highest degree centralities. In other words, because only the friends list of particular nodes were used to create this particular network, plenty of nodes have extremely low degree centralities as they are not very interconnected in this network\nNow let’s check the users with highest degree centralities from the size of their nodes:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 1000 for v in degree_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nBetweenness centrality measures the number of times a node lies on the shortest path between other nodes, meaning it acts as a bridge. In detail, betweenness centrality of a node \\(v\\) is the percentage of all the shortest paths of any two nodes (apart from \\(v\\)), which pass through \\(v\\). Specifically, in the facebook graph this measure is associated with the user’s ability to influence others. A user with a high betweenness centrality acts as a bridge to many users that are not friends and thus has the ability to influence them by conveying information (e.g. by posting something or sharing a post) or even connect them via the user’s circle (which would reduce the user’s betweeness centrality after).\nNow, the nodes with the \\(8\\) highest betweenness centralities will be calculated and shown with their centrality values:\n\nbetweenness_centrality = nx.centrality.betweenness_centrality(G)\n(sorted(betweenness_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.4805180785560152),\n (1684, 0.3377974497301992),\n (3437, 0.23611535735892905),\n (1912, 0.2292953395868782),\n (1085, 0.14901509211665306),\n (0, 0.14630592147442917),\n (698, 0.11533045020560802),\n (567, 0.09631033121856215)]\n\n\nLooking at the results, the node \\(107\\) has a betweenness centrality of \\(0.48\\), meaning it lies on almost half of the total shortest paths between other nodes. Also, combining the knowledge of the degree centrality:\n\nNodes \\(0, 107, 1684, 1912, 3437\\) have both the highest degree and betweenness centralities and are spotlight nodes. That indicates that those nodes are both the most popular ones in this network and can also influence and spread information in the network. However, those are some of the nodes whose friends list consist the network and as a result it is an expected finding.\nNodes \\(567, 1085\\) are not spotlight nodes, have some of the highest betweenness centralities and have not the highest degree centralities. That means that even though those nodes are not the most popular users in the network, they have the most influence in this network among friends of spotlight nodes when it comes to spreading information.\nNode \\(698\\) is a spotlight node and has a very high betweenness centrality even though it has not the highest degree centralities. In other words, this node does not have a very large friends list on facebook. However, the user’s whole friend list is a part of the network and thus the user could connect different circles in this network by being the middleman.\n\nMoving on, the distribution of betweenness centralities will be plotted:\n\nplt.figure(figsize=(12, 6))\nplt.hist(betweenness_centrality.values(), bins=100)\nplt.xticks(ticks=[0, 0.02, 0.1, 0.2, 0.3, 0.4, 0.5])  # set the x axis ticks\nplt.title(\"Betweenness Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Betweenness Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAs we can see, the vast majority of betweenness centralities is below \\(0.01\\). That makes sense as the graph is very sparse and thus most nodes do not act as bridges in shortest paths. However, that also results in some nodes having extremely high betweenness centralities as for example node \\(107\\) with \\(0.48\\) and node \\(1684\\) with \\(0.34\\) betweenness centrality.\nWe can also get an image on the nodes with the highest betweenness centralities and where they are located in the network. It is clear that they are the bridges from one community to another:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 1200 for v in betweenness_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nCloseness centrality scores each node based on their ‘closeness’ to all other nodes in the network. For a node \\(v\\), its closeness centrality measures the average farness to all other nodes. In other words, the higher the closeness centrality of \\(v\\), the closer it is located to the center of the network.\nThe closeness centrality measure is very important for the monitoring of the spread of false information (e.g. fake news) or viruses (e.g. malicious links that gain control of the facebook account in this case). Let’s examine the example of fake news. If the user with the highest closeness centrality measure started spreading some fake news information (sharing or creating a post), the whole network would get missinformed the quickest possible. However, if a user with very low closeness centrality would try the same, the spread of the missinformation to the whole network would be much slower. That is because the false information would have to firstly reach a user with high closeness centrality that would spread it to many different parts of the network.\nThe nodes with the highest closeness centralities will be found now:\n\ncloseness_centrality = nx.centrality.closeness_centrality(G)\n(sorted(closeness_centrality.items(), key=lambda item: item[1], reverse=True))[:8]\n\n[(107, 0.45969945355191255),\n (58, 0.3974018305284913),\n (428, 0.3948371956585509),\n (563, 0.3939127889961955),\n (1684, 0.39360561458231796),\n (171, 0.37049270575282134),\n (348, 0.36991572004397216),\n (483, 0.3698479575013739)]\n\n\nInspecting the users with the highest closeness centralities, we understand that there is not a huge gap between them in contrast to the previous metrics. Also, the nodes \\(107, 1684, 348\\) are the only spotlight nodes found in the ones with the highest closeness centralities. That means that a node that has many friends is not necessary close to the center of the network.\nAlso, the average distance of a particular node \\(v\\) to any other node can be found easily with the formula:\n\\[\\frac{1}{\\text{closeness centrality}(v)}\\]\n\n1 / closeness_centrality[107]\n\n2.1753343239227343\n\n\nThe distance from node \\(107\\) to a random node is around two hops\nFurthermore, the distribution of the closeness centralities:\n\nplt.figure(figsize=(12, 6))\nplt.hist(closeness_centrality.values(), bins=60)\nplt.title(\"Closeness Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Closeness Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nThe closeness centralities are distributed over various values from \\(0.17\\) to \\(0.46\\). In fact, the majority of them are found between \\(0.25\\) and \\(0.3\\). That means that the majority of nodes are relatively close to the center of the network and thus close to other nodes in general. However, there are some communities that are located further away, whose nodes would have the minimum closeness centralities, as seen below:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 50 for v in closeness_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nEigenvector centrality is the metric to show how connected a node is to other important nodes in the network. It measures a node’s influence based on how well it is connected inside the network and how many links its connections have and so on. This measure can identify the nodes with the most influence over the whole network. A high eigenvector centrality means that the node is connected to other nodes who themselves have high eigenvector centralities. In this facebook analysis, the measure is associated with the users ability to influence the whole graph and thus the users with the highest eigenvector centralities are the most important nodes in this network.\nThe nodes with the highest eigenvector centralities will be examined now:\n\neigenvector_centrality = nx.centrality.eigenvector_centrality(G)\n(sorted(eigenvector_centrality.items(), key=lambda item: item[1], reverse=True))[:10]\n\n[(1912, 0.09540696149067629),\n (2266, 0.08698327767886552),\n (2206, 0.08605239270584342),\n (2233, 0.08517340912756598),\n (2464, 0.08427877475676092),\n (2142, 0.08419311897991795),\n (2218, 0.0841557356805503),\n (2078, 0.08413617041724977),\n (2123, 0.08367141238206224),\n (1993, 0.0835324284081597)]\n\n\nChecking the results:\n\nNode \\(1912\\) has the highest eigenvector centrality with \\(0.095\\). This node is also a spotlight node and can surely be considered the most important node in this network in terms of overall influence to the whole network. In fact, this node also has some of the highest degree centralities and betweenness centralities, making the user very popular and influencious to other nodes.\nNodes \\(1993, 2078, 2206, 2123, 2142, 2218, 2233, 2266, 2464\\), even though they are not spotlight nodes, have some of the highest eigenvector centralities with around \\(0.83-0.87\\). Very interesting is the fact that all those nodes are identified for the first time, meaning they have neither the heighest degree, betweenness or closeness centralities in this graph. That leads to the conclusion that those nodes are very likely to be connected to the node \\(1912\\) and as a result have very high eigenvector centralities.\n\nChecking if those nodes are connected to the most important node \\(1912\\), the hypothesis is correct:\n\nhigh_eigenvector_centralities = (\n    sorted(eigenvector_centrality.items(), key=lambda item: item[1], reverse=True)\n)[1:10]  # 2nd to 10th nodes with heighest eigenvector centralities\nhigh_eigenvector_nodes = [\n    tuple[0] for tuple in high_eigenvector_centralities\n]  # set list as [2266, 2206, 2233, 2464, 2142, 2218, 2078, 2123, 1993]\nneighbors_1912 = [n for n in G.neighbors(1912)]  # list with all nodes connected to 1912\nall(\n    item in neighbors_1912 for item in high_eigenvector_nodes\n)  # check if items in list high_eigenvector_nodes exist in list neighbors_1912\n\nTrue\n\n\nLet’s check the distribution of the eigenvector centralities:\n\nplt.figure(figsize=(12, 6))\nplt.hist(eigenvector_centrality.values(), bins=60)\nplt.xticks(ticks=[0, 0.01, 0.02, 0.04, 0.06, 0.08])  # set the x axis ticks\nplt.title(\"Eigenvector Centrality Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Eigenvector Centrality\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAs shown in the distribution histogram, the vast majority of eigenvector centralities are below \\(0.005\\) and are actually almost \\(0\\). However, we can also see different values of eigenvector centralities as there are tiny bins all over the x axis.\nNow we can identify the eigenvector centralities of nodes based on their size in the following representation:\n\n# set up nodes size for a nice graph representation\nnode_size = [v * 4000 for v in eigenvector_centrality.values()]\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)\nplt.axis(\"off\")\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#clustering-effects",
    "href": "sessions/s09_networkx_data/facebook.html#clustering-effects",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "The clustering coefficient of a node \\(v\\) is defined as the probability that two randomly selected friends of \\(v\\) are friends with each other. As a result, the average clustering coefficient is the average of clustering coefficients of all the nodes. The closer the average clustering coefficient is to \\(1\\), the more complete the graph will be because there’s just one giant component. Lastly, it is a sign of triadic closure because the more complete the graph is, the more triangles will usually arise.\n\nnx.average_clustering(G)\n\n0.6055467186200876\n\n\nNow the clustering coefficient distribution will be displayed:\n\nplt.figure(figsize=(12, 6))\nplt.hist(nx.clustering(G).values(), bins=50)\nplt.title(\"Clustering Coefficient Histogram \", fontdict={\"size\": 22}, loc=\"center\")\nplt.xlabel(\"Clustering Coefficient\", fontdict={\"size\": 16})\nplt.ylabel(\"Counts\", fontdict={\"size\": 16})\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\\(50\\) bins were used to showcase the distribution. The bin with the highest counts concerns nodes with clustering coefficient close to \\(1\\) as there are more than two-hundred-fifty nodes in that bin. In addition, the bins of clustering coefficient between \\(0.4\\) and \\(0.8\\) contain the majority of nodes by far.\nThe number of unique triangles in the network are found next:\n\ntriangles_per_node = list(nx.triangles(G).values())\n# divide by 3 because each triangle is counted once for each node\nsum(triangles_per_node) / 3\n\n1612010.0\n\n\nNow the average number of triangles that a node is a part of:\n\nnp.mean(triangles_per_node)\n\n1197.3334983906907\n\n\nDue to having some nodes that belong to a great many triangles, the metric of median will give us a better understanding:\n\nnp.median(triangles_per_node)\n\n161.0\n\n\nIn fact, the median value is just \\(161\\) triangles, when the mean is around \\(1197\\) triangles that a node is part of. That means that the majority of nodes of the network belong to extremely few triangles, whereas some nodes are part of a plethora of triangles (which are extreme values that increase the mean)\nIn conclusion, the high average clustering coefficient together with the huge number of triangles are signs of the triadic closure. In detail, the triadic closure means that as time goes on, new edges tend to form between two users that have one or more mutual friends. That can be explained by the fact that Facebook usually suggests new friends to a user when there are many mutual friends between the user and the new friend to be added. Also, there is a source of latent stress. For example, if node \\(A\\) is friends with node \\(B\\) and \\(C\\), some tension builds up if \\(B\\) and \\(C\\) are not friends with each other."
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#bridges",
    "href": "sessions/s09_networkx_data/facebook.html#bridges",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "First of all, an edge joining two nodes A and B in the graph is considered a bridge, if deleting the edge would cause A and B to lie in two different components. Now it is checked if there are any bridges in this network:\n\nnx.has_bridges(G)\n\nTrue\n\n\nActually, there are bridges in the network. Now the edges that are bridges will be saved in a list and the number of them is printed:\n\nbridges = list(nx.bridges(G))\nlen(bridges)\n\n75\n\n\nThe existence of so many bridges is due to the fact that this network only contains the spotlight nodes and the friends of them. As a result, some friends of spotlight nodes are only connected to a spotlight node, making that edge a bridge.\nAlso, the edges that are local bridges are saved in a list and their number is printed. In detaill, an edge joining two nodes \\(C\\) and \\(D\\) in a graph is a local bridge, if its endpoints \\(C\\) and \\(D\\) have no friends in common. Very importantly, an edge that is a bridge is also a local bridge. Thus, this list contains all the above bridges as well:\n\nlocal_bridges = list(nx.local_bridges(G, with_span=False))\nlen(local_bridges)\n\n78\n\n\nShowcasing the bridges and local bridges in the network now. The bridges can be seen with the red color and the local bridges with the green color. Black edges are neither local bridges nor bridges.\nIt is clear that all the bridges concern nodes that are only connected to a spotlight node (have a degree of \\(1\\))\n\nplt.figure(figsize=(15, 8))\nnx.draw_networkx(G, pos=pos, node_size=10, with_labels=False, width=0.15)\nnx.draw_networkx_edges(\n    G, pos, edgelist=local_bridges, width=0.5, edge_color=\"lawngreen\"\n)  # green color for local bridges\nnx.draw_networkx_edges(\n    G, pos, edgelist=bridges, width=0.5, edge_color=\"r\"\n)  # red color for bridges\nplt.axis(\"off\")\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#assortativity",
    "href": "sessions/s09_networkx_data/facebook.html#assortativity",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "Assortativity describes the preference for a network’s nodes to attach to others that are similar in some way.\nThe assortativity in terms of nodes degrees is found with two ways:\n\nnx.degree_assortativity_coefficient(G)\n\n0.06357722918564943\n\n\n\n# use the potentially faster scipy.stats.pearsonr function.\nnx.degree_pearson_correlation_coefficient(G)\n\n0.06357722918564918\n\n\nIn fact, the assortativity coefficient is the Pearson correlation coefficient of degree between pairs of linked nodes. That means that it takes values from \\(-1\\) to \\(1\\). In detail, a positive assortativity coefficient indicates a correlation between nodes of similar degree, while a negative indicates correlation between nodes of different degrees.\nIn our case the assortativity coefficient is around \\(0.064\\), which is almost 0. That means that the network is almost non-assortative, and we cannot correlate linked nodes based on their degrees. In other words, we can not draw conclusions on the number of friends of a user from his/her friends’ number of friends (friends degree). That makes sense since we only use the friends list of spotlight nodes, non spotlight nodes will tend to have much fewer friends."
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#network-communities",
    "href": "sessions/s09_networkx_data/facebook.html#network-communities",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "A community is a group of nodes, so that nodes inside the group are connected with many more edges than between groups. Two different algorithms will be used for communities detection in this network\nFirstly, a semi-synchronous label propagation method 1 is used to detect the communities.\nThis function determines by itself the number of communities that will be detected. Now the communities will be iterated through and a colors list will be created to contain the same color for nodes that belong to the same community. Also, the number of communities is printed:\n\ncolors = [\"\" for x in range(G.number_of_nodes())]  # initialize colors list\ncounter = 0\nfor com in nx.community.label_propagation_communities(G):\n    color = \"#%06X\" % randint(0, 0xFFFFFF)  # creates random RGB color\n    counter += 1\n    for node in list(\n        com\n    ):  # fill colors list with the particular color for the community nodes\n        colors[node] = color\ncounter\n\n44\n\n\nIn detail, \\(44\\) communities were detected. Now the communities are showcased in the graph. Each community is depicted with a different color and its nodes are usually located close to each other:\n\nplt.figure(figsize=(15, 9))\nplt.axis(\"off\")\nnx.draw_networkx(\n    G, pos=pos, node_size=10, with_labels=False, width=0.15, node_color=colors\n)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nNext, the asynchronous fluid communities algorithm 2 is used.\nWith this function, we can decide the number of communities to be detected. Let’s say that \\(8\\) communities is the number we want. Again, the communities will be iterated through and a colors list will be created to contain the same color for nodes that belong to the same community.\n\ncolors = [\"\" for x in range(G.number_of_nodes())]\nfor com in nx.community.asyn_fluidc(G, 8, seed=0):\n    color = \"#%06X\" % randint(0, 0xFFFFFF)  # creates random RGB color\n    for node in list(com):\n        colors[node] = color\n\nNow the \\(8\\) communities are shown in the graph. Again, each community is depicted with a different color:\n\nplt.figure(figsize=(15, 9))\nplt.axis(\"off\")\nnx.draw_networkx(\n    G, pos=pos, node_size=10, with_labels=False, width=0.15, node_color=colors\n)\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#references",
    "href": "sessions/s09_networkx_data/facebook.html#references",
    "title": "Facebook Network Analysis",
    "section": "",
    "text": "Cambridge-intelligence"
  },
  {
    "objectID": "sessions/s09_networkx_data/facebook.html#footnotes",
    "href": "sessions/s09_networkx_data/facebook.html#footnotes",
    "title": "Facebook Network Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSemi-synchronous label propagation↩︎\nAsynchronous fluid communities algorithm↩︎"
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_dynamics.html",
    "href": "sessions/s08_networks_complex/networkx_dynamics.html",
    "title": "NetworkX - Dynamics",
    "section": "",
    "text": "The contents of this notebook have been derived from “A First Course in Network Science” by Filippo Menczer. You can see their official Github repository here.\nThis tutorial will show you how to use the included Simulation class to simulate node dynamics by specifying a graph, the initial state of the nodes, and node state transitions.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n# The following commands are used to reload our imports when we change them\n# This is useful when we are developing our code and we want to test it\n%load_ext autoreload\n%autoreload 2\n\nfrom simulation import (\n    initial_state,\n    initial_state_targeted,\n    state_transition,\n    Simulation,\n)\n\n\n\n\nThis is one of the fundamental models of spreading dynamics on networks. We will implement this spreading model using our simulation framework.\n\n\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\n# Draw the graph\npos = nx.spring_layout(G)\nnx.draw(G, pos)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nWe will initially assign every node to the ‘S’ state and then randomly choose one node to infect by setting it to the ‘I’ state. You should experiment with different choices of the “patient zero” node to infect and see how it affects the spreading dynamics, e.g. by selecting a high- or low-degree node.\nWe will develop the function initial_state() inside the simulation script. This practice is useful to keep the code organized and modular.\nSee if the function works:\n\ninitial_state(G)\n\n{0: 'S',\n 1: 'I',\n 2: 'S',\n 3: 'S',\n 4: 'S',\n 5: 'S',\n 6: 'S',\n 7: 'S',\n 8: 'S',\n 9: 'S',\n 10: 'S',\n 11: 'S',\n 12: 'S',\n 13: 'S',\n 14: 'S',\n 15: 'S',\n 16: 'S',\n 17: 'S',\n 18: 'S',\n 19: 'S'}\n\n\n\n\n\nThe SIS model involves two parameters, \\(\\beta\\) is the probability to transition from S to I given an infected neighbor, and \\(\\gamma\\), the probability of transitioning from I to S.\nIn pseudocode, the algorithm looks like this:\n\nFor each node in the graph\n\nIf node has state I\n\nThe node transitions to state S with probability \\(\\gamma\\)\n\nElse node has state S\n\nFor each neighbor of the node\n\nIf neighbor has state I\n\nThe node transitions to state I with probability \\(\\beta\\)\n\n\n\n\n\nThe logic gets a little deep with the indentations, but the code looks very much like this pseudocode.\nAgain, we develop this function state_transition() inside the simulation script.\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{2: 'I', 3: 'I'}\n\n\nIt’s possible, depending on your parameter values, that the first transition results in no state changes. This is okay, even expected. It might take a few tries before any states are updated and a nonempty dict is produced. It’s also okay to skip this, as we’re just checking our code accuracy, but it is easier to debug here than in the simulation proper.\n\n\n\nNow let’s create the simulation and visualize the initial state:\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\n# Reinitialize the simulation\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\n# Run the simulation\nsim.run(200)\n\n# Draw the graph\nsim.draw()\nplt.show()\nplt.close()\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat happens when we reduce the chance of recovery \\(\\gamma\\)?\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=400, m=1000)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nWhat if we increase the recovery rate \\(\\gamma\\)?\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=400, m=1000)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.2, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoosing the patient zero at random:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nChoosing as patient zero the node with the highest degree:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nChoosing as patient zero the node with the lowest degree:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n\ndef initial_state_min(G: nx.Graph) -&gt; dict:\n    return initial_state_targeted(G, target=\"min\")\n\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nFree scale network, choosing the patient zero at random:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nFree scale network, choosing as patient zero the node with the highest degree:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nFree scale network, choosing as patient zero the node with the lowest degree:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIn the Enron email network, choosing a random node as patient zero:\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nWhat if we explicitly infect the highest-degree node?\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAnd if we infect the lowest-degree node?\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n\ndef initial_state_min(G: nx.Graph) -&gt; dict:\n    return initial_state_targeted(G, target=\"min\")\n\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()"
  },
  {
    "objectID": "sessions/s08_networks_complex/networkx_dynamics.html#the-sis-model",
    "href": "sessions/s08_networks_complex/networkx_dynamics.html#the-sis-model",
    "title": "NetworkX - Dynamics",
    "section": "",
    "text": "This is one of the fundamental models of spreading dynamics on networks. We will implement this spreading model using our simulation framework.\n\n\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\n# Draw the graph\npos = nx.spring_layout(G)\nnx.draw(G, pos)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nWe will initially assign every node to the ‘S’ state and then randomly choose one node to infect by setting it to the ‘I’ state. You should experiment with different choices of the “patient zero” node to infect and see how it affects the spreading dynamics, e.g. by selecting a high- or low-degree node.\nWe will develop the function initial_state() inside the simulation script. This practice is useful to keep the code organized and modular.\nSee if the function works:\n\ninitial_state(G)\n\n{0: 'S',\n 1: 'I',\n 2: 'S',\n 3: 'S',\n 4: 'S',\n 5: 'S',\n 6: 'S',\n 7: 'S',\n 8: 'S',\n 9: 'S',\n 10: 'S',\n 11: 'S',\n 12: 'S',\n 13: 'S',\n 14: 'S',\n 15: 'S',\n 16: 'S',\n 17: 'S',\n 18: 'S',\n 19: 'S'}\n\n\n\n\n\nThe SIS model involves two parameters, \\(\\beta\\) is the probability to transition from S to I given an infected neighbor, and \\(\\gamma\\), the probability of transitioning from I to S.\nIn pseudocode, the algorithm looks like this:\n\nFor each node in the graph\n\nIf node has state I\n\nThe node transitions to state S with probability \\(\\gamma\\)\n\nElse node has state S\n\nFor each neighbor of the node\n\nIf neighbor has state I\n\nThe node transitions to state I with probability \\(\\beta\\)\n\n\n\n\n\nThe logic gets a little deep with the indentations, but the code looks very much like this pseudocode.\nAgain, we develop this function state_transition() inside the simulation script.\nLet’s test this out before moving forward:\n\ntest_state = initial_state(G)\nstate_transition(G, test_state)\n\n{2: 'I', 3: 'I'}\n\n\nIt’s possible, depending on your parameter values, that the first transition results in no state changes. This is okay, even expected. It might take a few tries before any states are updated and a nonempty dict is produced. It’s also okay to skip this, as we’re just checking our code accuracy, but it is easier to debug here than in the simulation proper.\n\n\n\nNow let’s create the simulation and visualize the initial state:\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\nsim.draw()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nLet’s run this simulation several steps and see where we end up:\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=20, m=50)\n\n# Reinitialize the simulation\nsim = Simulation(G, initial_state, state_transition, name=\"SIS model\")\n\n# Run the simulation\nsim.run(200)\n\n# Draw the graph\nsim.draw()\nplt.show()\nplt.close()\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat happens when we reduce the chance of recovery \\(\\gamma\\)?\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=400, m=1000)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nWhat if we increase the recovery rate \\(\\gamma\\)?\n\n# Random graph with n nodes and m edges\nG = nx.gnm_random_graph(n=400, m=1000)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.2, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoosing the patient zero at random:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nChoosing as patient zero the node with the highest degree:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nChoosing as patient zero the node with the lowest degree:\n\n# Watts-Strogatz graph with n nodes, each connected to its k nearest neighbors\nG = nx.watts_strogatz_graph(n=400, k=4, p=0.1)\n\n\ndef initial_state_min(G: nx.Graph) -&gt; dict:\n    return initial_state_targeted(G, target=\"min\")\n\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nFree scale network, choosing the patient zero at random:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nFree scale network, choosing as patient zero the node with the highest degree:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nFree scale network, choosing as patient zero the node with the lowest degree:\n\n# Barabasi-Albert graph with n nodes and m edges to attach from a new node to existing nodes\nG = nx.barabasi_albert_graph(n=400, m=2)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.05, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\nIn the Enron email network, choosing a random node as patient zero:\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nWhat if we explicitly infect the highest-degree node?\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_targeted, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nAnd if we infect the lowest-degree node?\n\n# Load the graph\nG = nx.read_edgelist(\"../../data/ia-enron-only/ia-enron-only.edges\", nodetype=int)\n\n\ndef initial_state_min(G: nx.Graph) -&gt; dict:\n    return initial_state_targeted(G, target=\"min\")\n\n\n# Reinitialize the simulation\nsim = Simulation(\n    G, initial_state_min, state_transition, gamma=0.0, beta=0.2, name=\"SIS model\"\n)\n\n# Run the simulation\nsim.run(100)\n\n# Draw the evolution of the number of infected nodes\nsim.plot()\nplt.grid()\nplt.show()\nplt.close()"
  },
  {
    "objectID": "modules/numerical-integration/index.html",
    "href": "modules/numerical-integration/index.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "1 Introduction\nNumerical integration is fundamental for solving ordinary differential equations (ODEs) that don’t have analytical solutions. In this module, you’ll learn how to:\n\nFormulate ODEs in Python\nUse SciPy’s solve_ivp to numerically integrate ODEs\nVisualize solutions and explore parameter spaces\nApply these techniques to real-world models\n\n\n\n2 The Initial Value Problem\nAn initial value problem (IVP) consists of:\n\\[\\frac{dy}{dt} = f(t, y), \\quad y(t_0) = y_0\\]\nWhere: - \\(f(t, y)\\) is the rate of change function - \\(y_0\\) is the initial condition at time \\(t_0\\)\n\n\n3 SciPy’s solve_ivp\nThe scipy.integrate.solve_ivp function is the standard tool for solving ODEs in Python. Try the following code:\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef exponential_decay(t, y):\n     return -0.5 * y\n\nt_span = [0, 10]\ny0 = [2, 4, 8]\nsol = solve_ivp(\n    fun=exponential_decay,\n    t_span=t_span, \n    y0=y0)\n\nprint(sol.t)\n\nprint(sol.y)\nHow does solve_ivp work? Let’s understand its parameters (copied from the documentation):\n\nfun: Right-hand side of the system: the time derivative of the state \\(y\\) at time \\(t\\). The calling signature is fun(t, y), where t is a scalar and y is an ndarray with len(y) = len(y0). Additional arguments need to be passed if args is used (see documentation of args argument). fun must return an array of the same shape as y. In our example, exponential_decay defines the ODE \\(\\frac{dy}{dt} = -0.5y\\), which models exponential decay \\(y(t) = y_0 e^{-0.5t}\\).\nt_span: Interval of integration \\((t_0, t_f)\\). The solver starts with \\(t=t_0\\) and integrates until it reaches \\(t=t_f\\). Both \\(t_0\\) and \\(t_f\\) must be floats or values interpretable by the float conversion function.\ny0: Initial state. For problems in the complex domain, pass y0 with a complex data type (even if the initial value is purely real).\n\nYou can also specify additional parameters: - method: Integration method to use. Common choices include 'RK45' (default), 'RK23', 'DOP853', 'Radau', 'BDF', and 'LSODA'. - t_eval: Times at which to store the computed solution, must be sorted and lie within t_span. If None (default), use points selected by the solver. - args: Additional arguments to pass to the user-defined functions. If, for example, fun has the signature fun(t, y, a, b, c), then args=(a, b, c).\n\n\n4 Systems of ODEs\nFor multiple coupled equations, return a list or array of derivatives:\ndef sir_model(t, y, beta, gamma):\n    S, I, R = y\n    N = S + I + R\n    \n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    \n    return [dSdt, dIdt, dRdt]\n\n\n5 Best Practices\n\nAlways check convergence: Plot solutions at different tolerances\nUse appropriate methods: 'RK45' (default) works well for most problems\nVectorize when possible: Makes code faster and cleaner\nDocument parameters: Keep track of units and meanings\nValidate against known solutions: Test your implementation\n\n\n\n6 Next Steps\nApply these techniques to the classical models in Session 1: - SIR epidemiological model - Spruce budworm population dynamics - Michaelis–Menten enzyme kinetics\n\n\n7 Resources\n\nSciPy solve_ivp documentation\nPython for ODEs tutorial"
  }
]