[
  {
    "objectID": "modules/ode-1d/spruce-budworm.html",
    "href": "modules/ode-1d/spruce-budworm.html",
    "title": "Spruce Budworm Model",
    "section": "",
    "text": "The spruce budworm is an insect that periodically devastates spruce forests. The population dynamics can be modeled by the following ODE (Strogatz 2024, chap. 3.7):\n\\[\n\\frac{dx}{dt} = rx\\left(1 - \\frac{x}{k}\\right) - \\frac{x^2}{1 + x^2}\n\\tag{1}\\]\nwhere:\nThe first term represents logistic growth, while the second term models predation by birds (which follows a saturating functional response).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-implementing-ode-function",
    "href": "modules/ode-1d/spruce-budworm.html#sec-implementing-ode-function",
    "title": "Spruce Budworm Model",
    "section": "Implementing the ODE Function",
    "text": "Implementing the ODE Function\nCreate a Python function that implements the spruce budworm differential equation. The function should follow the signature required by scipy.integrate.solve_ivp.\n\nFunction name: spruce_budworm\nParameters: t (time), x (population), r (growth rate), k (carrying capacity)\nReturn: The rate of change \\(\\frac{dx}{dt}\\).\nInclude appropriate docstring documentation.\n\nHere is a template to get you started:\ndef spruce_budworm(t: float, x: float, r: float = 0.5, k: float = 10) -&gt; float:\n    \"\"\"Docstring and type hints\"\"\"\n    # Your implementation here\n    dxdt = # fill in the equation\n    return dxdt\nWhy do we need t as an input? Although the equation does not explicitly depend on time, solve_ivp requires the function to accept time as the first argument.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-phase-portrait",
    "href": "modules/ode-1d/spruce-budworm.html#sec-phase-portrait",
    "title": "Spruce Budworm Model",
    "section": "Phase Portrait Visualization",
    "text": "Phase Portrait Visualization\nCreate a function that plots the rate of change \\(\\frac{dx}{dt}\\) as a function of the population \\(x\\). This phase portrait will help us visualize the equilibrium points and their stability.\n\nFunction name: plot_spruce_budworm_rate\nParameters: x_t (current population), r, k\nUse matplotlib for plotting\nPlot \\(\\frac{dx}{dt}\\) vs \\(x\\) for \\(x \\in [0, k]\\)\nIdentify and mark equilibrium points (where \\(\\frac{dx}{dt} = 0\\))\nColor-code equilibrium points:\n\nBlue circles for stable equilibria (where \\(\\frac{dx}{dt}\\) crosses zero from above).\nRed circles for unstable equilibria (where \\(\\frac{dx}{dt}\\) crosses zero from below).\n\nAdd a horizontal line at \\(y = 0\\) to indicate equilibria (null rate of change).\nLabel axes and add a title.\nMark the current population \\(x_t\\) with a vertical dashed line.\n\nFigure 1 shows an example of the expected output.\n\n\n\n\n\n\n\n\nFigure 1: Phase portrait (rate plot) of the spruce budworm model. Stable equilibria are marked in blue, unstable equilibria in red, and the current population \\(x_t\\) is shown as a green dashed line.\n\n\n\n\n\nHere are some hints to help you implement this function:\n\nYou can use np.linspace to create an array of \\(x\\) values.\nTo find zero crossings: you can look for sign changes combining np.diff and np.sign.\nStability: a fixed point is stable if \\(\\frac{dx}{dt}\\) decreases as you pass through it.\n\nReview the following definitions for clarity:\n\nEquilibrium point: A value \\(x^*\\) where \\(\\frac{dx}{dt} = 0\\).\nStable equilibrium: Small perturbations decay back to \\(x^*\\).\nUnstable equilibrium: Small perturbations grow away from \\(x^*\\).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-numerical-integration",
    "href": "modules/ode-1d/spruce-budworm.html#sec-numerical-integration",
    "title": "Spruce Budworm Model",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nCreate a function that evolves the system forward in time using numerical integration. This function should solve the ODE and append the results to existing time and population arrays.\n\nFunction name: evolve_spruce_budworm\nInputs: t (time array), x (population array), r, k, t_eval (duration to evolve).\nUse scipy.integrate.solve_ivp with the RK45 method.\nStart from the last values in the input arrays.\nConcatenate new results to the input arrays.\nEnsure population never goes negative (use np.clip).\nReturn updated t and x arrays.\n\nHere is a template to get you started:\ndef evolve_spruce_budworm(t: np.ndarray, x: np.ndarray, ...):\n    \"\"\"Don't forget the docstring and type hints\"\"\"\n    # Define time span from last time point\n    t_span = (t[-1], t[-1] + t_eval)\n\n    # Create evaluation points, t_eval\n    # This indicates where we want the solution evaluated\n    # and should be distributed along the time span\n    # Hint: use np.linspace\n\n    # Solve the ODE\n    solution = solve_ivp(\n        fun=spruce_budworm,\n        t_span=t_span,\n        y0=[x[-1]],\n        t_eval=t_eval,\n        args=(r, k),\n        method=\"RK45\",\n    )\n    t_new = solution.t\n    x_new = solution.y[0]\n\n    # Concatenate results - Hint: use np.concatenate\n    # Ensure non-negative population - Hint: use np.clip\n\n    return t, x\nSome important notes:\n\nThe args parameter in solve_ivp passes additional arguments to your ODE function. You can see how we use it in the example above.\nInitial condition should be [x[-1]] (last population value).\nUse method=\"RK45\" for adaptive step-size Runge-Kutta integration.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-time-series-visualization",
    "href": "modules/ode-1d/spruce-budworm.html#sec-time-series-visualization",
    "title": "Spruce Budworm Model",
    "section": "Time Series Visualization",
    "text": "Time Series Visualization\nCreate a function to plot the population dynamics over time. This visualization shows how the population evolves from the initial condition.\n\nFunction name: plot_spruce_budworm\nParameters: t (time array), x (population array).\nPlot time on the x-axis and population on the y-axis.\nUse green color for the trajectory.\nEnsure y-axis starts at 0 (populations cannot be negative).\nInclude grid, labels, and title.\nReturn the figure and axes objects.\n\nSee Figure 2 for an example output.\n\n\n\n\n\n\n\n\nFigure 2: Time series of the spruce budworm population generated with SciPy’s RK45 solver.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-streamlit-application",
    "href": "modules/ode-1d/spruce-budworm.html#sec-streamlit-application",
    "title": "Spruce Budworm Model",
    "section": "Building the Streamlit Application",
    "text": "Building the Streamlit Application\nNow that you have all the components, create an interactive Streamlit application that allows users to explore the spruce budworm model. This will enable real-time parameter adjustment and visualization.\nWhile all the previous code could be done in Google Colab, Streamlit has to be built on your local machine. Follow the instructions in the README.md file in the repository to set up your environment.\nDesign a script, name it spruce_budworm_app.py. You will find a suggested layout below. This script will use the functions you implemented in sections Section 1 through Section 4. You can either import them from a separate module (another script you created) or paste the function definitions directly into the script. For best practices, consider creating a module (e.g., spruce_budworm_model.py) and importing the functions.\nTo test your app, run the following command in your terminal:\nstreamlit run spruce_budworm_app.py\n\nSidebar Controls\nCreate sliders for:\n\nGrowth rate \\(r\\) (range: 0.0 to 1.0, default 0.5).\nCarrying capacity \\(k\\) (range: 0.1 to 10.0, default 10.0).\nInitial population: set automatically to \\(k/10\\) (the app uses \\(x_0 = k/10\\) by default).\nTime slider for evolution (range: 1 to 100, default 10).\n\n\n\nInteractive Features\n\nDisplay the differential equation with current parameter values.\nShow the phase portrait (rate of change plot), using your function from section Section 2.\nShow the time series evolution, using your function from section Section 4.\nAdd a button to “Evolve Forward” that continues the simulation, updating the plots.\nUse st.session_state to maintain simulation state between button clicks. You will need to store the time and population arrays in the session state, otherwise they will reset on each interaction.\n\n\n\nLayout Structure\nimport streamlit as st\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom your_module import (\n    spruce_budworm,\n    plot_spruce_budworm_rate,\n    evolve_spruce_budworm,\n    plot_spruce_budworm,\n)  # Or paste your functions here\n\nst.title(\"Spruce Budworm Population Dynamics\")\n\n# Sidebar parameters (as in the app)\nr = st.sidebar.slider(\"Intrinsic growth rate (r)\", 0.0, 1.0, 0.5)\nk = st.sidebar.slider(\"Carrying capacity (k)\", 0.1, 10.0, 10.0)\n\n# The app sets the initial population to k/10 by default\nx0 = k / 10\n\n# Initialize session state\nif (\"sbw_x\" not in st.session_state):\n    st.session_state[\"sbw_t\"] = np.array([0])\n    st.session_state[\"sbw_x\"] = np.array([x0])\n\n# Time slider and control buttons\nt_eval = st.sidebar.slider(\"Time\", 1, 100, 10)\nbutton = st.sidebar.button(\"Evolve\")\n\n# Retrieve session data\nt = st.session_state[\"sbw_t\"]\nx = st.session_state[\"sbw_x\"]\n\n# Evolve if requested\nif button:\n    t, x = evolve_spruce_budworm(t, x, r=r, k=k, t_eval=t_eval)\n    st.session_state[\"sbw_t\"] = t\n    st.session_state[\"sbw_x\"] = x\n\n# Plot phase portrait and time series\nfig1, ax1 = plot_spruce_budworm_rate(x[-1], r=r, k=k)\nst.pyplot(fig1)\nfig2, ax2 = plot_spruce_budworm(t, x)\nst.pyplot(fig2)\n\n\nAdvanced Features (Optional)\n\nAdd a reset button to restart the simulation.\nShow multiple trajectories with different initial conditions.\nAdd animation of the population dynamics.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-exploration-questions",
    "href": "modules/ode-1d/spruce-budworm.html#sec-exploration-questions",
    "title": "Spruce Budworm Model",
    "section": "Exploration Questions",
    "text": "Exploration Questions\nOnce your simulation is working, explore the following questions:\n\nMultiple Equilibria: For \\(r = 0.5\\) and \\(k = 10\\), how many equilibrium points exist? Which are stable?\nBistability: Start with two different initial conditions (e.g., \\(x_0 = 1\\) and \\(x_0 = 8\\)). Do they converge to the same equilibrium?\nHysteresis: Slowly increase the carrying capacity \\(k\\) from 5 to 15. Then slowly decrease it back to 5. Does the population return to the same state? If you are interested in this concept, see section Section 6.1.\nOutbreak Dynamics: What happens if you start with a small population (\\(x_0 &lt; 2\\)) and the carrying capacity is large (\\(k &gt; 10\\))?\nCritical Slowing Down: When the population is near an unstable equilibrium, how long does it take to move away? Compare this to the rate of change far from equilibrium.\nParameter Space: Create a diagram showing the number of equilibria as a function of \\(r\\) and \\(k\\). Where do bifurcations occur?\n\n\nSlow-Fast Dynamics\nThe carrying capacity \\(k\\) can be interpreted as a slowly varying parameter in real ecosystems (e.g., due to seasonal changes or forest management). You can simulate this by gradually changing \\(k\\) over time in your app. This can lead to hysteresis effects, where the population does not return to its original state after \\(k\\) is restored. Experiment with this by modifying your Streamlit app to allow \\(k\\) to vary over time.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#sec-mathematical-background",
    "href": "modules/ode-1d/spruce-budworm.html#sec-mathematical-background",
    "title": "Spruce Budworm Model",
    "section": "Mathematical Background",
    "text": "Mathematical Background\nIn this section I provide some additional mathematical context for the spruce budworm model. Play with your simulation to see these concepts in action!\n\nEquilibrium Analysis\nEquilibrium points satisfy:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) - \\frac{(x^*)^2}{1 + (x^*)^2} = 0\n\\tag{2}\\]\nThis can be rewritten as:\n\\[\nrx^*\\left(1 - \\frac{x^*}{k}\\right) = \\frac{(x^*)^2}{1 + (x^*)^2}\n\\tag{3}\\]\nThe left side represents birth rate (logistic growth), and the right side represents predation rate. Equilibria occur where these balance.\n\n\nStability Analysis\nThe stability of an equilibrium \\(x^*\\) is determined by the sign of the derivative:\n\\[\n\\frac{d}{dx}\\left(\\frac{dx}{dt}\\right)\\bigg|_{x=x^*}\n\\tag{4}\\]\nIf this derivative is:\n\nNegative: the equilibrium is stable (attracting).\nPositive: the equilibrium is unstable (repelling).\nZero: higher-order analysis is needed.\n\n\n\nEcological Interpretation\n\nLow equilibrium: Few budworms, controlled by predation.\nHigh equilibrium: Outbreak state, budworms overwhelm predators.\nMiddle equilibrium: Usually unstable, separates the two basins of attraction.\nHysteresis: The system can “jump” between states depending on history.\n\nThis behavior explains why spruce budworm populations can suddenly explode from low levels to outbreak proportions, and why simply reducing the outbreak may not return the forest to a healthy state.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/spruce-budworm.html#resources",
    "href": "modules/ode-1d/spruce-budworm.html#resources",
    "title": "Spruce Budworm Model",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 3.7) for theoretical background on the spruce budworm model.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nStreamlit documentation: https://docs.streamlit.io\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/amlab/odes_1d",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Spruce Budworm Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html",
    "href": "modules/ode-1d/sir.html",
    "title": "SIR Epidemic Model",
    "section": "",
    "text": "The SIR model is a classical compartmental model in epidemiology. It splits the population into:\nand describes how individuals move between these compartments over time.\nWe will use the normalized SIR model (fractions of the population, so \\(S+I+R=1\\)):\n\\[\n\\begin{aligned}\n\\dot S &= -\\beta SI,\\\\\n\\dot I &= \\beta SI - \\gamma I,\\\\\n\\dot R &= \\gamma I.\n\\end{aligned}\n\\tag{1}\\]",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-reference",
    "href": "modules/ode-1d/sir.html#sec-reference",
    "title": "SIR Epidemic Model",
    "section": "Reference Implementation",
    "text": "Reference Implementation\nA working implementation is provided in:\n\namlab/odes_1d/sir_model.py\n\nThe model function is sir_model(t, y, beta, gamma) and the plotting helper is plot_sir_model(...).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-render-figure",
    "href": "modules/ode-1d/sir.html#sec-render-figure",
    "title": "SIR Epidemic Model",
    "section": "Render-time Figure",
    "text": "Render-time Figure\nThe figure below is generated at render-time from the reference script.\n\n\n\n\n\n\n\n\nFigure 1: SIR dynamics for default parameters.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-exploration",
    "href": "modules/ode-1d/sir.html#sec-exploration",
    "title": "SIR Epidemic Model",
    "section": "Exploration",
    "text": "Exploration\n\nIncrease \\(\\beta\\) while keeping \\(\\gamma\\) fixed. What happens to the peak of \\(I(t)\\)?\nIncrease \\(\\gamma\\) while keeping \\(\\beta\\) fixed. Does the epidemic end sooner?\nTry different initial infected fractions \\(I(0)\\). Do you always see an outbreak?",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/sir.html#sec-run-locally",
    "href": "modules/ode-1d/sir.html#sec-run-locally",
    "title": "SIR Epidemic Model",
    "section": "Run Locally",
    "text": "Run Locally\nTo run the standalone script and show the plot:\npython amlab/odes_1d/sir_model.py",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "SIR Epidemic Model"
    ]
  },
  {
    "objectID": "modules/ode-1d/assignment.html",
    "href": "modules/ode-1d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Implement the complete Streamlit application for the Spruce Budworm model as described here, following the sections from Implementing the ODE Function through Building the Streamlit Application. Ensure that all functions are correctly defined and integrated into the app. Test the application thoroughly to confirm that it behaves as expected.\nAnswer at least three of the exploration questions from Exploration Questions and document your findings in a brief report (1-2 pages). You are encouraged to use LaTeX here. Include graphs demonstrating different behaviors observed during your exploration.\nIf you want to go the extra mile, here are some additional challenges you can tackle:",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-1d/assignment.html#tips-for-success",
    "href": "modules/ode-1d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Get Implementing the ODE Function working first, then build up.\nTest incrementally: Verify each function works before moving to the next.\nUse the reference: The provided code (and additional documentation) is there to help you understand the structure.\nExperiment: Try different parameter values and see what happens.\nCollaborate: Discuss with your teammates, divide the work if needed. You can also work separately and then compare your implementations.\nAsk questions: If you’re stuck, ask for help!\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/networks/enron.html",
    "href": "modules/networks/enron.html",
    "title": "Enron Email Network",
    "section": "",
    "text": "The Enron email dataset can be represented as a graph where nodes are email addresses and edges represent communication. It is widely used to study centrality, communities, and robustness.\nFigure 1: Enron network: degree histogram (log scale).",
    "crumbs": [
      "Session 6: Networks",
      "Enron Email"
    ]
  },
  {
    "objectID": "modules/networks/enron.html#load-the-graph",
    "href": "modules/networks/enron.html#load-the-graph",
    "title": "Enron Email Network",
    "section": "Load the graph",
    "text": "Load the graph\nimport networkx as nx\n\nG = nx.read_edgelist(\"data/ia-enron-only/ia-enron-only.edges\")",
    "crumbs": [
      "Session 6: Networks",
      "Enron Email"
    ]
  },
  {
    "objectID": "modules/networks/enron.html#centrality-metrics",
    "href": "modules/networks/enron.html#centrality-metrics",
    "title": "Enron Email Network",
    "section": "Centrality metrics",
    "text": "Centrality metrics\nCompute the top nodes by betweenness centrality.\nimport networkx as nx\n\nbc = nx.betweenness_centrality(G)\n# TODO: sort and print top 10 nodes\n\n\n\n\n\n\nHint: Top 10 by betweenness (click to expand)\n\n\n\n\n\nbc = nx.betweenness_centrality(G)\ntop10 = sorted(bc.items(), key=lambda x: x[1], reverse=True)[:10]\nprint(top10)",
    "crumbs": [
      "Session 6: Networks",
      "Enron Email"
    ]
  },
  {
    "objectID": "modules/networks/enron.html#questions-to-explore",
    "href": "modules/networks/enron.html#questions-to-explore",
    "title": "Enron Email Network",
    "section": "Questions to explore",
    "text": "Questions to explore\n\nWhich nodes act as brokers in the network?\nHow does the graph change if you remove high-betweenness nodes?\nCan you detect communities with a simple algorithm?",
    "crumbs": [
      "Session 6: Networks",
      "Enron Email"
    ]
  },
  {
    "objectID": "modules/networks/assignment.html",
    "href": "modules/networks/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Pick one dataset (USA Flights or Enron) and complete the tasks below.",
    "crumbs": [
      "Session 6: Networks",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/networks/assignment.html#required",
    "href": "modules/networks/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nLoad the graph with NetworkX and report nodes/edges.\nCompute and list the top 10 nodes by degree centrality.\nCompute one additional metric (betweenness, clustering, or PageRank).\nVisualize the graph (full or sampled) and include a short interpretation.",
    "crumbs": [
      "Session 6: Networks",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/networks/assignment.html#extra-mile-optional",
    "href": "modules/networks/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nRemove a high-centrality node and analyze changes in connectivity.\nCompare two different centrality metrics and discuss differences.\nTry a community detection method and summarize results.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 6: Networks",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html",
    "href": "modules/network-dynamics/sis.html",
    "title": "SIS Model",
    "section": "",
    "text": "In the SIS model, infected nodes recover back to susceptible. At each step:\nFigure 1: SIS model: example network with one infected node.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html#step-1-initialize-the-graph",
    "href": "modules/network-dynamics/sis.html#step-1-initialize-the-graph",
    "title": "SIS Model",
    "section": "Step 1: Initialize the graph",
    "text": "Step 1: Initialize the graph\nChoose a network structure and draw it.\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nG = nx.gnm_random_graph(n=20, m=50)\npos = nx.spring_layout(G)\n\nnx.draw(G, pos)\nplt.show()",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html#step-2-add-a-node-state",
    "href": "modules/network-dynamics/sis.html#step-2-add-a-node-state",
    "title": "SIS Model",
    "section": "Step 2: Add a node state",
    "text": "Step 2: Add a node state\nEach node has a state: “S” or “I”. Start with one infected node.\nnode_names = list(G.nodes)\nstate = {}\n# TODO: set one node to \"I\" and the rest to \"S\"\n\nnx.set_node_attributes(G, state, \"state\")\n\n\n\n\n\n\nHint: Initial state (click to expand)\n\n\n\n\n\nstate = {node: \"S\" for node in G.nodes}\npatient_zero = node_names[0]\nstate[patient_zero] = \"I\"",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html#step-3-state-transition",
    "href": "modules/network-dynamics/sis.html#step-3-state-transition",
    "title": "SIS Model",
    "section": "Step 3: State transition",
    "text": "Step 3: State transition\nImplement the SIS transition rules.\nstate = nx.get_node_attributes(G, \"state\")\nnext_state = {}\n\n# TODO: implement SIS transitions using beta and gamma\n\nnx.set_node_attributes(G, next_state, \"state\")\n\n\n\n\n\n\nHint: SIS transition (click to expand)\n\n\n\n\n\nimport random\n\nnext_state = {}\nfor node in G.nodes:\n    if state[node] == \"I\":\n        if random.random() &lt; gamma:\n            next_state[node] = \"S\"\n    else:\n        for neighbor in G.neighbors(node):\n            if state[neighbor] == \"I\" and random.random() &lt; beta:\n                next_state[node] = \"I\"\n                break",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html#step-4-simulate-and-plot",
    "href": "modules/network-dynamics/sis.html#step-4-simulate-and-plot",
    "title": "SIS Model",
    "section": "Step 4: Simulate and plot",
    "text": "Step 4: Simulate and plot\nRun for multiple steps and track the number of S and I nodes.\nnum_steps = 100\nls_s, ls_i = [], []\n\nfor _ in range(num_steps):\n    # TODO: apply the transition and update attributes\n    counts = list(nx.get_node_attributes(G, \"state\").values())\n    ls_s.append(counts.count(\"S\"))\n    ls_i.append(counts.count(\"I\"))\n\n# TODO: plot ls_s and ls_i",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/sis.html#extra-challenge",
    "href": "modules/network-dynamics/sis.html#extra-challenge",
    "title": "SIS Model",
    "section": "Extra challenge",
    "text": "Extra challenge\nExtend the model to SIR or SIRS by adding a recovered state.\nIf you want a full reference, see amlab/networks_complex/simulation.py.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "SIS Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/assignment.html",
    "href": "modules/network-dynamics/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Implement the SIS model and explore its behavior.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/network-dynamics/assignment.html#required",
    "href": "modules/network-dynamics/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nSimulate SIS on a graph with 20 nodes.\nUse at least two different network types (random, Watts-Strogatz, or Barabasi-Albert).\nPlot the time evolution of S and I.\nTry two sets of \\((\\beta, \\gamma)\\) and compare outcomes.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/network-dynamics/assignment.html#extra-mile-optional",
    "href": "modules/network-dynamics/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nExtend to SIR or SIRS.\nAdd a stop condition when infections die out.\nVisualize the network at different time steps.\n\nGood luck and enjoy your coding!\n\nSimulate the Daley-Kendall model on a real graph.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/network-dynamics/assignment.html#required-1",
    "href": "modules/network-dynamics/assignment.html#required-1",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nLoad the Facebook network and run the simulation.\nUse \\(\\beta=0.2\\) and \\(\\gamma=0.1\\) as a starting point.\nPlot the time evolution of I, S, R.\nReport how long it takes for the rumor to die out.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/network-dynamics/assignment.html#extra-mile-optional-1",
    "href": "modules/network-dynamics/assignment.html#extra-mile-optional-1",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nAdd key press controls and sliders.\nCompare outcomes for two different initial spreaders.\nRemove a high-centrality node and analyze the effect.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/traffic.html",
    "href": "modules/agent-based-modeling/traffic.html",
    "title": "Traffic Models with CA",
    "section": "",
    "text": "Traffic flow can be modeled with a 1D cellular automaton. Cars occupy cells and move forward each step according to simple rules.\nFigure 1: Traffic CA space-time diagram (cars as black pixels).",
    "crumbs": [
      "Session 9: Agent Based Modeling",
      "Traffic Models"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/traffic.html#model-rules",
    "href": "modules/agent-based-modeling/traffic.html#model-rules",
    "title": "Traffic Models with CA",
    "section": "Model rules",
    "text": "Model rules\nAt each step:\n\nAccelerate up to \\(v_{\\max}\\).\nBrake to avoid collisions.\nRandom slowdown with probability \\(p\\).\nMove forward.",
    "crumbs": [
      "Session 9: Agent Based Modeling",
      "Traffic Models"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/traffic.html#initialize-the-road",
    "href": "modules/agent-based-modeling/traffic.html#initialize-the-road",
    "title": "Traffic Models with CA",
    "section": "Initialize the road",
    "text": "Initialize the road\noccupied, speeds = initialize_road(length=100, density=0.2, vmax=5)",
    "crumbs": [
      "Session 9: Agent Based Modeling",
      "Traffic Models"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/traffic.html#update-one-step-template",
    "href": "modules/agent-based-modeling/traffic.html#update-one-step-template",
    "title": "Traffic Models with CA",
    "section": "Update one step (template)",
    "text": "Update one step (template)\ndef step(occupied, speeds, vmax=5, p_slow=0.3):\n    # TODO: accelerate\n    # TODO: brake to avoid collisions\n    # TODO: random slowdown\n    # TODO: move cars\n    return new_occupied, new_speeds\n\n\n\n\n\n\nHint: Update step (click to expand)\n\n\n\n\n\ndef step(occupied, speeds, vmax=5, p_slow=0.3):\n    length = len(occupied)\n    positions = np.where(occupied)[0]\n    speeds_new = speeds.copy()\n\n    speeds_new[positions] = np.minimum(speeds_new[positions] + 1, vmax)\n\n    gaps = np.zeros_like(positions)\n    for idx, pos in enumerate(positions):\n        next_pos = positions[(idx + 1) % len(positions)]\n        gaps[idx] = (next_pos - pos - 1) % length\n    speeds_new[positions] = np.minimum(speeds_new[positions], gaps)\n\n    rng = np.random.default_rng()\n    slow_mask = rng.random(len(positions)) &lt; p_slow\n    speeds_new[positions[slow_mask]] = np.maximum(\n        speeds_new[positions[slow_mask]] - 1, 0\n    )\n\n    new_occupied = np.zeros_like(occupied)\n    new_speeds = np.zeros_like(speeds)\n    new_positions = (positions + speeds_new[positions]) % length\n    new_occupied[new_positions] = True\n    new_speeds[new_positions] = speeds_new[positions]\n\n    return new_occupied, new_speeds",
    "crumbs": [
      "Session 9: Agent Based Modeling",
      "Traffic Models"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/traffic.html#space-time-diagram",
    "href": "modules/agent-based-modeling/traffic.html#space-time-diagram",
    "title": "Traffic Models with CA",
    "section": "Space-time diagram",
    "text": "Space-time diagram\nRun the model for many steps and plot the grid.\ngrid = simulate(steps=200, length=100, density=0.2, vmax=5, p_slow=0.3)\nplt.imshow(grid, cmap=\"binary\", interpolation=\"nearest\", aspect=\"auto\")\nplt.show()\nFull reference: amlab/cellular_automata/traffic.py.",
    "crumbs": [
      "Session 9: Agent Based Modeling",
      "Traffic Models"
    ]
  },
  {
    "objectID": "modules/lorenz/lorenz.html",
    "href": "modules/lorenz/lorenz.html",
    "title": "Lorenz Attractor",
    "section": "",
    "text": "The Lorenz system is a classic example of deterministic chaos:\n\\[\n\\begin{aligned}\n\\dot x &= s (y - x), \\\\\n\\dot y &= r x - y - x z, \\\\\n\\dot z &= x y - b z.\n\\end{aligned}\n\\tag{1}\\]\nFigure 1: Lorenz attractor trajectory (Euler integration).",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/lorenz/lorenz.html#implement-the-vector-field",
    "href": "modules/lorenz/lorenz.html#implement-the-vector-field",
    "title": "Lorenz Attractor",
    "section": "Implement the vector field",
    "text": "Implement the vector field\ndef lorenz(xyz, s=10, r=28, b=2.667):\n    x, y, z = xyz\n    x_dot = s * (y - x)\n    y_dot = r * x - y - x * z\n    z_dot = x * y - b * z\n    return np.array([x_dot, y_dot, z_dot])",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/lorenz/lorenz.html#simulate-with-euler",
    "href": "modules/lorenz/lorenz.html#simulate-with-euler",
    "title": "Lorenz Attractor",
    "section": "Simulate with Euler",
    "text": "Simulate with Euler\nnum_steps = 10000\ndt = 0.01\nxyzs = np.empty((num_steps + 1, 3))\nxyzs[0] = (0.0, 1.0, 1.05)\n\nfor i in range(num_steps):\n    xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt\nTry changing \\(r\\) or the initial condition and observe how the trajectory changes.\nReference code: amlab/extra/lorenz_attractor.py.",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/lorenz/assignment.html",
    "href": "modules/lorenz/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Simulate the Lorenz system and explore its sensitivity to initial conditions.",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/lorenz/assignment.html#required",
    "href": "modules/lorenz/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement the Lorenz ODE and simulate with Euler’s method.\nPlot the 3D trajectory.\nRun two simulations with slightly different initial conditions and compare.",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/lorenz/assignment.html#extra-mile-optional",
    "href": "modules/lorenz/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nTry different parameter values \\((s, r, b)\\) and describe changes.\nUse a smaller \\(dt\\) and compare trajectories.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Extra: Lorenz Attractor",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html",
    "href": "modules/pde-1d/turing-instability.html",
    "title": "Turing Instability",
    "section": "",
    "text": "Turing instability explains when a uniform steady state becomes unstable to spatial perturbations, leading to patterns. We will implement the checks and visualize the instability region.\nFigure 1: Turing space for the Gierer-Meinhardt model (a vs d).",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#conditions",
    "href": "modules/pde-1d/turing-instability.html#conditions",
    "title": "Turing Instability",
    "section": "Conditions",
    "text": "Conditions\nLet the Jacobian at the fixed point be\n\\[J=\\begin{pmatrix} f_u & f_v \\\\ g_u & g_v \\end{pmatrix}. \\tag{1}\\]\nA common set of conditions for Turing instability is:\n\\[\n\\begin{aligned}\n&f_u + g_v &lt; 0, \\\\\n&f_u g_v - f_v g_u &gt; 0, \\\\\n&g_v + d f_u &gt; 2\\sqrt{d\\,(f_u g_v - f_v g_u)}.\n\\end{aligned}\n\\tag{2}\\]",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#implement-a-turing-test",
    "href": "modules/pde-1d/turing-instability.html#implement-a-turing-test",
    "title": "Turing Instability",
    "section": "Implement a Turing test",
    "text": "Implement a Turing test\nCreate a function that returns True if all conditions are satisfied. In the reference script the Jacobian entries are hard-coded at the fixed point.\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    # TODO: compute fu, fv, gu, gv at the fixed point\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    # TODO: implement the three conditions\n    return cond1 & cond2 & cond3\n\n\n\n\n\n\nHint: Turing instability functions (click to expand)\n\n\n\n\n\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    fu = 2 * b / (a + 1) - b\n    fv = -((b / (a + 1)) ** 2)\n    gu = 2 * (a + 1) / b\n    gv = -1.0\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    nabla = fu * gv - fv * gu\n    cond1 = (fu + gv) &lt; 0\n    cond2 = nabla &gt; 0\n    cond3 = (gv + d * fu) &gt; (2 * np.sqrt(d) * np.sqrt(nabla))\n    return cond1 & cond2 & cond3",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#plot-the-turing-space",
    "href": "modules/pde-1d/turing-instability.html#plot-the-turing-space",
    "title": "Turing Instability",
    "section": "Plot the Turing space",
    "text": "Plot the Turing space\nPlot the region of \\((a, d)\\) where the instability holds.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\narr_a = np.linspace(0, 1, 1000)\narr_d = np.linspace(0, 100, 1000)\nmesh_a, mesh_d = np.meshgrid(arr_a, arr_d)\nmask_turing = is_turing_instability(mesh_a, b, mesh_d)\n\nfig, ax = plt.subplots(figsize=(6, 4))\nax.contourf(mesh_a, mesh_d, mask_turing)\nax.set_xlabel(\"a\")\nax.set_ylabel(\"d\")\nax.set_title(\"Turing Space\")\nEnsure your function works with arrays.",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#unstable-spatial-modes",
    "href": "modules/pde-1d/turing-instability.html#unstable-spatial-modes",
    "title": "Turing Instability",
    "section": "Unstable spatial modes",
    "text": "Unstable spatial modes\nThe temporal eigenvalues for spatial mode \\(\\lambda_n\\) are the eigenvalues of\n\\[A_n = J - \\lambda_n \\;\\mathrm{diag}(1, d). \\tag{3}\\]\nYou can scan modes to find which ones are unstable:\nimport numpy as np\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length=40.0, num_modes=10):\n    # TODO: build Jacobian and scan spatial modes\n    return unstable_modes\n\n\n\n\n\n\nHint: Spatial mode scan (click to expand)\n\n\n\n\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length=40.0, num_modes=10):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    jac = np.array([[fu, fv], [gu, gv]])\n    n_values = np.arange(num_modes)\n    max_eigs = np.zeros(num_modes)\n\n    for n in n_values:\n        lambda_n = (n * np.pi / length) ** 2\n        a_n = jac - lambda_n * np.diag([1, d])\n        sigma1, sigma2 = np.linalg.eigvals(a_n)\n        max_eigs[n] = max(sigma1.real, sigma2.real)\n\n    sorted_indices = np.argsort(max_eigs)[::-1]\n    unstable_modes = sorted_indices[max_eigs[sorted_indices] &gt; 0]\n    return unstable_modes",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/turing-instability.html#interaction-extension-optional",
    "href": "modules/pde-1d/turing-instability.html#interaction-extension-optional",
    "title": "Turing Instability",
    "section": "Interaction extension (optional)",
    "text": "Interaction extension (optional)\nMake the plot interactive: clicking on the Turing diagram updates \\((a, d)\\) and restarts the animation of \\(v(x)\\).\nfrom matplotlib.backend_bases import MouseEvent\n\ndef mouse_click(event: MouseEvent):\n    if event.inaxes == ax_turing:\n        a = event.xdata\n        d = event.ydata\n        # TODO: reset u,v and restart the animation\n\nfig.canvas.mpl_connect(\"button_press_event\", mouse_click)\n\n\n\n\n\n\nTip\n\n\n\nYou can find a complete interactive implementation in amlab/pdes_1d.",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html",
    "href": "modules/pde-1d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Implement a full 1D reaction-diffusion workflow for the Gierer-Meinhardt model. Your submission should include code and figures that demonstrate pattern formation.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#required",
    "href": "modules/pde-1d/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement the PDE solver using an explicit Euler time step.\nEnforce Neumann boundary conditions at each step.\nUse \\(L=40\\), \\(dx=0.5\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).\nCreate an animation of \\(v(x)\\) that updates in time.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#turing-instability",
    "href": "modules/pde-1d/assignment.html#turing-instability",
    "title": "Assignment",
    "section": "Turing Instability",
    "text": "Turing Instability\n\nImplement is_turing_instability(a, b, d) and plot the Turing space diagram.\nMark the point \\((a, d)\\) you are using on the diagram.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#extra-mile-optional",
    "href": "modules/pde-1d/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nCompute unstable spatial modes and display the leading mode on the animation.\nMake the diagram interactive: clicking on \\((a, d)\\) updates the simulation.\nTry other boundary conditions and compare.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-1d/assignment.html#tips-for-success",
    "href": "modules/pde-1d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Verify your Laplacian and boundary conditions first.\nTest incrementally: Plot intermediate results to detect instability early.\nBe careful with dt: If the simulation explodes, reduce \\(dt\\) or increase \\(dx\\).\nDocument choices: Report the parameters you used and the patterns you observed.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-2d/gierer-meinhardt.html",
    "href": "modules/pde-2d/gierer-meinhardt.html",
    "title": "Gierer-Meinhardt Model (2D)",
    "section": "",
    "text": "The 2D Gierer-Meinhardt model is a pattern-forming reaction-diffusion system. We will extend the 1D solver to a rectangular domain \\(\\Omega = (0, L_1) \\times (0, L_2)\\) and visualize \\(v(x,y)\\).\nIn 2D the model is\n\\[\n\\begin{aligned}\n\\frac{\\partial u}{\\partial t} &= \\Delta u + \\gamma \\left(a - b u + \\frac{u^2}{v}\\right), \\\\\n\\frac{\\partial v}{\\partial t} &= d\\,\\Delta v + \\gamma \\left(u^2 - v\\right),\n\\end{aligned}\n\\tag{1}\\]\nwhere \\(u(x,y,t)\\) and \\(v(x,y,t)\\) are concentrations.\nFigure 1: Gierer-Meinhardt 2D: example snapshot of \\(v(x,y)\\) with \\(L_1=20\\), \\(L_2=50\\), \\(dx=1\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 2D"
    ]
  },
  {
    "objectID": "modules/pde-2d/gierer-meinhardt.html#laplacian-in-2d",
    "href": "modules/pde-2d/gierer-meinhardt.html#laplacian-in-2d",
    "title": "Gierer-Meinhardt Model (2D)",
    "section": "Laplacian in 2D",
    "text": "Laplacian in 2D\nIn two dimensions the Laplacian is\n\\[\n\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}.\n\\tag{2}\\]\nUsing a 5-point stencil with spacing \\(h\\):\n\\[\n\\Delta u(x,y) \\approx \\frac{u(x+h,y) + u(x-h,y) + u(x,y+h) + u(x,y-h) - 4u(x,y)}{h^2}.\n\\tag{3}\\]\nA 9-point stencil improves accuracy by including diagonal neighbors:\n\\[\n\\Delta u(x,y) \\approx \\frac{-20u(x,y) + 4\\sum_{\\text{cardinal}} u + \\sum_{\\text{diagonal}} u}{6h^2}.\n\\tag{4}\\]",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 2D"
    ]
  },
  {
    "objectID": "modules/pde-2d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "href": "modules/pde-2d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "title": "Gierer-Meinhardt Model (2D)",
    "section": "Exercise: Simulate the PDE",
    "text": "Exercise: Simulate the PDE\nWe will use \\(L_1=20\\), \\(L_2=50\\), \\(dx=1\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), and \\(\\gamma=1\\). Follow the steps below and compare your output to Figure 1.\n\nInitialize the fields\nimport numpy as np\n\nlength_x = 20\nlength_y = 50\ndx = 1\nlenx = int(length_x / dx)\nleny = int(length_y / dx)\n\nuv = np.ones((2, lenx, leny))\nuv += uv * np.random.uniform(0, 1, uv.shape) / 100\n\n\nDefine the PDE (template)\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    # TODO: compute the 2D Laplacian with np.roll\n\n    # TODO: implement the reaction terms f(u, v) and g(u, v)\n    # TODO: combine diffusion + reaction to build du_dt and dv_dt\n    return du_dt, dv_dt\n\n\n\n\n\n\nHint: Gierer-Meinhardt 2D PDE (click to expand)\n\n\n\n\n\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    lap = -4 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap += np.roll(uv, shift=1, axis=2)\n    lap += np.roll(uv, shift=-1, axis=2)\n    lap /= dx**2\n\n    u, v = uv\n    lu, lv = lap\n\n    f = a - b * u + (u**2) / v\n    g = u**2 - v\n    du_dt = lu + gamma * f\n    dv_dt = d * lv + gamma * g\n    return du_dt, dv_dt\n\n\n\n\n\nTime stepping (template)\nnum_iter = 50000\ndt = 0.001\n\nfor _ in range(num_iter):\n    dudt, dvdt = gierer_meinhardt_pde(0, uv, dx=dx)\n    # TODO: update u and v with Euler's method\n\n    # TODO: enforce Neumann boundary conditions in both directions\n\n\nPlot the image (template)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nim = ax.imshow(\n    uv[1],\n    interpolation=\"bilinear\",\n    origin=\"lower\",\n    extent=[0, length_y, 0, length_x],\n)\nplt.show()\n\n\nAnimation\nInstead of running a long loop, move the Euler updates inside the animation callback.\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nim = ax.imshow(uv[1], origin=\"lower\", extent=[0, length_y, 0, length_x])\n\ndef update_animation(frame):\n    # TODO: update uv via Euler steps\n    # TODO: apply Neumann boundary conditions\n    im.set_array(uv[1])\n    im.set_clim(vmin=uv[1].min(), vmax=uv[1].max() + 0.1)\n    return (im,)\n\nani = animation.FuncAnimation(fig, update_animation, interval=1, blit=True)\n\n\n\n\n\n\nHint: Animation update (click to expand)\n\n\n\n\n\ndef update_animation(frame):\n    global uv\n    for _ in range(anim_speed):\n        dudt = gierer_meinhardt_pde(0, uv, gamma=gamma, a=a, b=b, d=d, dx=dx)\n        uv = uv + dudt * dt\n        uv[:, 0, :] = uv[:, 1, :]\n        uv[:, -1, :] = uv[:, -2, :]\n        uv[:, :, 0] = uv[:, :, 1]\n        uv[:, :, -1] = uv[:, :, -2]\n\n    im.set_array(uv[1])\n    im.set_clim(vmin=uv[1].min(), vmax=uv[1].max() + 0.1)\n    return (im,)",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 2D"
    ]
  },
  {
    "objectID": "modules/pde-2d/gierer-meinhardt.html#explore",
    "href": "modules/pde-2d/gierer-meinhardt.html#explore",
    "title": "Gierer-Meinhardt Model (2D)",
    "section": "Explore",
    "text": "Explore\nTry different parameter values for \\((a, d)\\) and describe the pattern. What changes when you increase \\(d\\)?",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 2D"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott-art.html",
    "href": "modules/pde-2d/gray-scott-art.html",
    "title": "Gray-Scott: Interaction",
    "section": "",
    "text": "This page adds interaction to the Gray-Scott simulation: draw sources of \\(v\\), pause/resume, and adjust parameters with sliders. The reference implementation is in amlab/pdes_2d/gray_scott.py.",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott: Interaction"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott-art.html#draw-on-the-plot",
    "href": "modules/pde-2d/gray-scott-art.html#draw-on-the-plot",
    "title": "Gray-Scott: Interaction",
    "section": "Draw on the plot",
    "text": "Draw on the plot\nLeft click adds a small perturbation near \\((u,v)=(0.5,0.5)\\), right click resets to \\((1,0)\\). Implement an update function and wire the events.\nfrom matplotlib.backend_bases import MouseEvent\n\ndef update_uv(event: MouseEvent, r: int = 3):\n    # TODO: check if event is inside the axes\n    # TODO: compute (x, y) indices\n    # TODO: left click adds noise around (0.5, 0.5)\n    # TODO: right click resets to (1, 0)\n    # TODO: update a (2r x 2r) patch in uv\n    # TODO: refresh the image\n\n\n\n\n\n\nHint: update_uv (click to expand)\n\n\n\n\n\ndef update_uv(event: MouseEvent, r: int = 3):\n    if event.inaxes != ax_uv:\n        return\n    if event.xdata is None or event.ydata is None:\n        return\n    x = int(event.xdata)\n    y = int(event.ydata)\n\n    if event.button == 1:\n        u_new = 0.5 * (1 + 0.1 * np.random.randn())\n        v_new = 0.5 * (1 + 0.1 * np.random.randn())\n    elif event.button == 3:\n        u_new = 1.0\n        v_new = 0.0\n    else:\n        return\n\n    uv[0, y - r : y + r, x - r : x + r] = u_new\n    uv[1, y - r : y + r, x - r : x + r] = v_new\n    im.set_array(uv[1])\n\n\n\nNow allow continuous drawing while the mouse button is pressed.\ndef on_click(event: MouseEvent):\n    # TODO: enable drawing and update_uv(event)\n\ndef on_release(event: MouseEvent):\n    # TODO: disable drawing\n\ndef on_motion(event: MouseEvent):\n    # TODO: if drawing, call update_uv(event)\n\nfig.canvas.mpl_connect(\"button_press_event\", on_click)\nfig.canvas.mpl_connect(\"button_release_event\", on_release)\nfig.canvas.mpl_connect(\"motion_notify_event\", on_motion)\n\n\n\n\n\n\nHint: mouse handlers (click to expand)\n\n\n\n\n\ndef on_click(event: MouseEvent):\n    if event.inaxes != ax_uv:\n        return\n    if event.xdata is None or event.ydata is None:\n        return\n    nonlocal drawing\n    drawing = True\n    update_uv(event)\n\n\ndef on_release(event: MouseEvent):\n    nonlocal drawing\n    drawing = False\n\n\ndef on_motion(event: MouseEvent):\n    if drawing:\n        update_uv(event)",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott: Interaction"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott-art.html#pause-and-resume",
    "href": "modules/pde-2d/gray-scott-art.html#pause-and-resume",
    "title": "Gray-Scott: Interaction",
    "section": "Pause and resume",
    "text": "Pause and resume\nUse the space bar to pause/resume the simulation.\nfrom matplotlib.backend_bases import KeyEvent\n\npause = False\n\ndef on_keypress(event: KeyEvent):\n    # TODO: toggle pause when space bar is pressed\n\nfig.canvas.mpl_connect(\"key_press_event\", on_keypress)\n\n\n\n\n\n\nHint: pause handler (click to expand)\n\n\n\n\n\ndef on_keypress(event: KeyEvent):\n    nonlocal pause\n    if event.key == \" \":\n        pause ^= True",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott: Interaction"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott-art.html#sliders",
    "href": "modules/pde-2d/gray-scott-art.html#sliders",
    "title": "Gray-Scott: Interaction",
    "section": "Sliders",
    "text": "Sliders\nCreate sliders to update \\(d_1, d_2, f, k\\) while the animation runs.\nfrom matplotlib.widgets import Slider\n\n# Create axes for sliders on the right\nax_d1 = ax_sliders.inset_axes([0.0, 0.8, 0.8, 0.1])\nax_d2 = ax_sliders.inset_axes([0.0, 0.6, 0.8, 0.1])\nax_f = ax_sliders.inset_axes([0.0, 0.4, 0.8, 0.1])\nax_k = ax_sliders.inset_axes([0.0, 0.2, 0.8, 0.1])\n\nslider_d1 = Slider(ax_d1, \"D1\", 0.01, 0.2, valinit=d1, valstep=0.01)\nslider_d2 = Slider(ax_d2, \"D2\", 0.01, 0.2, valinit=d2, valstep=0.01)\nslider_f = Slider(ax_f, \"F\", 0.01, 0.09, valinit=f, valstep=0.001)\nslider_k = Slider(ax_k, \"k\", 0.04, 0.07, valinit=k, valstep=0.001)\n\n# TODO: update parameters when sliders change\n\n\n\n\n\n\nHint: slider update (click to expand)\n\n\n\n\n\ndef update_sliders(_):\n    nonlocal d1, d2, f, k, pause\n    d1 = slider_d1.val\n    d2 = slider_d2.val\n    f = slider_f.val\n    k = slider_k.val\n    pause = True\n\nslider_d1.on_changed(update_sliders)\nslider_d2.on_changed(update_sliders)\nslider_f.on_changed(update_sliders)\nslider_k.on_changed(update_sliders)",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott: Interaction"
    ]
  },
  {
    "objectID": "modules/pde-2d/assignment.html",
    "href": "modules/pde-2d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Complete a 2D reaction-diffusion simulation and report your findings.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-2d/assignment.html#required",
    "href": "modules/pde-2d/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement the 2D Gierer-Meinhardt PDE with a 5-point stencil.\nUse \\(L_1=20\\), \\(L_2=50\\), \\(dx=1\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).\nPlot a snapshot of \\(v(x,y)\\) after a long integration.\nCreate an animation that updates \\(v(x,y)\\) in real time.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-2d/assignment.html#turing-instability",
    "href": "modules/pde-2d/assignment.html#turing-instability",
    "title": "Assignment",
    "section": "Turing Instability",
    "text": "Turing Instability\n\nImplement find_unstable_spatial_modes() and report the leading mode for \\(d=20\\) and \\(d=30\\).\nState whether each case exhibits Turing instability.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-2d/assignment.html#gray-scott-optional",
    "href": "modules/pde-2d/assignment.html#gray-scott-optional",
    "title": "Assignment",
    "section": "Gray-Scott (Optional)",
    "text": "Gray-Scott (Optional)\n\nImplement the Gray-Scott model and reproduce one of the parameter sets (A-E).\nAdd interaction: draw perturbations and pause/resume the simulation.",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/pde-2d/assignment.html#tips-for-success",
    "href": "modules/pde-2d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart small: use a smaller grid to debug the update function.\nCheck dt: if the simulation explodes, reduce \\(dt\\) or increase \\(dx\\).\nValidate: compare your pattern to ?@fig-gm-2d in the module notes.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 5: PDEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html",
    "href": "modules/ode-2d/fitzhugh-nagumo.html",
    "title": "FitzHugh–Nagumo Model",
    "section": "",
    "text": "The FitzHugh–Nagumo model is a simplified neuron model that captures key features of excitability and spiking behavior. It consists of two coupled ODEs:\n\\[\\begin{aligned}\n\\epsilon \\dot v &= f(v) - w + I_{\\text{app}} \\\\\n\\dot w &= v - \\gamma w\n\\end{aligned} \\tag{1}\\]\nWhere \\(v\\) is the fast variable representing the membrane potential, \\(w\\) is a recovery variable, \\(I_{\\text{app}}\\) is an applied current, and \\(\\epsilon \\ll 1\\) controls the timescale separation between the fast variable \\(v\\) and the slow variable \\(w\\). \\(f(v)\\) is a cubic nonlinearity, often taken as\n\\[\nf(v) = v (1 - v)(v - \\alpha),\\quad \\text{for } 0 &lt; \\alpha &lt; 1\n\\tag{2}\\]\nFigure 1: Phase plane of the FitzHugh–Nagumo system with epsilon = 0.01, gamma = 0.5, I_app = 0.5 and alpha = 0.1. Trajectories are shown for different initial conditions (IC as v-w, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\nFollow the steps outline in the CDIMA model to explore how the FitzHugh–Nagumo system behaves for different initial conditions and parameters.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html#time-series-and-excitability",
    "href": "modules/ode-2d/fitzhugh-nagumo.html#time-series-and-excitability",
    "title": "FitzHugh–Nagumo Model",
    "section": "Time Series and Excitability",
    "text": "Time Series and Excitability\nIn the excitable regime, trajectories typically stay near the resting equilibrium, but sufficiently large perturbations can trigger a large excursion (a “spike”) before returning to rest.\nBelow we plot the fast variable \\(v(t)\\) for a fixed parameter set and initial condition.\n\n\n\n\n\n\n\n\nFigure 2: Time series \\(v(t)\\) for the FitzHugh–Nagumo system (same parameters as the phase-plane plot). Depending on the initial condition, the solution may relax to rest or exhibit a spike/oscillation.\n\n\n\n\n\nTry changing the initial condition and parameters to see how the time series changes. What regimes of behavior do you observe? Can you connect these observations to the phase plane trajectories and the underlying theory of excitability?",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/fitzhugh-nagumo.html#resources",
    "href": "modules/ode-2d/fitzhugh-nagumo.html#resources",
    "title": "FitzHugh–Nagumo Model",
    "section": "Resources",
    "text": "Resources\n\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/amlab/odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "FitzHugh–Nagumo Model"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html",
    "href": "modules/ode-2d/van-der-pol.html",
    "title": "Van der Pol Oscillator",
    "section": "",
    "text": "The Van der Pol oscillator is a prototypical nonlinear system that exhibits self-sustained oscillations. For a wide range of initial conditions, trajectories converge to a stable limit cycle.\nIn the form we will use in this course, the system is written as (Strogatz 2024, chap. 7.5):\n\\[\\begin{aligned}\n\\dot x &= \\mu\\,(y - f(x)) \\\\\n\\dot y &= -\\frac{x}{\\mu}\n\\end{aligned} \\tag{1}\\]\nwhere \\(\\mu&gt;0\\) controls the strength of the nonlinearity (and the fast–slow character for large \\(\\mu\\)), and\n\\[\nf(x) = \\frac{x^3}{3} - x.\n\\tag{2}\\]\nFigure 1: Phase plane of the Van der Pol system with mu = 3. Trajectories are shown for different initial conditions (IC as x-y, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\nFollow the steps outline in the CDIMA model to explore how the Van der Pol system behaves for different initial conditions and parameters.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html#the-stable-limit-cycle",
    "href": "modules/ode-2d/van-der-pol.html#the-stable-limit-cycle",
    "title": "Van der Pol Oscillator",
    "section": "The Stable Limit Cycle",
    "text": "The Stable Limit Cycle\nThe Van der Pol system has a stable limit cycle that attracts trajectories from a wide range of initial conditions. Plot this limit cycle as a \\(x(t)-t\\) plot, and verify that it matches the phase plane trajectories.\n\n\n/tmp/ipykernel_3099/2854713749.py:14: UserWarning:\n\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n\n\n\n\n\n\n\n\n\nFigure 2: Time series of x(t) for the Van der Pol system with mu = 3 and IC: (2, -2). Generated with scipy.integrate.solve_ivp() and matplotlib.\n\n\n\n\n\nThe amplitude and period of the limit cycle depend on \\(\\mu\\). There are two phases of the limit cycle: a slow phase where trajectories move slowly near the cubic nullcline, and a fast phase where trajectories rapidly jump between branches of the nullcline. The speed of the slow phase increases with \\(\\mu\\), while the fast phase becomes more abrupt. This leads to a characteristic “relaxation oscillation” shape for large \\(\\mu\\).\nPlay with the parameter \\(\\mu\\) to see how it changes the shape of the limit cycle and the transient dynamics.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/van-der-pol.html#resources",
    "href": "modules/ode-2d/van-der-pol.html#resources",
    "title": "Van der Pol Oscillator",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 7.5) for theoretical background on the Van der Pol oscillator.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/amlab/odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Van der Pol Oscillator"
    ]
  },
  {
    "objectID": "modules/ode-2d/assignment.html",
    "href": "modules/ode-2d/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "You will build a Matplotlib animation for one 2D ODE model.\nChoose a model\nWrite one Python script that, when executed, opens a figure showing:\nUse the pipeline showed for the CDIMA model as a starting point, and adapt it to the model you choose. For the animation, follow the steps outlined in the animation page.\nThen, add a second subplot that animates the time evolution of one variable (as indicated in the page for each model).\nExtra Mile (Optional): Make the figure interactive: clicking on the phase plane sets the initial condition, and the animation restarts.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-2d/assignment.html#tips-for-success",
    "href": "modules/ode-2d/assignment.html#tips-for-success",
    "title": "Assignment",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple: Get the ODE function working first, then build up.\nTest incrementally: Verify each function works before moving to the next.\nUse the reference: The provided code (and additional documentation) is there to help you understand the structure.\nExperiment: Try different parameter values and see what happens.\nCollaborate: Discuss with your teammates, divide the work if needed. You can also work separately and then compare your implementations.\nAsk questions: If you’re stuck, ask for help!\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/cellular-automata/index.html",
    "href": "modules/cellular-automata/index.html",
    "title": "Cellular Automata",
    "section": "",
    "text": "In this session we explore 1D cellular automata and apply them to traffic models.",
    "crumbs": [
      "Session 8: Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/index.html#case-studies",
    "href": "modules/cellular-automata/index.html#case-studies",
    "title": "Cellular Automata",
    "section": "Case Studies",
    "text": "Case Studies\n1D Cellular AutomataAssignment",
    "crumbs": [
      "Session 8: Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/index.html#what-do-we-need",
    "href": "modules/cellular-automata/index.html#what-do-we-need",
    "title": "Cellular Automata",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nEfficient arrays for state updates.\n\n\nmatplotlib.pyplot\nVisualize space-time diagrams.\n\n\nmatplotlib.backend_bases\nHandle mouse clicks for interactive initial conditions.",
    "crumbs": [
      "Session 8: Cellular Automata"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html",
    "href": "modules/collective-motion/vicsek.html",
    "title": "Vicsek Model",
    "section": "",
    "text": "The Vicsek model describes \\(N\\) self-propelled particles (boids) that align with neighbors within a radius \\(r\\), plus noise \\(\\eta\\). Each particle has position \\(\\mathbf{x}_i(t)\\) and heading \\(\\theta_i(t)\\).\nFigure 1: Vicsek model: boids on a square with heading arrows.",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html#initial-state",
    "href": "modules/collective-motion/vicsek.html#initial-state",
    "title": "Vicsek Model",
    "section": "Initial State",
    "text": "Initial State\nCreate the initial positions and headings. Positions are uniform on the box and headings are uniform on \\([0, 2\\pi]\\).\ndef initialize_particles(num_boids, box_size):\n    # Random initial theta, shape (N)\n    theta =\n\n    # Random initial x, y - shape (2, N)\n    xy =\n    return xy, theta\n\n\n\n\n\n\nSolved: Initialization (click to expand)\n\n\n\n\n\ndef initialize_particles(num_boids, box_size):\n    theta = np.random.uniform(0, 2 * np.pi, num_boids)\n    xy = np.random.uniform(0, box_size, (2, num_boids))\n    return xy, theta\n\n\n\nTry out your function now. Vicsek used \\(N \\in [40, 10000]\\) and \\(L \\in [3.0, 50.0]\\) in his simulations. The more particles you have, the slower the simulation will be, so start with a small number like \\(N=100\\) and a box size of \\(L=10\\).",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html#motion",
    "href": "modules/collective-motion/vicsek.html#motion",
    "title": "Vicsek Model",
    "section": "Motion",
    "text": "Motion\nAll boids have the same speed module \\(v_0\\), but their headings change based on neighbors. Every time step \\(\\Delta t\\), each boid averages the headings of neighbors within radius \\(r\\) and adds noise \\(\\eta\\). Then it moves in the new heading direction. This happens simultaneously to all boids. Follow the equations in (Vicsek et al. 1995) to implement the update step. We provide a summary here.\nThe positions of the \\(i\\)th particle is updated as:\n\\[\n\\mathbf{x}_i(t + \\Delta t) = \\mathbf{x}_i(t) + v_0 \\Delta t \\begin{bmatrix} \\cos(\\theta_i(t + \\Delta t)) \\\\ \\sin(\\theta_i(t + \\Delta t)) \\end{bmatrix}.\n\\tag{1}\\]\nWhere \\(v_0\\) is the speed module, which Vicsek assumed to be \\(v_0 = 0.03\\) in his simulations.\nIt is important to remember that particles stay within the box. We will apply periodic boundary conditions, meaning that a particle that goes out of the box on one side reappears on the opposite side. Mathematically, we can implement this with the modulo operator, if we assume that the positions are in the range \\([0, L]\\):\n\\[\n\\mathbf{x}_i(t + \\Delta t) = \\mathbf{x}_i(t + \\Delta t) \\mod L,\n\\tag{2}\\]\nComing back to ?@eq-vicsek-xi, in order to compute the new positions, we need to compute the new heading \\(\\theta_i(t + \\Delta t)\\) as:\n\\[\n\\theta_i(t + \\Delta t) = \\langle \\theta_j(t) \\rangle_{j \\in \\mathcal{N}_i} + \\frac{\\eta}{2} \\xi_i(t),\n\\tag{3}\\]\nwhere \\(\\mathcal{N}_i\\) is the set of neighbors within radius \\(r\\) of particle \\(i\\), \\(\\langle \\cdot \\rangle\\) denotes the average angle, and \\(\\xi_i(t)\\) is a random variable uniformly distributed in \\([-1, 1]\\). Vicsek used \\(r = 1\\) and \\(\\eta \\in [0.0, 5.0]\\) in his simulations.\n\nPython Implementation\nBefore we jump into coding, it is good to outline the steps we need to take for each time step:\n\nFor each particle \\(i\\), find its neighbors within radius \\(r\\).\nCompute the average heading of these neighbors.\nAdd noise to the average heading to get the new heading \\(\\theta_i(t + \\Delta t)\\).\nUpdate the position of each particle based on its new heading.\nApply periodic boundary conditions to ensure particles stay within the box.\n\nFor steps 1, we need to compare every particle with every other particle to compute distances. This can be done with nested loops or more efficiently with a distance matrix. For simplicity, start with the loop version. Once we know the distances, we can get all neighbors for each particle and compute the average heading. Finally, we add noise, following Equation 3.\n# What we have:\nxy # the positions of the particles, shape (2, N)\ntheta # the headings of the particles, shape (N)\nnoise # the noise level eta\n# ----\n\nnum_boids = xy.shape[1]  # N\n\n# Loop over each particle\nfor i in range(num_boids):\n    # Initialize list to store neighbor headings\n    ls_theta_neighbors = []\n    # Loop over all other particles to find neighbors\n    for j in range(num_boids):\n        # TODO: Skip self comparison (i == j)\n\n        # TODO: Compute distance between particle i and j\n        \n        # TODO: If distance is less than radius,\n        # add the heading of particle j to the list of neighbors\n    # After finding neighbors...\n    # TODO: Compute the average heading and add noise\n\n# Result: updated theta for all particles\n\n\n\n\n\n\nSolved: Update theta using loops (click to expand)\n\n\n\n\n\nnum_boids = xy.shape[1]  # N\n\n# Loop over each particle\nfor i in range(num_boids):\n    # Initialize list to store neighbor headings\n    ls_theta_neighbors = []\n    # Loop over all other particles to find neighbors\n    for j in range(num_boids):\n        # Skip self comparison\n        if i == j:\n            continue\n        # Compute distance between particle i and j\n        dist = np.linalg.norm(xy[:, i] - xy[:, j])\n        # If distance is less than radius,\n        # add the heading of particle j to the list of neighbors\n        if dist &lt;= radius_interaction:\n            ls_theta_neighbors.append(theta[j])\n    # After finding neighbors\n    # Compute the average heading...\n    theta_new[i] = np.mean(ls_theta_neighbors)\n    # ...and add noise\n    theta_new[i] += noise * np.pi * np.random.uniform(-1, 1)\n\n\n\nJust with that, we have implemented steps 1-3. Now we can compute the new positions based on the new headings, following Equation 1.\n# After updating theta for all particles\nfor i in range(num_boids):\n    # TODO: Compute velocity vector based on new heading\n\n    # TODO: Update position based on velocity and time step\n\n# Result: updated xy for all particles\nThere is a final step to apply periodic boundary conditions, following Equation 2.\n# After updating positions for all particles\n# TODO: Apply periodic boundary conditions to xy\n\n# Result: updated xy with periodic boundaries\n::: {.callout-tip collapse=“true”} ## Solved: Update positions and apply periodic boundaries (click to expand)\n# After updating theta for all particles\nfor i in range(num_boids):\n    # Compute velocity vector based on new heading\n    v = v0 * np.array([np.cos(theta_new[i]), np.sin(theta_new[i])])\n    # Update position based on velocity and time step\n    xy_new[:, i] = xy_new[:, i] + dt * v\n\n# Apply periodic boundary conditions to xy\nxy = np.mod(xy_new, box_size)\n# We overwrite xy with the new positions after applying periodic boundaries\nDo you have it? Excellent! Last but not least, we can put everything together in a function that takes the current positions and headings and returns the updated positions and headings after one time step.\n\n\n\n\n\n\nSolved: Vicsek equations, loop version (click to expand)\n\n\n\n\n\ndef vicsek_equations(xy, theta, dt=1.0, eta=0.1, box_size=10, radius_interaction=1, v0=0.03):\n    xy_new = xy.copy()\n    theta_new = theta.copy()\n    num_boids = len(theta)\n    for i in range(num_boids):\n        ls_theta_neighbors = []\n        for j in range(num_boids):\n            dist = np.linalg.norm(xy[:, i] - xy[:, j])\n            if dist &lt;= radius_interaction:\n                ls_theta_neighbors.append(theta[j])\n        theta_new[i] = np.mean(ls_theta_neighbors)\n        theta_new[i] += eta * np.pi * np.random.uniform(-1, 1)\n\n        v = v0 * np.array([np.cos(theta_new[i]), np.sin(theta_new[i])])\n        xy_new[:, i] = xy_new[:, i] + dt * v\n\n    xy_new = np.mod(xy_new, box_size)\n    return xy_new, theta_new",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html#python-implementation-vectorized-version-optional",
    "href": "modules/collective-motion/vicsek.html#python-implementation-vectorized-version-optional",
    "title": "Vicsek Model",
    "section": "Python Implementation: Vectorized Version (Optional)",
    "text": "Python Implementation: Vectorized Version (Optional)\nLoops are expensive. You can compute neighbor averages with a distance matrix.\ndef vicsek_equations(\n    xy: np.ndarray,\n    theta: np.ndarray,\n    noise: float = 0.1,\n    box_size: float = 25,\n    dt: float = 1,\n    radius_interaction: float = 1,\n    v0: float = 0.03,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    # TODO: Compute distance matrix and neighbor matrix\n    # Useful functions:\n    # scipy.spatial.distance.pdist\n    # scipy.spatial.distance.squareform\n    \n    # TODO: Vectorized computation of average direction of neighbors (including itself)\n    # Useful functions: np.sin, np.cos, np.arctan2\n\n    # TODO: Add noise to the average heading\n    # Useful function: np.random.rand\n\n    # TODO: Update position based on new headings\n    # Useful functions: np.cos, np.sin\n\n    return xy_new, theta_new\n\n\n\n\n\n\nSolved: Vicsek equations, vectorized version (click to expand)\n\n\n\n\n\ndef vicsek_equations(\n    xy: np.ndarray,\n    theta: np.ndarray,\n    noise: float = 0.1,\n    box_size: float = 25,\n    dt: float = 1,\n    radius_interaction: float = 1,\n    v0: float = 0.03,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Update the state of the particles based on the Vicsek model.\n\n    Parameters\n    ----------\n    xy : np.ndarray\n        Position of the particles.\n    theta : np.ndarray\n        Angle of the particles.\n    noise : float, optional\n        Noise parameter, eta, default is 0.1.\n    box_size : float, optional\n        Dimension of the space, L, default is 25.\n    dt : float, optional\n        Time step, default is 1 [Vicsek1995]\n    radius_interaction : float, optional\n        Interaction radius, default is 1 [Vicsek1995]\n    v0 : float, optional\n        Speed of the particles, default is 0.03 [Vicsek1995]\n\n    Returns\n    -------\n    np.ndarray\n        Updated position of the particles.\n    np.ndarray\n        Updated angle of the particles.\n    \"\"\"\n    # Compute distance matrix and neighbor matrix\n    d_matrix = scipy.spatial.distance.pdist(xy.T)\n    d_matrix = scipy.spatial.distance.squareform(d_matrix)\n    neighbors = d_matrix &lt;= radius_interaction\n    # Vectorized computation of average direction of neighbors (including itself)\n    num_boids = xy.shape[1]\n    sin_theta = np.sin(theta)\n    cos_theta = np.cos(theta)\n    # neighbors is (N, N), sin_theta/cos_theta is (N,)\n    # Broadcasting: (N, N) * (N,) -&gt; (N, N)\n    sum_sin = neighbors @ sin_theta  # (N,)\n    sum_cos = neighbors @ cos_theta  # (N,)\n    count = neighbors.sum(axis=1)  # (N,)\n    mean_sin = sum_sin / count\n    mean_cos = sum_cos / count\n    theta_avg = np.arctan2(mean_sin, mean_cos)\n    # Add noise: uniform in [-noise/2, noise/2]\n    noise_arr = noise * (np.random.uniform(size=num_boids) - 0.5)\n    theta_new = theta_avg + noise_arr\n    theta_new = np.mod(theta_new, 2 * np.pi)\n\n    # Update position\n    v = v0 * np.array([np.cos(theta_new), np.sin(theta_new)])\n    xy_new = xy + dt * v\n    # Periodic boundary conditions\n    xy_new = np.mod(xy_new, box_size)\n\n    return xy_new, theta_new",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html#order-parameter",
    "href": "modules/collective-motion/vicsek.html#order-parameter",
    "title": "Vicsek Model",
    "section": "Order Parameter",
    "text": "Order Parameter\nThe order parameter \\(\\varphi\\) is defined as the magnitude of the average velocity vector normalized by the speed:\n\\[\n\\varphi(t) = \\frac{1}{N v_0} \\left|\\sum_{i=1}^N v_0 \\begin{bmatrix} \\cos(\\theta_i(t)) \\\\ \\sin(\\theta_i(t)) \\end{bmatrix}\\right| = \\frac{1}{N} \\left|\\sum_{i=1}^N \\begin{bmatrix} \\cos(\\theta_i(t)) \\\\ \\sin(\\theta_i(t)) \\end{bmatrix}\\right|.\n\\tag{4}\\]\nWe can compute this at each time step to see how the system evolves. In the disordered phase, \\(\\varphi \\approx 0\\) because the headings are random and cancel out. In the ordered phase, \\(\\varphi \\approx 1\\) because all particles align in the same direction.\ndef vicsek_order_parameter(xy: np.ndarray, theta: np.ndarray, v0: float = 0.03) -&gt; float:\n    # TODO: Compute the order parameter phi based on the headings theta\n    return phi\n\n\n\n\n\n\nSolved: Order parameter (click to expand)\n\n\n\n\n\ndef vicsek_order_parameter(theta: np.ndarray, v0: float = 0.03) -&gt; float:\n    \"\"\"\n    Compute the normalized order parameter (mean velocity divided by v0), as in Vicsek et al. (1995).\n    \"\"\"\n    vx = v0 * np.cos(theta)\n    vy = v0 * np.sin(theta)\n    avg_vx = np.mean(vx)\n    avg_vy = np.mean(vy)\n    return float(np.sqrt(avg_vx**2 + avg_vy**2) / v0)",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek.html#references",
    "href": "modules/collective-motion/vicsek.html#references",
    "title": "Vicsek Model",
    "section": "References",
    "text": "References\n\n(Vicsek et al. 1995)",
    "crumbs": [
      "Session 4: Collective Motion",
      "Vicsek Model"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek-predator.html",
    "href": "modules/collective-motion/vicsek-predator.html",
    "title": "Vicsek Model with Predator",
    "section": "",
    "text": "Now add a predator that boids avoid. The predator position is controlled by the mouse, and boids change their angle when they are within a predator radius.\nThe repulsion angle is\n\\[\\Theta_{\\text{rep}, i} = \\tan^{-1}\\left(\\frac{y_i - y_{\\text{pred}}}{x_i - x_{\\text{pred}}}\\right). \\tag{1}\\]\nWe blend alignment and repulsion with strength \\(k\\):\n\\[\\Theta_i = (1-k)\\left(\\langle \\Theta_j \\rangle + \\eta_i\\right) + k\\,\\Theta_{\\text{rep}, i}. \\tag{2}\\]",
    "crumbs": [
      "Session 4: Collective Motion",
      "Predator Effect"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek-predator.html#track-the-predator",
    "href": "modules/collective-motion/vicsek-predator.html#track-the-predator",
    "title": "Vicsek Model with Predator",
    "section": "Track the predator",
    "text": "Track the predator\nfrom matplotlib.backend_bases import MouseEvent\n\n# Inside run_simulation\nxy_pred = np.array([-1000, -1000])\nradius_predator = 1.0\nstrength_predator = 0.1\n\n\ndef on_mouse_move(event: MouseEvent):\n    nonlocal xy_pred\n    if event.inaxes == ax_plane:\n        xy_pred = np.array([event.xdata, event.ydata])\n    else:\n        xy_pred = np.array([-1000, -1000])\n\nfig.canvas.mpl_connect(\"motion_notify_event\", on_mouse_move)",
    "crumbs": [
      "Session 4: Collective Motion",
      "Predator Effect"
    ]
  },
  {
    "objectID": "modules/collective-motion/vicsek-predator.html#update-the-equations",
    "href": "modules/collective-motion/vicsek-predator.html#update-the-equations",
    "title": "Vicsek Model with Predator",
    "section": "Update the equations",
    "text": "Update the equations\nAdd the predator terms inside your Vicsek update.\ndef vicsek_equations(\n    xy, theta, dt, eta, box_size, radius_interaction, v0,\n    xy_pred, radius_predator, strength_predator,\n):\n    # TODO: compute alignment as usual\n\n    # TODO: compute repulsion angle and blend with k\n    return xy, theta\n\n\n\n\n\n\nHint: Predator update (click to expand)\n\n\n\n\n\n# Distances to predator\n d_pred = np.linalg.norm(xy - xy_pred[:, np.newaxis], axis=0)\n affected = d_pred &lt;= radius_predator\n repulsion_angle = np.arctan2(xy[1] - xy_pred[1], xy[0] - xy_pred[0])\n term_pred = strength_predator * (repulsion_angle - theta) * affected\n theta = np.mod(theta + term_pred, 2 * np.pi)\n\n\n\nIf you want a full working reference, check amlab/collective_motion/vicsek_predator.py.",
    "crumbs": [
      "Session 4: Collective Motion",
      "Predator Effect"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-diagram.html",
    "href": "modules/ode-coupled/kuramoto-diagram.html",
    "title": "Kuramoto Model",
    "section": "",
    "text": "The order parameter \\(r\\) measures the coherence of the population. As coupling \\(K\\) increases, the system transitions from incoherent (\\(r \\approx 0\\)) to synchronized (\\(r &gt; 0\\)).\nFor a Cauchy distribution with scale \\(\\gamma\\):\n\\[\nK_c = \\frac{2}{\\pi g(0)}\n\\tag{1}\\]\nwhere \\(g(\\omega)\\) is the probability density function of the natural frequencies. For a Cauchy distribution with scale parameter \\(\\gamma\\):\n\\[\ng(\\omega)=\\frac{1}{\\pi} \\frac{\\gamma}{\\omega^2+\\gamma^2}\n\\tag{2}\\]\nIn particular, \\(g(0)=\\frac{1}{\\pi\\gamma}\\), so the critical coupling simplifies to\n\\[\nK_c = 2\\gamma\n\\tag{3}\\]\nThe theoretical order parameter is:\n\\[\nr(K)=\n\\begin{cases}\n0, & K \\le K_c \\\\\n\\sqrt{1-\\frac{K_c}{K}}, & K &gt; K_c\n\\end{cases}\n\\tag{4}\\]\nWarning: This exact formula only works for a Cauchy distribution!\nFigure 1: Kuramoto diagram: theoretical curve from Equation 4 and empirical points (drawn from a normal distribution). Why is there a mismatch?\nFor any other distribution, the theoretical order parameter near onset is\n\\[\nr \\approx \\sqrt{\\frac{16}{\\pi K_c^3}} \\sqrt{\\frac{\\mu}{-g''(0)}}\n\\tag{5}\\]\nwhere \\(\\mu\\) measures the distance from the critical point (a dimensionless reduced coupling) and \\(g''(0)\\) is the second derivative of the frequency distribution at \\(0\\).\n\\[\n\\mu = \\frac{K - K_c}{K_c}\n\\tag{6}\\]\nThis formula is derived from a perturbative analysis near the critical point and captures the square-root scaling of the order parameter as the coupling strength exceeds the critical value.\nFor a normal distribution with scale parameter (standard deviation) sigma:\n\\[\ng(\\omega) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{\\omega^2}{2\\sigma^2}\\right)\n\\tag{7}\\]\n\\[\ng''(\\omega) = \\left( \\frac{\\omega^2}{\\sigma^4} - \\frac{1}{\\sigma^2} \\right) g(\\omega)\n\\tag{8}\\]",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Bifurcation Diagram"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-diagram.html#python-implementation",
    "href": "modules/ode-coupled/kuramoto-diagram.html#python-implementation",
    "title": "Kuramoto Model",
    "section": "Python Implementation",
    "text": "Python Implementation\nIn a new script, draw the theoretical bifurcation diagram for \\(0 &lt; K &lt; 5\\).\nOn top of it, draw the empirical curve, using \\(N = 1000\\) oscillators, \\(dt = 0.01\\), stopping at \\(t = 100\\) and averaging the order parameter (\\(r\\)) over the last ten steps.\nDo your two curves match? The example in Figure 1 shows a mismatch. Can you explain why? Can you fix it? If you are stuck, check the solution below.\n\n\n\n\n\n\nWhy is there a mismatch?\n\n\n\n\n\nThe mismatch occurs because the closed-form theoretical curve Equation 4 is derived for a Cauchy frequency distribution, while the empirical data in Figure 1 is generated from a normal distribution.\nTo fix this you have two consistent options:\n\nKeep the normal distribution and use a matching theoretical prediction (typically only an approximation near onset, e.g. Equation 5).\nKeep the closed-form curve Equation 4 and generate the empirical data using a Cauchy distribution.\n\n\n\n\n\n\n\n\n\nFigure 2: Kuramoto diagram: empirical points (normal frequencies) and a matching theoretical prediction (see Equation 5 for the near-onset scaling).\n\n\n\n\n\nAlternatively, fix the mismatch by changing the empirical distribution to a Cauchy distribution, which matches the closed-form curve Equation 4.\n\n\n\n\n\n\n\n\nFigure 3: Kuramoto diagram: theoretical curve Equation 4 and empirical points (Cauchy frequencies).",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Bifurcation Diagram"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-diagram.html#validate-your-findings",
    "href": "modules/ode-coupled/kuramoto-diagram.html#validate-your-findings",
    "title": "Kuramoto Model",
    "section": "Validate Your Findings",
    "text": "Validate Your Findings\nFind the critical coupling \\(K_c\\) from the theoretical formula and check if it matches the empirical transition point in your simulations. You can estimate the empirical \\(K_c\\) by looking for the value of \\(K\\) where \\(r\\) starts to deviate significantly from zero. Or use then ear-onset scaling Equation 5 to fit the empirical data and extract an estimate of \\(K_c\\).\nIn your animation script from the previous page, try setting the coupling strength just below and just above the critical value to see the difference in the dynamics. You should see that below \\(K_c\\), the oscillators remain incoherent, while above \\(K_c\\), they start to synchronize and form a cluster on the unit circle.\n\n\n\n\n\n\n\n\nFigure 4: Comparison between the theoretical critical coupling \\(K_c\\) and the empirical transition point observed in simulations. Individual oscillators are represented as blue dots, while the coupling strength is painted red.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Bifurcation Diagram"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-diagram.html#whats-next",
    "href": "modules/ode-coupled/kuramoto-diagram.html#whats-next",
    "title": "Kuramoto Model",
    "section": "What’s Next?",
    "text": "What’s Next?\nIn the next page, we will merge the bifurcation diagram with the oscillator animation to create a full simulation of the Kuramoto model. This will allow us to see how the order parameter evolves in real time as we adjust the coupling strength and other parameters using sliders.\nFull Simulation",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Bifurcation Diagram"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html",
    "href": "modules/ode-coupled/kuramoto-oscillators.html",
    "title": "Kuramoto Model",
    "section": "",
    "text": "The phases \\(\\theta_i\\) are sampled uniformly on \\([0, 2\\pi]\\) and the natural frequencies \\(\\omega_i\\) from a normal distribution with standard deviation \\(\\sigma\\).\nWrite a function to initialize the oscillators:\ndef initialize_oscillators(num_oscillators: int, sigma: float = 1.0):\n    # Assign a random initial phase to each oscillator\n    theta =  # draw from uniform distribution\n\n    # Assign a random natural frequency to each oscillator\n    omega =  # draw from normal distribution\n    return theta, omega\nThe outputs theta and omega are 1D arrays of length num_oscillators. If you don’t know how to sample from these distributions, see the hint below.\n\n\n\n\n\n\nHow to sample from distributions (click to expand)\n\n\n\n\n\nRemember NumPy has built-in functions for sampling from distributions: - Uniform distribution: np.random.uniform(low=0.0, high=2*np.pi, size=num_oscillators) - Normal distribution: np.random.normal(loc=0.0, scale=sigma, size=num_oscillators)\nIf you need more help, you can expand the code snippet below for a complete implementation.\n\n\n\n\n\n\n\n\n\nComplete initialization function (click to expand)\n\n\n\n\n\ndef initialize_oscillators(num_oscillators: int, sigma: float = 1.0):\n    # Assign a random initial phase to each oscillator\n    theta =  np.random.uniform(low=0.0, high=2 * np.pi, size=num_oscillators)\n\n    # Assign a random natural frequency to each oscillator\n    omega =  np.random.normal(loc=0.0, scale=sigma, size=num_oscillators)\n    return theta, omega\n(Remember to import numpy first!)",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#initialize-oscillators",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#initialize-oscillators",
    "title": "Kuramoto Model",
    "section": "",
    "text": "The phases \\(\\theta_i\\) are sampled uniformly on \\([0, 2\\pi]\\) and the natural frequencies \\(\\omega_i\\) from a normal distribution with standard deviation \\(\\sigma\\).\nWrite a function to initialize the oscillators:\ndef initialize_oscillators(num_oscillators: int, sigma: float = 1.0):\n    # Assign a random initial phase to each oscillator\n    theta =  # draw from uniform distribution\n\n    # Assign a random natural frequency to each oscillator\n    omega =  # draw from normal distribution\n    return theta, omega\nThe outputs theta and omega are 1D arrays of length num_oscillators. If you don’t know how to sample from these distributions, see the hint below.\n\n\n\n\n\n\nHow to sample from distributions (click to expand)\n\n\n\n\n\nRemember NumPy has built-in functions for sampling from distributions: - Uniform distribution: np.random.uniform(low=0.0, high=2*np.pi, size=num_oscillators) - Normal distribution: np.random.normal(loc=0.0, scale=sigma, size=num_oscillators)\nIf you need more help, you can expand the code snippet below for a complete implementation.\n\n\n\n\n\n\n\n\n\nComplete initialization function (click to expand)\n\n\n\n\n\ndef initialize_oscillators(num_oscillators: int, sigma: float = 1.0):\n    # Assign a random initial phase to each oscillator\n    theta =  np.random.uniform(low=0.0, high=2 * np.pi, size=num_oscillators)\n\n    # Assign a random natural frequency to each oscillator\n    omega =  np.random.normal(loc=0.0, scale=sigma, size=num_oscillators)\n    return theta, omega\n(Remember to import numpy first!)",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#plot-the-oscillators",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#plot-the-oscillators",
    "title": "Kuramoto Model",
    "section": "Plot the Oscillators",
    "text": "Plot the Oscillators\nTo visualize the oscillators, we can plot their phases on the unit circle. The x-coordinate is \\(\\cos(\\theta_i)\\) and the y-coordinate is \\(\\sin(\\theta_i)\\). This way, each oscillator corresponds to a point on the circle. Build a code to visualize the oscillators as blue dots on the unit circle. Your output should be similar to Figure 1, but feel free to show it in your own style!\n\n\n\n\n\n\n\n\nFigure 1: Sample visualization of oscillators on the unit circle. Each blue dot represents an oscillator with phase \\(\\theta_i\\).\n\n\n\n\n\nIf you don’t know how to achieve the plot above, feel free to expand some of the hints below.\n\n\n\n\n\n\nHow to compute the positions of the oscillators (click to expand)\n\n\n\n\n\nTo compute the x and y coordinates for the plot, you can use NumPy’s cos and sin functions applied to the theta array:\nx = np.cos(theta)\ny = np.sin(theta)\n(Remember to import numpy first!)\n\n\n\n\n\n\n\n\n\nHow to create the plot (click to expand)\n\n\n\n\n\nTo create the plot, you can use Matplotlib’s subplots function to set up the figure and axes, and then use scatter to plot the points. Here’s a complete example:\n# First, we prepare the figure and axes\nfig, ax = plt.subplots(figsize=(6, 6))\n# fig is the Figure, a \"canvas\" where everything is drawn\n# ax is the Axes, a \"subplot\" where we can plot data\n# A single figure can have multiple axes (e.g. for subplots)\nax.set_title(\"Kuramoto Model\")  # Title of the plot\nax.set_xlabel(\"Cos(theta)\")  # Name of x-axis\nax.set_ylabel(\"Sin(theta)\")  # Name of y-axis\nax.set_xlim(-1.1, 1.1)  # Limits for x-axis\nax.set_ylim(-1.1, 1.1)  # Limits for y-axis\nax.set_aspect(\"equal\")  # Make the circle look circular\nax.grid(True)  # Show grid lines\n# Draw unit circle (optional, but it helps to visualize the boundary)\ncircle = plt.Circle((0, 0), 1, color=\"lightgray\", fill=False)\nax.add_artist(circle)\n\n# Now we are ready to plot the oscillators as blue dots\nax.scatter(x, y, s=50, color=\"blue\", alpha=0.5)\n# s is the size of the dots\n# alpha is the transparency (0 is fully transparent, 1 is fully opaque)\n# we want the oscillators to be somewhat transparent so we can see overlaps\n\n# Finally, we show the plot and close it to free up memory\nplt.show()\nplt.close()",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#define-the-ode",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#define-the-ode",
    "title": "Kuramoto Model",
    "section": "Define the ODE",
    "text": "Define the ODE\nChoose between the original pairwise form of the Kuramoto model or the mean field approximation. You can see both forms in the theory page Kuramoto Model. The mean field approximation is often more efficient for large populations, as it avoids computing pairwise interactions.\nFollow the template below to define the ODE function for the Kuramoto model. Call it kuramoto_ode(). The function should compute the derivatives of the phases \\(\\dot\\theta_i\\) based on the current phases \\(\\theta_i\\), natural frequencies \\(\\omega_i\\), and coupling strength \\(K\\).\ndef ode(t, state, *params):\n    # state represents the current values of the variables (e.g., x, y)\n\n    # params are any additional parameters needed to compute the derivatives\n    # each of them is separated by commas\n\n    return dstate_dt  # this should be a sequence of the same length as `state`\nRemember: solve_ivp() requires the time argument even if it is not used.\nBy the way, remember to keep the phases \\(\\theta_i\\) within the range \\([0, 2\\pi]\\) to avoid numerical issues. You can use np.mod(theta, 2 * np.pi) to achieve this.\n\n\n\n\n\n\nSee the full ODE function (click to expand)\n\n\n\n\n\nThe function below is for the mean-field approximation of the Kuramoto model, which is more efficient than computing pairwise interactions. It computes the order parameter at each time step and uses it to calculate the derivatives.\ndef kuramoto_ode(t, theta, omega, coupling_strength=1.0):\n    # Make sure theta stays within [0, 2*pi] to avoid numerical issues\n    theta = np.mod(theta, 2 * np.pi)\n    order_param = np.mean(np.exp(1j * theta))\n    r = np.abs(order_param)\n    phi = np.angle(order_param)\n    dtheta_dt = omega + coupling_strength * r * np.sin(phi - theta)\n    return dtheta_dt\n\n\n\nTo validate that your function works, try running it with the following parameters:\n\nCoupling strength \\(K=10.0\\) (this is a strong coupling regime where synchronization should occur)\nNumber of oscillators \\(N=100\\)\nStandard deviation of natural frequencies \\(\\sigma=1.0\\)\n\nRun the simulation for \\(t \\in [0, 10]\\) and visualize the last state on the unit circle. You should see some degree of synchronization, with the oscillators clustering together. See Figure 2 for a sample output.\n\n\n\n\n\n\n\n\nFigure 2: Visualization of oscillators after running the Kuramoto ODE for K=10. The clustering of the blue dots indicates synchronization.\n\n\n\n\n\n\n\n\n\n\n\nHow to run the simulation (click to expand)\n\n\n\n\n\nYou can use scipy.integrate.solve_ivp() to run the simulation. Here’s a simple example of how to do this:\nfrom scipy.integrate import solve_ivp\n\n# Parameters\ncoupling_strength = 10.0\nnum_oscillators = 100\nsigma = 1.0\nt_span = (0, 10)\n\n# Initialize oscillators\ntheta, omega = initialize_oscillators(num_oscillators, sigma=sigma)\n# Run the simulation\nsol = solve_ivp(\n    kuramoto_ode,\n    t_span,\n    theta,\n    args=(omega, coupling_strength)\n    )\n# The solution `sol.y` contains the phases of the oscillators at each time step.\n# sol.y is a 2D array of shape (num_oscillators, num_time_points)\n# You can visualize the last state using the same plotting code as before.\ntheta_end = sol.y[:, -1] # Get the final state of the phases\nx = np.cos(theta_end)\ny = np.sin(theta_end)\n# Plotting code as before to visualize the final state\n\n\n\nThen, try reducing the coupling strength to \\(K=0.1\\) and observe how the oscillators become more scattered, indicating a more incoherent state. See Figure 3 for a sample output.\n\n\n\n\n\n\n\n\nFigure 3: Visualization of oscillators after running the Kuramoto ODE for K=0.1. The scattering of the blue dots indicates incoherence.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#animate-the-phases",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#animate-the-phases",
    "title": "Kuramoto Model",
    "section": "Animate the Phases",
    "text": "Animate the Phases\nSeeing the final state of the system is nice and that, but you know what is even better? Seeing it in action! You can use matplotlib.animation to create an animation of the oscillators moving around the unit circle as they evolve according to the Kuramoto ODE. This will allow you to visualize the process of synchronization in real time.\nTo create an animation, make sure you are working on a Python script in your local computer (e.g., kuramoto.py) and run it with python kuramoto.py. It is possible to do animations on Jupyter notebooks, but it is more complicated and may not work in all environments.\nReady? Firt, your script should initialize the oscillators and all parameters that you want to control (e.g., coupling strength, number of oscillators, etc.).\n# Remember to include / import the following functions\n# that you have created earlier:\n# initialize_oscillators()\n# kuramoto_ode()\n\ncoupling_strength = 1.0  # K\nnum_oscillators = 100  # Number of oscillators\nomega = 0.5  # Standard deviation of the natural frequencies\nsigma = 1.0  # Scale of the initial phases\ndt = 0.1  # Time step for the integration time\n\n# Initialize oscillators (phase and natural frequency)\ntheta, omega = initialize_oscillators(\n    num_oscillators,\n    sigma=sigma\n)\nt_span = (0, dt)\n# For the animation, we use a small time span\n# But you can go higher for the static imagine\n# t_span = (0, 100)\nSecond, we need to create a figure and axes. Every element inside this plot should be named, so that we can update it in real time. Follow this template:\n# Initialize the figure and axes\nfig, ax_phase = plt.subplots(figsize=(6, 6))\n\n# Define the labels and size of this plot\nax_phase.set_title(\"Kuramoto Model\")\nax_phase.set_xlabel(\"Cos(theta)\")\nax_phase.set_ylabel(\"Sin(theta)\")\nax_phase.set_xlim(-1.1, 1.1)\nax_phase.set_ylim(-1.1, 1.1)\nax_phase.set_aspect(\"equal\")\nax_phase.grid(True)\n\n# Draw unit circle (optional, but it helps to visualize the boundary)\ncircle = plt.Circle((0, 0), 1, color=\"lightgray\", fill=False)\nax_phase.add_artist(circle)\n\n# Initialize scatter plot for oscillators\nscatter = ax_phase.scatter([], [], s=50, color=\"blue\", alpha=0.25)\n# [] means we are starting with an empty array of points,\n# which we will update in the animation loop\n# s is the size of the dots, and alpha is the transparency\n\n# Initialize line for the phase centroid (order parameter)\n(centroid_line,) = ax_phase.plot([], [], color=\"red\", linewidth=2)\n(centroid_point,) = ax_phase.plot([], [], \"ro\", markersize=8)\n# Same idea here:\n# we start with empty data and update it in the animation loop\nAll the block above will initialize the figure and axes, draw the unit circle, and create empty plot elements for the oscillators and the order parameter. The variables scatter, centroid_line, and centroid_point are references to these plot elements, which we will update in the animation loop.\nNext, we need to define an update function that will be called at each time step of the animation. This function will compute the new positions of the oscillators and the order parameter based on the current state of the system. It should look something like this:\ndef update_function(frame: int):\n    # Acces the variables from the outer scope\n    global theta\n\n    # Solve the ODE system\n    sol = solve_ivp(\n            kuramoto_ode,\n            (0, dt),\n            theta,\n            args=(omega, coupling_strength),\n    )\n    # Update theta with the new values from the solution\n    theta = sol.y[..., -1]\n    \n    # Keep theta within [0, 2 * pi]\n    theta = np.mod(theta, 2 * np.pi)\n\n    # Update scatter plot on the unit circle\n    x = np.cos(theta)\n    y = np.sin(theta)\n    data = np.vstack((x, y)).T\n    scatter.set_offsets(data)\n    return [scatter]\nFinally, we can create the animation using matplotlib.animation.FuncAnimation:\nfrom matplotlib.animation import FuncAnimation\n\nani = FuncAnimation(\n    fig,  # Our figure object\n    update_function,  # Updates the plot at each frame\n    frames=200, # Number of frames in the animation\n    interval=100, # Time between frames in milliseconds\n    blit=True, # Optimize rendering by only updating changed elements\n    )\nplt.show()\nAll done! You should see an animation of the oscillators moving around the unit circle. You can experiment with different parameters (e.g., coupling strength, number of oscillators, etc.) to see how it affects the synchronization process.\n\n\n\n\n\n\nFigure 4: Kuramoto oscillators animation on the unit circle.\n\n\n\nIs your order parameter not moving? If you followed the guide, you might notice that the order parameter does not update in the animation. You will need to compute the order parameter inside the update_function() and update the centroid_line and centroid_point accordingly.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#compare-the-odes",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#compare-the-odes",
    "title": "Kuramoto Model",
    "section": "Compare the ODEs",
    "text": "Compare the ODEs\nIf you have reached this far, congratulations! You have successfully implemented the Kuramoto model and visualized its dynamics. Now, you can compare the original pairwise form of the ODE with the mean field approximation. Try implementing both versions and see how they differ in terms of computational efficiency and the resulting dynamics. You should find that the mean field approximation is much faster for large populations, while still capturing the essential behavior of synchronization.\n\n\n\n\n\n\nHow do I implement the other ODE?\n\n\n\n\n\nYou just have to create a new kuramoto_ode() function. I recommend you name them differently, for instance kuramoto_ode_pairwise() and kuramoto_ode_meanfield(), so that you can easily switch between them in the animation loop. Follow the equations in the theory page Kuramoto Model.\nIf you have reached this far by implementing one of them, it should be as simple as changing the ODE function in the solve_ivp() call inside the update_function(). For example, if you have implemented the pairwise version, you can switch to the mean field version by changing this line:\nsol = solve_ivp(\n    kuramoto_ode_pairwise, # Change this to the other ODE function\n    (0, dt),\n    theta,\n    args=(omega, coupling_strength),\n    )\nThis is why modularity is important! By keeping your code organized and modular, you can easily swap out different components (like the ODE function) without having to rewrite the entire animation code. This allows you to experiment with different models and see how they compare in terms of dynamics and computational efficiency.\nIn fact, doing modularization well will save you half the work for the assignment where you will implement a different model of coupled oscillators (the bridge of the Millenium).",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-oscillators.html#whats-next",
    "href": "modules/ode-coupled/kuramoto-oscillators.html#whats-next",
    "title": "Kuramoto Model",
    "section": "What’s Next?",
    "text": "What’s Next?\nIn the next page, we will explore the bifurcation diagram of the Kuramoto model, which shows how the order parameter changes as a function of the coupling strength. This will help us understand the transition from incoherence to synchronization in this system.\nBifurcation Diagram",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Oscillators"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html",
    "href": "modules/ode-coupled/kuramoto.html",
    "title": "Kuramoto Model",
    "section": "",
    "text": "The Kuramoto model describes a population of weakly coupled oscillators. Each oscillator has a phase \\(\\theta_i\\) and a natural frequency \\(\\omega_i\\).\nThe natural frequency of each oscillator (\\(\\omega_i\\)) is drawn from a normal distribution centered at zero, and with standard deviation (scale parameter) \\(\\sigma\\). The density function of this normal distribution is:\n\\[\ng(\\omega) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{\\omega^2}{2\\sigma^2}\\right).\n\\tag{1}\\]\nThe initial phase of each oscillator (\\(\\theta_i\\)) is drawn from an uniform distribution between \\(0\\) and \\(2\\pi\\).\nFor any system of weakly coupled, nearly identical limit-cycle oscillators, the long-term dynamics are given by phase equations of the following universal form:\n\\[\n\\dot\\theta_i = \\omega_i + \\sum_{j=1}^N \\Gamma_{ij} \\left( \\theta_j - \\theta_i \\right),\\quad i = 1, \\dots, N\n\\tag{2}\\]\nWhere \\(\\Gamma_{ij}(\\theta)\\) is the coupling function that describes how oscillator \\(j\\) influences oscillator \\(i\\) as a function of their phase difference. \\(N\\) is the total number of oscillators in the population.\nThe Kuramoto model corresponds to the simplest possible case of equally weighted, all-to-all, purely sinusoidal coupling:\n\\[\n\\Gamma_{ij}(\\theta) = \\frac{K}{N} \\sin \\left( \\theta_j - \\theta_i \\right) \\tag{3}\\]\nWhere \\(K\\) is the coupling strength. The factor of \\(1/N\\) ensures that the total input to each oscillator remains finite as \\(N\\) increases. The Kuramoto model is a paradigmatic example of how collective synchronization can emerge from simple interactions among heterogeneous oscillators. It has been widely studied in physics, biology, and engineering to understand phenomena such as circadian rhythms, neuronal synchronization, and power grid stability.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html#the-order-parameter",
    "href": "modules/ode-coupled/kuramoto.html#the-order-parameter",
    "title": "Kuramoto Model",
    "section": "The Order Parameter",
    "text": "The Order Parameter\nTo visualize the dynamics of the phases, it is convenient to imagine a swarm of points running around the unit circle in the complex plane.\n\n\n\n\n\n\n\n\nFigure 1: Oscillators (blue dots) on the unit circle. The order parameter (red) points towards the centroid of the phases.\n\n\n\n\n\nThe complex order parameter is a macroscopic quantity that can be interpreted as the collective rhythm produced by the whole population.\n\\[\nr e^{i\\Psi} = \\frac{1}{N} \\sum_{j=1}^N e^{i\\theta_j}\n\\tag{4}\\]\n\\(r\\) is the coherence of the population, which measures how synchronized the oscillators are. It ranges from \\(0\\) (completely incoherent) to \\(1\\) (fully synchronized). \\(\\Psi\\) is the mean phase, which represents the average phase of the population.\nFigure 1 shows a snapshot of the oscillators (blue dots) and the order parameter (red arrow) pointing towards the centroid of the phases. If you want to see this in action, run the script in amlab/odes_coupled/kuramoto.py to animate the oscillators on the unit circle.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html#mean-field-approximation",
    "href": "modules/ode-coupled/kuramoto.html#mean-field-approximation",
    "title": "Kuramoto Model",
    "section": "Mean Field Approximation",
    "text": "Mean Field Approximation\nKuramoto noticed that the governing equation can be rewritten neatly in terms of the order parameter:\n\\[\n\\dot\\theta_i = \\omega_i + K r \\sin(\\Psi - \\theta_i),\\quad i = 1, \\dots, N  \\tag{5}\\]\nThis equation has a simple interpretation: each oscillator is pulled toward the mean phase \\(\\Psi\\) with an effective coupling strength \\(K r\\) that depends on the coherence of the population. This is known as the mean field approximation. It is exact in the limit of infinite \\(N\\) and provides a powerful framework to analyze the dynamics of the system.\nYou can use this form of the equation to implement the ODE function for the Kuramoto model, which is often more efficient than computing pairwise interactions. The order parameter can be computed at each time step using the current phases of the oscillators.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html#spontaneous-synchronization",
    "href": "modules/ode-coupled/kuramoto.html#spontaneous-synchronization",
    "title": "Kuramoto Model",
    "section": "Spontaneous Synchronization",
    "text": "Spontaneous Synchronization\nThe mean field approximation reveals a positive feedback loop that can lead to spontaneous synchronization:\n\nThe phase \\(\\theta_i\\) is pulled toward the mean phase \\(\\Psi\\).\nThe population becomes more coherent. In turn, the order parameter \\(r\\) increases.\nThe effective strength of the coupling \\(K r\\) increases proportionally to the coherence.\n\\(K r\\) tends to recruit even more oscillators into the synchronized cluster, which feeds step 1.\n\nIn other words, the more oscillators are synchronized, the stronger the coupling becomes, which in turn promotes even more synchronization. This positive feedback can lead to a phase transition from incoherence to coherence as the coupling strength \\(K\\) crosses a critical threshold. The critical coupling strength \\(K_c\\) can be derived analytically for certain frequency distributions (e.g. Cauchy) and can be estimated numerically for others (e.g. normal).\n\n\n\n\n\n\n\n\nFigure 2: Bifurcation diagram of the Kuramoto model. The order parameter \\(r_\\infty\\) (steady-state coherence) is plotted as a function of the coupling strength \\(K\\). A phase transition occurs at a critical coupling strength \\(K_c\\), where \\(r_\\infty\\) transitions from near zero (incoherence) to a positive value (synchronization).",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html#goal-of-this-session",
    "href": "modules/ode-coupled/kuramoto.html#goal-of-this-session",
    "title": "Kuramoto Model",
    "section": "Goal of this Session",
    "text": "Goal of this Session\nImplement the Kuramoto model in Python, visualize the oscillators on a unit circle and find when the spontaneous synchronization happens.\nPlay with the following parameters and see how they affect the dynamics:\n\nCoupling strength, \\(K &gt; 0\\)\nNumber of oscillators, \\(N\\)\n\nYou can follow two approaches to the ODE function.\n\nPairwise Interactions\nFollow equations Equation 2 and Equation 3 to compute the pairwise interactions between oscillators. This is straightforward but can be computationally expensive for large \\(N\\).\n\\[\n\\dot\\theta_i = \\omega_i + \\sum_{j=1}^N \\Gamma_{ij} \\left( \\theta_j - \\theta_i \\right),\\quad i = 1, \\dots, N\n\\tag{6}\\]\n\\[\n\\Gamma_{ij}(\\theta) = \\frac{K}{N} \\sin \\left( \\theta_j - \\theta_i \\right) \\tag{7}\\]\n\n\nMean Field Approximation\nFollow equation Equation 5 and Equation 4 to compute the dynamics using the order parameter. This is more efficient and provides insight into the collective behavior of the system.\n\\[\n\\dot\\theta_i = \\omega_i + K r \\sin(\\Psi - \\theta_i),\\quad i = 1, \\dots, N  \\tag{8}\\]\n\\[\nr e^{i\\Psi} = \\frac{1}{N} \\sum_{j=1}^N e^{i\\theta_j}\n\\tag{9}\\]\n\nWe will start by initializing the oscillators and plotting them on the unit circle. Then, we will define the ODE function and use scipy.integrate.solve_ivp() to simulate the dynamics. Follow to the next page for the implementation details.\nOscillators and Animation",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto.html#reference",
    "href": "modules/ode-coupled/kuramoto.html#reference",
    "title": "Kuramoto Model",
    "section": "Reference",
    "text": "Reference\nFrom Kuramoto to Crawford: exploring the onset of synchronization in populations of coupled oscillators by Steven H. Strogatz.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto Model"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#program",
    "href": "syllabus.html#program",
    "title": "Applied Math Lab",
    "section": "",
    "text": "This course has 10 live in-person sessions.\n\n\nSimulate classical one-dimensional ODE models (SIR epidemiological model, spruce budworm population model, Michaelis–Menten enzyme kinetics). Solve ODEs numerically with SciPy in Python, and build/deploy a simple Streamlit web app to explore parameter effects. Groups are assigned and remain for the whole course.\n\n\n\nExplore two-dimensional ODEs via nonlinear oscillatory systems: Van der Pol oscillator and FitzHugh–Nagumo model. Create animations with matplotlib and build interactive Python programs that let users set initial conditions via mouse clicks.\n\n\n\nImplement coupled ODEs, focusing on the Kuramoto model. Animate multiple plots simultaneously (e.g., oscillator evolution and a bifurcation diagram).\n\n\n\nSimulate flocking behavior using the Vicsek model. Implement interaction rules for “boids” and extend the simulation by treating the mouse as a predator and coding avoidance behavior.\n\n\n\nIntroduce partial differential equations through reaction–diffusion models (Gierer–Meinhardt and Gray–Scott). Implement 1D and 2D Laplacians with NumPy and animate spatiotemporal evolution to study Turing instability and pattern formation.\n\n\n\nIntroduce NetworkX: build graphs, compute structural metrics (degree distribution, clustering coefficient, centrality), and visualize different network types. Establish foundations for modeling dynamics on networks.\n\n\n\nSimulate spreading processes (fake news, epidemics) on real-world networks. Retrieve and process open-source network datasets, and investigate how network structure shapes propagation dynamics.\n\n\n\nIntroduce one-dimensional cellular automata as a framework for discrete dynamical systems. Explore deterministic and stochastic CA, and how simple local rules generate complex global behavior.\n\n\n\nApply cellular automata to traffic modeling with the Nagel–Schreckenberg model. Study congestion, flow, and phase transitions by tuning parameters such as vehicle density and maximum speed.\n\n\n\nWrap-up and support session for the final project: address remaining questions, clarify concepts, and help groups prepare deliverables.",
    "crumbs": [
      "Getting Started",
      "Syllabus"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Math Modeling (Python)",
    "section": "",
    "text": "Welcome! This site collects the notes, code, and datasets for the Applied Math Lab.",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#course-at-a-glance",
    "href": "index.html#course-at-a-glance",
    "title": "Applied Math Modeling (Python)",
    "section": "Course at a glance",
    "text": "Course at a glance\n\nFormat: 10 live in-person sessions\nTools: Python, NumPy, SciPy, matplotlib, Streamlit, NetworkX\nMain goal: learn modeling by building simulations you can explore and explain",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#how-this-reposite-is-organized",
    "href": "index.html#how-this-reposite-is-organized",
    "title": "Applied Math Modeling (Python)",
    "section": "How this repo/site is organized",
    "text": "How this repo/site is organized\n\nModules (theory + guided notebooks/notes): modules/\nSession code (classroom scripts and demos): amlab/\nStreamlit app (interactive demos): streamlit/\nDatasets used in network sessions: data/",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#what-you-will-build",
    "href": "index.html#what-you-will-build",
    "title": "Applied Math Modeling (Python)",
    "section": "What you will build",
    "text": "What you will build\nAcross the course you will implement and experiment with:\n\nODE models (SIR, spruce budworm, Michaelis–Menten)\nNonlinear oscillators (Van der Pol, FitzHugh–Nagumo)\nReaction–diffusion PDEs (finite differences + animations)\nCollective motion (Vicsek collective motion + interaction)\nNetworks (metrics, spreading processes, real datasets)\nCellular automata (1D rules + traffic models)",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#getting-started-locally",
    "href": "index.html#getting-started-locally",
    "title": "Applied Math Modeling (Python)",
    "section": "Getting started locally",
    "text": "Getting started locally\n\nCreate an environment\nIf you use Conda:\nconda create --name amlab python=3.13\nconda activate amlab\nconda install --yes --file requirements.txt\nIf you prefer pip:\nWindows (PowerShell):\npython -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\npip install -r requirements.txt\nmacOS/Linux:\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\n\n\nRun the Streamlit app\nstreamlit run ./streamlit/home.py",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "index.html#where-to-go-next",
    "href": "index.html#where-to-go-next",
    "title": "Applied Math Modeling (Python)",
    "section": "Where to go next",
    "text": "Where to go next\n\nStart with Session 1: ODEs in 1D\nReview the full schedule in the Syllabus",
    "crumbs": [
      "Getting Started",
      "Home"
    ]
  },
  {
    "objectID": "modules/ode-coupled/assignment.html",
    "href": "modules/ode-coupled/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "This is a joint assignment with the main course Mathematical Modelling. Follow the official handout posted on the main course Blackboard: Kuramoto_assignment.pdf.\nYour main goal is to simulate the Millennium Bridge crowd–bridge synchrony model from the handout. Conceptually, it is Kuramoto-like: pedestrians are phase oscillators, and their coupling is mediated by the bridge motion (Strogatz et al. (2005); Eckhardt et al. (2007)).\nUpload your submission to the Mathematical Modelling course (it counts towards both courses). This time, assignments are individual.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-coupled/assignment.html#summary-of-goals",
    "href": "modules/ode-coupled/assignment.html#summary-of-goals",
    "title": "Assignment",
    "section": "Summary of Goals",
    "text": "Summary of Goals\nBelow is a brief summary of the goals; use the handout for full details and instructions.\n\nKuramoto Model (Coupled Oscillators)\nStart with the basic all-to-all Kuramoto ODE (Kuramoto (2003); Strogatz (2000)) \\[\\dot\\theta_i = \\omega_i + \\frac{K}{N}\\sum_{j=1}^N \\sin(\\theta_j-\\theta_i),\\qquad i=1,\\dots,N. \\tag{1}\\]\nFrom this, you can implement the following tasks:\n\nPlot \\(r(t)\\) (order parameter) versus time. \\(r_\\infty\\approx 0\\) for \\(K&lt;K_c\\) (up to fluctuations) and \\(r_\\infty\\in(0,1)\\) for \\(K&gt;K_c\\), with fluctuations typically decreasing like \\(\\mathcal{O}(N^{-1/2})\\).\nAnimate oscillators on the unit circle (optionally plot the centroid \\(r e^{i\\Psi}\\)).\nEstimate \\(K_c\\) numerically by sampling multiple \\(K\\) values and plotting \\(r_\\infty(K)\\) with error bars. We suggest averaging over a tail window to reduce fluctuations.\nCompare with the theory in Strogatz (2000) (implicit curve for \\(r_\\infty(K)\\)) and the special case of the Cauchy distribution.\n\n\n\nMillennium Bridge Crowd Synchrony\nModeling assumptions:\n\nThe bridge is a single lateral vibration mode (damped harmonic oscillator).\nEach pedestrian is a phase oscillator whose lateral forcing is periodic in its stepping phase.\n\nBridge dynamics: \\[M\\,\\ddot X(t)+B\\,\\dot X(t)+KX(t)=\\sum_{i=1}^N G\\sin\\theta_i(t),\\qquad \\Omega=\\sqrt{K/M}. \\tag{2}\\]\nPedestrian phase dynamics (see Strogatz et al. (2005)): \\[\\dot\\theta_i(t)=\\Omega_i + C\\,A(t)\\,\\sin\\big(\\Psi(t)-\\theta_i(t)+\\alpha\\big),\\qquad i=1,\\dots,N. \\tag{3}\\]\nBridge amplitude/phase definitions: \\[X(t)=A(t)\\sin\\Psi(t),\\quad \\dot X(t)=A(t)\\Omega\\cos\\Psi(t), \\tag{4}\\] \\[A(t)=\\sqrt{X(t)^2+\\Big(\\dot X(t)/\\Omega\\Big)^2},\\qquad \\Psi(t)=\\operatorname{atan2}\\!\\Big(X(t),\\dot X(t)/\\Omega\\Big). \\tag{5}\\]\nSynchronization measure: \\[R(t)e^{i\\Phi(t)}=\\frac{1}{N}\\sum_{j=1}^N e^{i\\theta_j(t)}. \\tag{6}\\]\nCritical crowd size (simplest case \\(\\alpha=\\pi/2\\) and symmetric \\(P(\\Omega)\\) about the bridge frequency): \\[N_c=\\frac{2B\\Omega}{\\pi G C\\,P(\\Omega)}. \\tag{7}\\]\nWobbling and synchronization emerge together when \\(N\\) crosses \\(N_c\\) (see also Strogatz et al. (2005)).",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-coupled/assignment.html#required-millennium-bridge-experiment",
    "href": "modules/ode-coupled/assignment.html#required-millennium-bridge-experiment",
    "title": "Assignment",
    "section": "Required (Millennium Bridge experiment)",
    "text": "Required (Millennium Bridge experiment)\nUse scipy.integrate.solve_ivp to run the controlled crowd ramp experiment:\n\nStart with \\(N=N_0\\) pedestrians. Every \\(\\Delta T\\) seconds, increase the crowd by \\(\\Delta N\\) (add new pedestrians with fresh \\(\\theta_i(0)\\) and \\(\\Omega_i\\)) until reaching \\(N_{\\max}\\).\nCompute \\(N_c\\) using the formula in the handout (using your chosen parameters/distribution).\nDefine \\(t_c=\\inf\\{t: N(t)\\ge N_c\\}\\).\nProduce three stacked plots and draw a vertical dashed line at \\(t=t_c\\) labeled “\\(N=N_c\\)”:\n\n\\(N(t)\\) vs \\(t\\) (crowd size staircase)\n\\(A(t)\\) vs \\(t\\) (bridge wobble amplitude)\n\\(R(t)\\) vs \\(t\\) (degree of synchronization)\n\nBriefly describe what happens before/after \\(t_c\\) and whether the observed onset is close to the theoretical prediction.\n\nReference code is available in amlab/odes_coupled/bridge.py. Use it for ideas, but do not copy it.\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/ode-coupled/index.html",
    "href": "modules/ode-coupled/index.html",
    "title": "Coupled ODEs",
    "section": "",
    "text": "In this session we return to ODEs and study coupled oscillators. The main example is the Kuramoto model, where synchronization emerges from weak coupling.",
    "crumbs": [
      "Session 3: Coupled ODEs"
    ]
  },
  {
    "objectID": "modules/ode-coupled/index.html#case-studies",
    "href": "modules/ode-coupled/index.html#case-studies",
    "title": "Coupled ODEs",
    "section": "Case Studies",
    "text": "Case Studies\nWe will focus on the Kuramoto model, which represents a population of oscillators with distributed natural frequencies. You can read the theory in the following page:\nKuramoto Model\nThe following button will guide you through a basic implementation of the model, including visualizations of the oscillators.\nOscillators and Animation\nNext, we will explore the bifurcation diagram of the Kuramoto model, which shows how the order parameter changes as a function of the coupling strength.\nBifurcation Diagram\nFinally, we merge the two graphs together into a full simulation with sliders to control parameters in real time.\nFull Simulation\nAnd once that is ready, we will apply the same ideas to a more complex system: the Millennium Bridge crowd–bridge synchrony model.\nAssignment",
    "crumbs": [
      "Session 3: Coupled ODEs"
    ]
  },
  {
    "objectID": "modules/ode-coupled/index.html#what-do-we-need",
    "href": "modules/ode-coupled/index.html#what-do-we-need",
    "title": "Coupled ODEs",
    "section": "What do we need?",
    "text": "What do we need?\n\nscipy\nWe are back to ODEs. Use scipy.integrate.solve_ivp().\n\n\nmatplotlib.pyplot\nInitialize the figure and axes and draw static elements.\n\n\nmatplotlib.animation\nUpdate plot elements in real time for animations.\n\n\nmatplotlib.Slider\nAdd sliders so users can interact with parameters.",
    "crumbs": [
      "Session 3: Coupled ODEs"
    ]
  },
  {
    "objectID": "modules/ode-coupled/index.html#references",
    "href": "modules/ode-coupled/index.html#references",
    "title": "Coupled ODEs",
    "section": "References",
    "text": "References\n\nFrom Kuramoto to Crawford: exploring the onset of synchronization in populations of coupled oscillators by Steven H. Strogatz.",
    "crumbs": [
      "Session 3: Coupled ODEs"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-full.html",
    "href": "modules/ode-coupled/kuramoto-full.html",
    "title": "Kuramoto Model",
    "section": "",
    "text": "This part is optional and is meant to be a fun extension if you want to build a full simulation with sliders and live plots. It combines the previous two pages into a single interactive experience.\nIf you want to skip this part, you can go directly to the next page, which contains an assignment based on the same ideas.\nAssignment",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Full Simulation"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-full.html#template",
    "href": "modules/ode-coupled/kuramoto-full.html#template",
    "title": "Kuramoto Model",
    "section": "Template",
    "text": "Template\nYou can start from the template in amlab/odes_coupled/kuramoto_full_template.py and fill in the missing parts. The template includes the structure for sliders, animation, and order parameter computation, so you can focus on implementing the Kuramoto model dynamics and visualizations.\nAlternatively, you can build the full simulation from scratch by following the steps outlined in the previous pages and combining them together.",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Full Simulation"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-full.html#order-parameter",
    "href": "modules/ode-coupled/kuramoto-full.html#order-parameter",
    "title": "Kuramoto Model",
    "section": "Order Parameter",
    "text": "Order Parameter\nComplete the function that computes the order parameter:\ndef kuramoto_order_parameter(theta: np.ndarray) -&gt; tuple:\n    # TODO: compute r * exp(i * phi)\n    order_param =  # replace this line\n    r = np.abs(order_param)\n    phi = np.angle(order_param)\n    rcosphi = np.real(order_param)\n    rsinphi = np.imag(order_param)\n    return r, phi, rcosphi, rsinphi\n\n\n\n\n\n\nHint: Order parameter (click to expand)\n\n\n\n\n\ndef kuramoto_order_parameter(theta: np.ndarray) -&gt; tuple:\n    order_param = np.mean(np.exp(1j * theta), axis=0)\n    r = np.abs(order_param)\n    phi = np.angle(order_param)\n    rcosphi = np.real(order_param)\n    rsinphi = np.imag(order_param)\n    return r, phi, rcosphi, rsinphi",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Full Simulation"
    ]
  },
  {
    "objectID": "modules/ode-coupled/kuramoto-full.html#sliders",
    "href": "modules/ode-coupled/kuramoto-full.html#sliders",
    "title": "Kuramoto Model",
    "section": "Sliders",
    "text": "Sliders\nUse sliders to update the coupling strength, number of oscillators, and the distribution scale. The template shows how to restart the animation when values change.\n\n\n\n\n\n\nHint: Slider update (click to expand)\n\n\n\n\n\ndef update_sliders(_):\n    nonlocal coupling_strength, num_oscillators, sigma, theta, omega\n    coupling_strength = slider_coupling.val\n    num_oscillators = int(slider_num_oscillators.val)\n    sigma = slider_sigma.val\n    theta, omega = initialize_oscillators(num_oscillators, sigma=sigma)\n\n\n\nWhen you finish, run the full simulation and explore how synchronization changes as you vary \\(K\\).",
    "crumbs": [
      "Session 3: Coupled ODEs",
      "Kuramoto: Full Simulation"
    ]
  },
  {
    "objectID": "modules/collective-motion/assignment.html",
    "href": "modules/collective-motion/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Simulate the Vicsek model and report your findings.",
    "crumbs": [
      "Session 4: Collective Motion",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/collective-motion/assignment.html#required",
    "href": "modules/collective-motion/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement the Vicsek equations and animate the boids on a box of size 25.\nCompute and plot the order parameter \\(r(t)\\).\nShow how \\(r\\) changes with noise \\(\\eta\\).",
    "crumbs": [
      "Session 4: Collective Motion",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/collective-motion/assignment.html#extra-mile-optional",
    "href": "modules/collective-motion/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nAdd sliders for \\(v_0\\), \\(\\eta\\), \\(r\\), and box size.\nAdd a predator controlled by the mouse.\nImplement a repulsion force between boids.\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 4: Collective Motion",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/collective-motion/index.html",
    "href": "modules/collective-motion/index.html",
    "title": "Collective Motion",
    "section": "",
    "text": "In this session we study collective motion: how local alignment rules create global order. The main example is the Vicsek model, with optional predator interaction.",
    "crumbs": [
      "Session 4: Collective Motion"
    ]
  },
  {
    "objectID": "modules/collective-motion/index.html#case-studies",
    "href": "modules/collective-motion/index.html#case-studies",
    "title": "Collective Motion",
    "section": "Case Studies",
    "text": "Case Studies\nVicsek Model Predator Effect Assignment",
    "crumbs": [
      "Session 4: Collective Motion"
    ]
  },
  {
    "objectID": "modules/collective-motion/index.html#what-do-we-need",
    "href": "modules/collective-motion/index.html#what-do-we-need",
    "title": "Collective Motion",
    "section": "What do we need?",
    "text": "What do we need?\n\nmatplotlib.pyplot\nInitialize the figure and axes and draw static elements.\n\n\nmatplotlib.animation\nUpdate plot elements in real time for animations.\n\n\nmatplotlib.Slider\nAdd sliders so users can interact with parameters.\n\n\nmatplotlib.backend_bases\nTrack mouse position and clicks for interactive behavior.\n\n\nWhy not use scipy.solve_ivp here?\nIn previous sessions, we used ODE solvers like scipy.solve_ivp to study continuous-time dynamical systems. The Vicsek model, however, is fundamentally a discrete-time, agent-based model: at each step, all particles update their direction and position based on their neighbors and some noise. This update is not described by a differential equation, but by a set of rules applied at each time step. Therefore, we implement the Vicsek model using a simple loop, not an ODE solver.",
    "crumbs": [
      "Session 4: Collective Motion"
    ]
  },
  {
    "objectID": "modules/collective-motion/index.html#references",
    "href": "modules/collective-motion/index.html#references",
    "title": "Collective Motion",
    "section": "References",
    "text": "References\n\n(Vicsek et al. 1995)\nCheck this cool simulation. This explorable illustrates of an intuitive dynamic model for collective motion (swarming) in animal groups. The model can be used to describe collective behavior observed in schooling fish or flocking birds, for example. The details of the model are described in (Couzin et al. 2002).",
    "crumbs": [
      "Session 4: Collective Motion"
    ]
  },
  {
    "objectID": "modules/cellular-automata/assignment.html",
    "href": "modules/cellular-automata/assignment.html",
    "title": "Assignment",
    "section": "",
    "text": "Complete a 1D cellular automaton and a traffic model simulation.",
    "crumbs": [
      "Session 8: Cellular Automata",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/cellular-automata/assignment.html#required",
    "href": "modules/cellular-automata/assignment.html#required",
    "title": "Assignment",
    "section": "Required",
    "text": "Required\n\nImplement Rule 30 and plot a space-time diagram.\nModify the initial row (at least 3 different initial conditions).\nImplement the traffic CA and generate a space-time diagram.\nCompare two densities and discuss the patterns.",
    "crumbs": [
      "Session 8: Cellular Automata",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/cellular-automata/assignment.html#extra-mile-optional",
    "href": "modules/cellular-automata/assignment.html#extra-mile-optional",
    "title": "Assignment",
    "section": "Extra Mile (Optional)",
    "text": "Extra Mile (Optional)\n\nImplement another rule (e.g., Rule 110).\nAdd interactivity to the traffic model (sliders for density or \\(p\\)).\n\nGood luck and enjoy your coding!",
    "crumbs": [
      "Session 8: Cellular Automata",
      "Assignment"
    ]
  },
  {
    "objectID": "modules/cellular-automata/cellular-1d.html",
    "href": "modules/cellular-automata/cellular-1d.html",
    "title": "Intro to 1D Cellular Automata",
    "section": "",
    "text": "A 1D cellular automaton updates each cell using its local neighborhood. We will use elementary 3-cell rules, such as Rule 30.\nFigure 1: Rule 30 space-time diagram.",
    "crumbs": [
      "Session 8: Cellular Automata",
      "1D Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/cellular-1d.html#define-the-rule",
    "href": "modules/cellular-automata/cellular-1d.html#define-the-rule",
    "title": "Intro to 1D Cellular Automata",
    "section": "Define the rule",
    "text": "Define the rule\nA rule is an 8-bit binary table that maps each neighborhood to a new cell value.\nrule_number = 30\nrule_bin = np.array([int(x) for x in f\"{rule_number:08b}\"])",
    "crumbs": [
      "Session 8: Cellular Automata",
      "1D Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/cellular-1d.html#apply-the-rule-template",
    "href": "modules/cellular-automata/cellular-1d.html#apply-the-rule-template",
    "title": "Intro to 1D Cellular Automata",
    "section": "Apply the rule (template)",
    "text": "Apply the rule (template)\ndef apply_rule(state, rule_bin):\n    new_state = np.zeros_like(state)\n    for i in range(1, len(state) - 1):\n        neighborhood = state[i - 1 : i + 2]\n        index = 7 - int(\"\".join(neighborhood.astype(str)), 2)\n        new_state[i] = rule_bin[index]\n    return new_state",
    "crumbs": [
      "Session 8: Cellular Automata",
      "1D Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/cellular-1d.html#build-a-space-time-diagram",
    "href": "modules/cellular-automata/cellular-1d.html#build-a-space-time-diagram",
    "title": "Intro to 1D Cellular Automata",
    "section": "Build a space-time diagram",
    "text": "Build a space-time diagram\niterations = 60\ngrid_size = 101\n\ngrid = np.zeros((iterations, grid_size), dtype=int)\ngrid[0, grid_size // 2] = 1\n\nfor t in range(1, iterations):\n    grid[t] = apply_rule(grid[t - 1], rule_bin)\n\nplt.imshow(grid, cmap=\"binary\", interpolation=\"nearest\", aspect=\"auto\")\nplt.show()",
    "crumbs": [
      "Session 8: Cellular Automata",
      "1D Cellular Automata"
    ]
  },
  {
    "objectID": "modules/cellular-automata/cellular-1d.html#interactive-initial-row",
    "href": "modules/cellular-automata/cellular-1d.html#interactive-initial-row",
    "title": "Intro to 1D Cellular Automata",
    "section": "Interactive initial row",
    "text": "Interactive initial row\nThe script amlab/cellular_automata/cellular.py lets you click on the first row to toggle cells and recompute the automaton.",
    "crumbs": [
      "Session 8: Cellular Automata",
      "1D Cellular Automata"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html",
    "href": "modules/ode-2d/index.html",
    "title": "Ordinary Differential Equations in 2D",
    "section": "",
    "text": "In this session we move from 1D dynamics to planar systems \\[\\dot x=f(x,y;\\,\\theta),\\qquad \\dot y=g(x,y;\\,\\theta), \\tag{1}\\] where behavior can depend strongly on both the initial state \\((x_0,y_0)\\) and the parameters \\(\\theta\\).",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#case-studies",
    "href": "modules/ode-2d/index.html#case-studies",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Case Studies",
    "text": "Case Studies\n\nChlorine Dioxide–Iodine–Malonic Acid (CDIMA)\nThe CDIMA reaction is a classical example from chemical kinetics that can display rich nonlinear dynamics. We will use a reduced 2D model to explore how parameter changes can trigger qualitatively different behaviors (e.g., convergence to a steady state vs. sustained oscillations).\nGo to this example\n\n\nVan der Pol oscillator\nThe Van der Pol system is a prototypical self-excited oscillator: it exhibits a stable limit cycle for a wide range of initial conditions. It is a clean testbed for studying how nonlinear damping (controlled by a parameter) changes trajectories and transient dynamics.\nGo to this example\n\n\nFitzHugh–Nagumo\nThe FitzHugh–Nagumo model is a simplified neuron model capturing excitability and spiking. It’s a great example of a fast–slow 2D system, where parameters control whether trajectories relax to rest, fire spikes, or oscillate.\nGo to this example",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#goals",
    "href": "modules/ode-2d/index.html#goals",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Goals",
    "text": "Goals\n\nExplore the evolution of the system depending on its initial state \\((x_0,y_0)\\).\nStudy how solutions depend on equation parameters (bifurcation-style exploration).\nBuild intuition using phase portraits, time series, and (simple) animations.\nConnect the simulations to the theory: oscillations/limit cycles, fast–slow dynamics, and excitability.\nRun the provided scripts and modify initial conditions/parameters to reproduce and explain the behaviors discussed in lecture.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#what-do-we-need",
    "href": "modules/ode-2d/index.html#what-do-we-need",
    "title": "Ordinary Differential Equations in 2D",
    "section": "What do we need?",
    "text": "What do we need?\n\nscipy\nWe’ll use numerical integration to evolve the ODEs forward in time. In particular, we’ll rely on scipy.integrate.solve_ivp() which supports explicit Runge–Kutta methods (and many other solvers). Review session 1 for a refresher on how to use solve_ivp() for 1D ODEs, and we’ll extend that workflow to 2D systems here.\n\n\nsolve_ivp()\nCore workflow:\n\ndefine the right-hand side \\((f,g)\\) as a Python function\nchoose a time span and evaluation grid\nintegrate with an RK method (or a stiff method when needed)\nanalyze \\((x(t),y(t))\\) in time and in phase space\n\n\n\nmatplotlib.animation\nTo animate trajectories we update plot elements frame-by-frame (lines, markers, text), creating the illusion of motion. This is a lightweight way to visualize how trajectories “flow” through the phase plane.\n\n\nmatplotlib.pyplot\nUsed to initialize the figure/axes and draw static plot elements:\n\naxes labels, titles, legends\nnullclines or vector fields (when included)\nstatic phase portrait scaffolding\n\n\n\nmatplotlib.backend_bases\nWe’ll hook into Matplotlib’s event system (e.g. mouse clicks) to let the user interact with the model. For example, clicking in the phase plane can set a new initial condition \\((x_0,y_0)\\) and re-run the integration.\n\n\nstreamlit?\nAt the moment, animations and interactive plots are not implemented yet in Streamlit. For this reason, we will run the code in Python scripts for now.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/index.html#lets-get-started",
    "href": "modules/ode-2d/index.html#lets-get-started",
    "title": "Ordinary Differential Equations in 2D",
    "section": "Let’s Get Started!",
    "text": "Let’s Get Started!\nGo to the assignment page for the details of the coding task, and check out the provided code for each model to get a head start.\nThe CDIMA model is fully explained and implemented, so it’s a great place to start. Then, you can move on to the Van der Pol and FitzHugh–Nagumo models.",
    "crumbs": [
      "Session 2: ODEs in 2D"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html",
    "href": "modules/ode-2d/cdima.html",
    "title": "CDIMA Reaction",
    "section": "",
    "text": "The CDIMA model (Chlorine Dioxide–Iodine–Malonic Acid reaction) is a classic 2D chemical oscillator used to study phase-plane dynamics. The equations are:\n\\[\\begin{aligned}\n\\dot x &= a - x - \\frac{4xy}{1+x^2} \\\\\n\\dot y &= bx \\left( 1 - \\frac{y}{1+x^2} \\right)\n\\end{aligned} \\tag{1}\\]\nwhere \\(x\\) and \\(y\\) are the dimensionless concentrations of I\\(^-\\) and ClO\\(_2^-\\). The parameters \\(a,\\ b &gt; 0\\) depend on the empirical rate constants and on the concentrations assumed for the slow reactants (Strogatz 2024, chap. 8.3).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#phase-plane-analysis",
    "href": "modules/ode-2d/cdima.html#phase-plane-analysis",
    "title": "CDIMA Reaction",
    "section": "Phase-Plane Analysis",
    "text": "Phase-Plane Analysis\nTo understand the dynamics, we can analyze the phase plane. A phase plane is a 2D plot whose axes are the state variables (here, \\(x\\) and \\(y\\)). Each point \\((x,y)\\) represents the system’s state at a given time, and the differential equations define a vector field on this plane that indicates how the state evolves. Trajectories (solution curves) show how \\((x(t),y(t))\\) moves through the plane, revealing features such as equilibrium points, nullclines, limit cycles, and their stability.\n\n\n\n\n\n\n\n\nFigure 1: Phase plane of the CDIMA system with a = 10, b = 4. Trajectories are shown for different initial conditions (IC as x-y, marked black). Generated with scipy.integrate.solve_ivp() and matplotlib.\n\n\n\n\n\nGenerating this phase plane in Python is simple. We will follow the same approach as in 1D: define the right-hand side as a function, choose a time span and evaluation grid, and integrate with scipy.integrate.solve_ivp(). Follow the steps below.\n\nDefine the ODE Function\nFirst, define the cdima() function. Remeber that any ODE (in any dimension), can be written as:\ndef ode(t, state, *params):\n    # state represents the current values of the variables (e.g., x, y)\n\n    # params are any additional parameters needed to compute the derivatives\n    # each of them is separated by commas\n\n    return dstate_dt  # this should be a sequence of the same length as `state`\nCan you write the cdima() function in this format? If you need an extra hint, uncollapse the code block below.\n\n\n\n\n\n\nHint: CDIMA right-hand side (click to expand)\n\n\n\n\n\ndef cdima(t: float, state: tuple[float, float], a: int, b: int) -&gt; tuple[float, float]:\n    \"\"\"Remember the docstring and type hints!\"\"\"\n    x, y = state  # unpack the state variables\n    dxdt =  # compute dx/dt\n    dydt = # compute dy/dt\n    return (dxdt, dydt)  # return the derivatives as a list\n\n\n\n\n\nSolve the Initial Value Problem\nNext, we need to solve the initial value problem (IVP) for a given initial condition and parameters. The workflow is similar to 1D, but now we have a vector of state variables instead of a single variable. The solve_ivp() function will return the trajectories for both \\(x(t)\\) and \\(y(t)\\), which we can then plot in the phase plane.\nUsing scipy.integrate.solve_ivp() and your previously defined cdima() function, can you write the code to solve the IVP for a specific initial condition and parameters? The output should be the trajectories of \\(x(t)\\) and \\(y(t)\\), i.e. two arrays of the same length.\nIf you need a hint, uncollapse the code block below.\n\n\n\n\n\n\nHint: Solving the IVP (click to expand)\n\n\n\n\n\nfrom scipy.integrate import solve_ivp\nimport numpy as np\n\n# Define parameters\na, b = 10, 4\n# Define initial condition\nx0, y0 = 0, 3 \n# Define time span and evaluation points\nt_span = (0, 20) # Start at t=0 and end at t=20\nt_eval = np.linspace(t_span[0], t_span[1], 2000)  # Return 2000 points between t=0 and t=20\n# Solve the IVP\nsol = solve_ivp(cdima, t_span, [x0, y0], args=(a, b), t_eval=t_eval)\n# sol.y[0] will give you x(t) and sol.y[1] will give you y(t)\n\n\n\nDo you have it? Great! Try the following initial conditions: \\(a=10\\), \\(b=4\\), and \\((x_0,y_0) = (0,3)\\). You can see this trajectory in Figure 1. What will be the state of the system at \\(t=5\\)?\n\n\n\n\n\n\nSolution: State at t=20 (click to expand)\n\n\n\n\n\n\nfrom scipy.integrate import solve_ivp\nimport numpy as np\n\nfrom amlab.odes_2d.cdima import cdima\n\na, b = 10, 4\nx0, y0 = 0, 3\n\nt_span = (0, 5)\nt_eval = np.linspace(t_span[0], t_span[1], 500)\nsol = solve_ivp(cdima, t_span, [x0, y0], args=(a, b), t_eval=t_eval)\nfinal_state = sol.y[:, -1]  # Get the last column of sol.y, which corresponds to the state at t=5\nprint(f\"State at t=5: x={final_state[0]:.2f}, y={final_state[1]:.2f}\")\n\nState at t=5: x=2.08, y=4.13\n\n\n\n\n\n\n\nPlotting the Phase Plane\nFinally, we can plot the trajectories in the phase plane using matplotlib.pyplot. Try to reproduce the plot in Figure 1 by plotting \\(y(t)\\) vs. \\(x(t)\\) for different initial conditions. You can also mark the initial conditions on the plot to see where the trajectories start.\n\n\n\n\n\n\nHint: Plotting the Phase Plane (click to expand)\n\n\n\n\n\nimport matplotlib.pyplot as plt \n\nfig, ax = plt.subplots(figsize=(8, 4))\nfor x0, y0 in [(0, 3), (0, 1.5), (2, 0)]:\n    sol = solve_ivp(cdima, [0, 20], [x0, y0], args=(a, b), t_eval=np.linspace(0, 20, 2000))\n    ax.plot(sol.y[0], sol.y[1], label=f\"IC: ({x0}, {y0})\")  # Plot y vs. x\n    ax.plot(x0, y0, 'o', color='black')  # Mark the initial condition\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.show()",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#nullclines-in-the-phase-plane",
    "href": "modules/ode-2d/cdima.html#nullclines-in-the-phase-plane",
    "title": "CDIMA Reaction",
    "section": "Nullclines in the Phase Plane",
    "text": "Nullclines in the Phase Plane\nIn addition to trajectories, we can also plot nullclines in the phase plane. Nullclines are curves where the derivative of one of the variables is zero. They help us identify equilibrium points and understand the flow of trajectories.\n\n\n\n\n\n\n\n\nFigure 2: Nullclines of the CDIMA system with a = 10, b = 4. The x-nullcline (dx/dt=0) is shown in blue, and the y-nullcline (dy/dt=0) is shown in red. Generated with matplotlib.pyplot.\n\n\n\n\n\nHow can we find the nullclines for the CDIMA system? We have two options:\n\nAnalytical approach: Set \\(\\dot x = 0\\) and \\(\\dot y = 0\\) and solve the resulting equations for \\(y\\) as a function of \\(x\\) (or vice versa). This can be done by hand or using symbolic computation tools like SymPy.\nNumerical approach: Evaluate the derivatives on a grid of \\((x,y)\\) values and identify where they change sign (i.e., where they cross zero). This can be done using numerical methods and is often more practical for complex systems. Figure 2 shows the nullclines computed using a numerical approach.\n\nPick one of these methods to compute the nullclines for the CDIMA system, and then plot them in the phase plane. The intersection points of the nullclines correspond to equilibrium points of the system.\n\n\n\n\n\n\nHint: Computing Nullclines (click to expand)\n\n\n\n\n\n# Define the limits for the grid\nx_min, x_max = 0.1, 5\ny_min, y_max = 0, 10\nnum_points = 1000  # Number of points in the grid\n\n# Create a grid of points\nx_values = np.linspace(x_min, x_max, num_points)\ny_values = np.linspace(y_min, y_max, num_points)\nx_grid, y_grid = np.meshgrid(x_values, y_values)\n# meshgrid creates two 2D arrays:\n# x_grid and y_grid, where each element (i,j) corresponds to the\n# coordinates (x_values[i], y_values[j]) in the phase plane.\n\n# Evaluate the derivatives at each point\ndx_dt: np.ndarray\ndy_dt: np.ndarray\ndx_dt, dy_dt = cdima(0, [x_grid, y_grid], a, b)\n\n# Extract nullcline data:\n# Find where dx_dt changes sign (zero crossings)\ndxdt_zero_crossings = np.where(np.diff(np.sign(dx_dt), axis=0))\ndxdt_nullcline_x = x_grid[dxdt_zero_crossings]\ndxdt_nullcline_y = y_grid[dxdt_zero_crossings]\n\n# Extract nullcline data - Find where dy_dt changes sign (zero crossings)\ndydt_zero_crossings = np.where(np.diff(np.sign(dy_dt), axis=1))\ndydt_nullcline_x = x_grid[dydt_zero_crossings]\ndydt_nullcline_y = y_grid[dydt_zero_crossings]\nNow you can plot the nullclines using matplotlib Recommendation: do not join the points! There is no guarantee that the sequence of points in dxdt_nullcline_x and dxdt_nullcline_y (or dydt_nullcline_x and dydt_nullcline_y) will form a continuous curve, so it’s better to plot them as individual points (e.g., using 'o' markers) rather than trying to connect them with lines.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#equilibrium-points-on-the-phase-plane",
    "href": "modules/ode-2d/cdima.html#equilibrium-points-on-the-phase-plane",
    "title": "CDIMA Reaction",
    "section": "Equilibrium Points on the Phase Plane",
    "text": "Equilibrium Points on the Phase Plane\nThe intersection points of the nullclines correspond to equilibrium points (equilibria) of the system. In other words, they are points where both \\(\\dot x = 0\\) and \\(\\dot y = 0\\) simultaneously.\nTo find the equilibrium points, we can look for the coordinates where the x-nullcline and y-nullcline intersect. This can be done by checking for points that are close to each other in both nullcline datasets or by using a more systematic approach (e.g., clustering or root-finding methods).\nIn Python, we can use the scipy.optimize.fsolve() function to find the roots of the system of equations defined by the nullclines. This will give us the coordinates of the equilibrium points.\nfrom scipy.optimize import fsolve\n\na, b = 10, 4\n\n# We need to define a function that represents the system of\n# equations for the nullclines\ndef cdima_fixed(xy: np.ndarray) -&gt; np.ndarray:\n    return cdima(None, xy, a, b)\n\nequilibrium_point = fsolve(cdima_fixed, [1, 1])  # Initial guess for the equilibrium point\nprint(f\"Equilibrium point: x={equilibrium_point[0]:.2f}, y={equilibrium_point[1]:.2f}\")\nIf we have done things well, plotting the equilibrium point on the phase plane should show that it lies at the intersection of the nullclines.\n\n\n\n\n\n\n\n\nFigure 3: Equilibrium point of the CDIMA system with a = 10, b = 4. The equilibrium point is marked with a black dot at the intersection of the nullclines. Generated with scipy.optimize.fsolve() and matplotlib.pyplot.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#stability-of-the-equilibrium-point",
    "href": "modules/ode-2d/cdima.html#stability-of-the-equilibrium-point",
    "title": "CDIMA Reaction",
    "section": "Stability of the Equilibrium Point",
    "text": "Stability of the Equilibrium Point\nAs you know from 1D systems, a equilibrium point can be stable or unstable. A stable equilibrium point attracts nearby trajectories, while an unstable equilibrium point repels them. In 2D systems, we can determine the stability of an equilibrium point by analyzing the Jacobian matrix of the system at that point. The Jacobian matrix is a 2x2 matrix that contains the partial derivatives of the right-hand side of the ODEs with respect to the state variables.\n\\[J =\n\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x} & \\frac{\\partial f}{\\partial y} \\\\\n\\frac{\\partial g}{\\partial x} & \\frac{\\partial g}{\\partial y}\n\\end{bmatrix} \\tag{2}\\]\nWhere \\(f\\) and \\(g\\) are the right-hand sides of the ODEs for \\(\\dot x\\) and \\(\\dot y\\), respectively. The eigenvalues of the Jacobian determine the stability of the equilibrium point:\n\nIf both eigenvalues have negative real parts, the equilibrium point is stable (attracting).\nIf at least one eigenvalue has a positive real part, the equilibrium point is unstable (repelling).\n\nSo all we need to do is compute the equilibrium point \\((x^*, y^*)\\), evaluate the Jacobian at that point, and compute its eigenvalues to determine stability.\nAs the CDIMA model has two parameters, we can explore how the stability of the equilibrium point changes as we vary \\(a\\) and \\(b\\). This leads to a stability diagram in the parameter space, which can be very insightful for understanding the system’s behavior.\nFor the CDIMA model, we can prove that the boundary between stable and unstable regimes is given by the curve \\(b = \\frac{3}{5} a - \\frac{25}{a}\\) in the \\((a,b)\\) parameter space (Strogatz 2024, chap. 8.3). Now go to your CDIMA simulation and explore how the trajectories change as you cross this boundary by varying \\(a\\) and \\(b\\).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#closing-remarks",
    "href": "modules/ode-2d/cdima.html#closing-remarks",
    "title": "CDIMA Reaction",
    "section": "Closing Remarks",
    "text": "Closing Remarks\nHave you done all the steps above? Great! You should now have a good understanding of how to analyze a 2D ODE system using phase-plane methods. You can explore how changing the parameters affects the trajectories, nullclines, and equilibrium points. Try different initial conditions to see how the system’s behavior changes.\nYour next steps:\n\nReproduce the phase plane and nullcline plots for other systems such as the Van der Pol oscillator and the FitzHugh–Nagumo model.\nCreate an interactive animation of the trajectories in the phase plane using matplotlib.animation. You can follow the guide showed here to get started.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/cdima.html#resources",
    "href": "modules/ode-2d/cdima.html#resources",
    "title": "CDIMA Reaction",
    "section": "Resources",
    "text": "Resources\n\n(Strogatz 2024, chap. 8.3) for theoretical background on the CDIMA model and phase-plane analysis.\nSciPy documentation: https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nReference implementation: https://github.com/daniprec/BAM-Applied-Math-Lab/tree/main/amlab/odes_2d",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "CDIMA Reaction"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html",
    "href": "modules/ode-2d/animation.html",
    "title": "Animations and Interactivity",
    "section": "",
    "text": "This page summarizes the core Matplotlib pattern we use to animate trajectories in the phase plane, and how to restart an animation when the user changes parameters or initial conditions.\nIf you struggle with this part, feel free to check a complete example of the CDMI animation here.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#minimal-animation-template",
    "href": "modules/ode-2d/animation.html#minimal-animation-template",
    "title": "Animations and Interactivity",
    "section": "Minimal Animation Template",
    "text": "Minimal Animation Template\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\n\n# ...\n# Your code to compute trajectories, nullclines, fixed point...\n# Example: sol = solve_ivp(...)\n# ...\n\n# Open a new figure (white canvas)\nfig = plt.figure()\nax = plt.gca()  # get current axis\n\n# Initialize the line object for animation on the phase plane\n(plot_trajectory,) = ax.plot([], [], lw=2)\n# This trajectory would be x-y for the\n# phase plane of the CDIMA and Van der Pol models, and v-w for the FitzHugh–Nagumo model\n\n\ndef animate(frame: int, xy: tuple[np.ndarray, np.ndarray]):\n    \"\"\"Update function called once per frame.\"\"\"\n    # unpack the solution (x(t), y(t)) or (v(t), w(t))\n    x, y = xy\n    # update the line data to show the trajectory up to the current frame\n    plot_trajectory.set_data(x[:frame], y[:frame])\n    # return the updated artist (line) for blitting\n    return (plot_trajectory,)\n\n\n# The animation object that will run the animation\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    fargs=(sol.y,),\n    frames=len(sol.t),\n    interval=1,  # delay between frames in milliseconds\n    blit=True,  # redraw only the updated artists for efficiency\n)\n\nWhat Happens in an Animation?\nThe animation function is called once per frame:\n\nframe (or i) is the frame index (0, 1, 2, …).\nxy is the data to plot (here, the solution sol.y returned by solve_ivp).\nthe function must update the artists (lines, points, text, etc.).\nit must return an iterable with the updated artists when blit=True. This tells Matplotlib which parts of the plot to redraw for the next frame, improving performance.\n\n\n\nThe Animation Function in Detail\nTemplate:\ndef animate_function(i: int, *args):\n    # update plot elements\n    return (artist1, artist2, ...)\nIn our case, the second input argument is the solution from solve_ivp. Updating a line is typically done with:\nline.set_data(x, y)\nThis replaces the line coordinates by the new points \\((x,y)\\).\n\n\nCreating the Animation (FuncAnimation)\nimport matplotlib.animation as animation\n\nani = animation.FuncAnimation(\n    fig,\n    function,\n    fargs=(sol.y,),\n    interval=1,\n    blit=True,\n)\nArguments:\n\nfig: the Matplotlib figure to animate\nfunction: the callback that updates plot elements on each frame\nfargs: extra arguments passed to function (everything except the frame index)\ninterval: delay between frames (milliseconds)\nblit: if True, redraws only the updated artists (faster). When using blit=True, your animation function must return the artists that were updated.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#interactivity-restarting-the-animation",
    "href": "modules/ode-2d/animation.html#interactivity-restarting-the-animation",
    "title": "Animations and Interactivity",
    "section": "Interactivity: Restarting the Animation",
    "text": "Interactivity: Restarting the Animation\nWhen the user clicks (new initial condition) or changes a parameter, a common pattern is:\nani.event_source.stop()          # stop the current animation\nani.frame_seq = ani.new_frame_seq()  # reset frame generator\nani._args = (xy, ...)            # replace animation inputs (like new fargs)\nani.event_source.start()         # start again\nThis is the mechanism used in the interactive scripts: recompute solve_ivp(...), update nullclines/fixed point, then restart the animation with the new data.",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/ode-2d/animation.html#mouse-clicks",
    "href": "modules/ode-2d/animation.html#mouse-clicks",
    "title": "Animations and Interactivity",
    "section": "Mouse Clicks",
    "text": "Mouse Clicks\nMatplotlib figures can react to user input via the event system. A common pattern is to capture clicks in a specific axis and use the click position as a new initial condition.\nfrom matplotlib.backend_bases import MouseEvent\n\n\ndef mouse_click(event: MouseEvent):\n    # Check if the mouse click happens in the axis \"ax1\"\n    if event.inaxes == ax1:\n        # Get the position of the mouse click on the axis\n        x0 = event.xdata\n        y0 = event.ydata\n    else:\n        return\n\n    # This part of the code should update the plot.\n    # Use the animation functions we have learnt:\n    # 1) stop the current animation\n    # 2) clear/reset it\n    # 3) recompute the solution (and nullclines/fixed point if needed)\n    # 4) set new animation arguments\n    # 5) start again\n\n\n# Make the figure aware of user clicks.\n# Whenever the user clicks, we run the function \"mouse_click\".\nfig.canvas.mpl_connect(\"button_press_event\", mouse_click)\nYou will need to stop the current animation, clear it, update the parameters/initial conditions, and start over (see the previous section).",
    "crumbs": [
      "Session 2: ODEs in 2D",
      "Animation Template"
    ]
  },
  {
    "objectID": "modules/pde-2d/index.html",
    "href": "modules/pde-2d/index.html",
    "title": "Partial Differential Equations in 2D",
    "section": "",
    "text": "In this session we extend the 1D reaction-diffusion workflow to two spatial dimensions. We will use finite differences, explicit Euler time stepping, and Matplotlib animations to explore pattern formation."
  },
  {
    "objectID": "modules/pde-2d/index.html#case-studies",
    "href": "modules/pde-2d/index.html#case-studies",
    "title": "Partial Differential Equations in 2D",
    "section": "Case Studies",
    "text": "Case Studies\nGierer-Meinhardt 2D Turing Instability (2D) Gray-Scott Assignment"
  },
  {
    "objectID": "modules/pde-2d/index.html#what-do-we-need",
    "href": "modules/pde-2d/index.html#what-do-we-need",
    "title": "Partial Differential Equations in 2D",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nWe use NumPy arrays to store 2D fields and np.roll() to compute discrete Laplacians.\n\n\nmatplotlib.pyplot\nInitialize figures, axes, and static plot elements.\n\n\nmatplotlib.animation\nUpdate image data frame-by-frame to animate the dynamics.\n\n\nmatplotlib.backend_bases\nHandle user interaction (mouse clicks and key presses).\n\n\nscipy\nGreat for ODEs, but we will not use it for PDEs in this session."
  },
  {
    "objectID": "modules/pde-2d/turing-instability.html",
    "href": "modules/pde-2d/turing-instability.html",
    "title": "Turing Instability in 2D",
    "section": "",
    "text": "Turing instability predicts when small spatial perturbations grow into patterns. We will check the instability conditions and compute unstable spatial modes on a 2D rectangle.\nFigure 1: Turing space for the Gierer-Meinhardt model (a vs d).",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability (2D)"
    ]
  },
  {
    "objectID": "modules/pde-2d/turing-instability.html#conditions",
    "href": "modules/pde-2d/turing-instability.html#conditions",
    "title": "Turing Instability in 2D",
    "section": "Conditions",
    "text": "Conditions\nLet the Jacobian at the fixed point be\n\\[J=\\begin{pmatrix} f_u & f_v \\\\ g_u & g_v \\end{pmatrix}. \\tag{1}\\]\nA common set of conditions for Turing instability is:\n\\[\n\\begin{aligned}\n&f_u + g_v &lt; 0, \\\\\n&f_u g_v - f_v g_u &gt; 0, \\\\\n&g_v + d f_u &gt; 2\\sqrt{d\\,(f_u g_v - f_v g_u)}.\n\\end{aligned}\n\\tag{2}\\]",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability (2D)"
    ]
  },
  {
    "objectID": "modules/pde-2d/turing-instability.html#implement-a-turing-test",
    "href": "modules/pde-2d/turing-instability.html#implement-a-turing-test",
    "title": "Turing Instability in 2D",
    "section": "Implement a Turing test",
    "text": "Implement a Turing test\nCreate a function that returns True if all conditions are satisfied. In the reference script the Jacobian entries are hard-coded at the fixed point.\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    # TODO: compute fu, fv, gu, gv at the fixed point\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    # TODO: implement the three conditions\n    return cond1 & cond2 & cond3\n\n\n\n\n\n\nHint: Turing instability functions (click to expand)\n\n\n\n\n\ndef giere_meinhardt_jacobian(a=0.40, b=1.00):\n    fu = 2 * b / (a + 1) - b\n    fv = -((b / (a + 1)) ** 2)\n    gu = 2 * (a + 1) / b\n    gv = -1.0\n    return fu, fv, gu, gv\n\n\ndef is_turing_instability(a, b, d):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    nabla = fu * gv - fv * gu\n    cond1 = (fu + gv) &lt; 0\n    cond2 = nabla &gt; 0\n    cond3 = (gv + d * fu) &gt; (2 * np.sqrt(d) * np.sqrt(nabla))\n    return cond1 & cond2 & cond3",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability (2D)"
    ]
  },
  {
    "objectID": "modules/pde-2d/turing-instability.html#unstable-spatial-modes-2d",
    "href": "modules/pde-2d/turing-instability.html#unstable-spatial-modes-2d",
    "title": "Turing Instability in 2D",
    "section": "Unstable spatial modes (2D)",
    "text": "Unstable spatial modes (2D)\nThe unstable modes are now pairs \\((n_x, n_y)\\). The temporal eigenvalues for spatial mode \\((\\lambda_x, \\lambda_y)\\) are the eigenvalues of\n\\[A_n = J - (\\lambda_x + \\lambda_y)\\,\\mathrm{diag}(1, d). \\tag{3}\\]\nimport numpy as np\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length_x=20.0, length_y=50.0, num_modes=10):\n    # TODO: build the Jacobian and scan 2D spatial modes\n    return unstable_modes\n\n\n\n\n\n\nHint: Spatial mode scan (click to expand)\n\n\n\n\n\ndef find_unstable_spatial_modes(a=0.40, b=1.00, d=30.0, length_x=20.0, length_y=50.0, num_modes=10):\n    fu, fv, gu, gv = giere_meinhardt_jacobian(a, b)\n    jac = np.array([[fu, fv], [gu, gv]])\n    n_values = np.arange(1, num_modes)\n    max_eigs = np.zeros((num_modes, num_modes))\n\n    for x in n_values:\n        for y in n_values:\n            lambda_x = (x * np.pi / length_x) ** 2\n            lambda_y = (y * np.pi / length_y) ** 2\n            a_n = jac - (lambda_x + lambda_y) * np.diag([1, d])\n            sigma1, sigma2 = np.linalg.eigvals(a_n)\n            max_eigs[x, y] = max(sigma1.real, sigma2.real)\n\n    idx, idy = np.unravel_index(np.argsort(max_eigs, axis=None), max_eigs.shape)\n    num_positives = (max_eigs &gt; 0).sum()\n    idx, idy = idx[-1:-num_positives:-1], idy[-1:-num_positives:-1]\n    unstable_modes = [(i, j) for i, j in zip(idx, idy)]\n    return unstable_modes",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability (2D)"
    ]
  },
  {
    "objectID": "modules/pde-2d/turing-instability.html#exercises",
    "href": "modules/pde-2d/turing-instability.html#exercises",
    "title": "Turing Instability in 2D",
    "section": "Exercises",
    "text": "Exercises\n\nCheck whether these parameter values lead to Turing instability: \\(\\gamma=1\\), \\(a=0.4\\), \\(b=1\\), \\(d=30\\).\nRepeat for \\(\\gamma=1\\), \\(a=0.4\\), \\(b=1\\), \\(d=20\\).\nUse \\(L_1=20\\), \\(L_2=50\\) and report the number of unstable modes and the leading mode for each case.",
    "crumbs": [
      "Session 5: PDEs",
      "Turing Instability (2D)"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html",
    "href": "modules/pde-2d/gray-scott.html",
    "title": "Gray-Scott Model",
    "section": "",
    "text": "Gray-Scott is an autocatalytic reaction-diffusion model for two substances \\(u\\) and \\(v\\). It produces rich patterns and is ideal for interactive exploration.\nThe equations are\n\\[\n\\begin{aligned}\n\\frac{\\partial u}{\\partial t} &= d_1 \\Delta u - u v^2 + f(1-u), \\\\\n\\frac{\\partial v}{\\partial t} &= d_2 \\Delta v + u v^2 - (f+k) v,\n\\end{aligned}\n\\tag{1}\\]\nwhere \\(d_1, d_2\\) are diffusion coefficients and \\(f, k\\) control the feed and kill rates.\nFigure 1: Gray-Scott: example snapshot of \\(v(x,y)\\) for \\(d_1=0.1\\), \\(d_2=0.05\\), \\(f=0.040\\), \\(k=0.060\\).",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html#laplacian-in-2d",
    "href": "modules/pde-2d/gray-scott.html#laplacian-in-2d",
    "title": "Gray-Scott Model",
    "section": "Laplacian in 2D",
    "text": "Laplacian in 2D\nWe will reuse the 5-point stencil (and optionally the 9-point stencil). The reference script contains both.",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html#implement-the-pde",
    "href": "modules/pde-2d/gray-scott.html#implement-the-pde",
    "title": "Gray-Scott Model",
    "section": "Implement the PDE",
    "text": "Implement the PDE\nStart from a template and fill in the missing parts.\ndef laplacian(uv):\n    # TODO: implement 5-point stencil with np.roll\n    return lap\n\n\ndef gray_scott_pde(t, uv, d1=0.1, d2=0.05, f=0.040, k=0.060, stencil=5):\n    # TODO: compute laplacian (5 or 9 point)\n    # TODO: compute du_dt and dv_dt\n    return du_dt, dv_dt\n\n\n\n\n\n\nHint: Laplacian and PDE (click to expand)\n\n\n\n\n\ndef laplacian(uv):\n    lap = -4 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap += np.roll(uv, shift=1, axis=2)\n    lap += np.roll(uv, shift=-1, axis=2)\n    return lap\n\n\ndef gray_scott_pde(t, uv, d1=0.1, d2=0.05, f=0.040, k=0.060, stencil=5):\n    u, v = uv\n    lap = laplacian(uv)\n    lu, lv = lap\n    uv2 = u * v * v\n    du_dt = d1 * lu - uv2 + f * (1 - u)\n    dv_dt = d2 * lv + uv2 - (f + k) * v\n    return du_dt, dv_dt",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html#simulation-setup",
    "href": "modules/pde-2d/gray-scott.html#simulation-setup",
    "title": "Gray-Scott Model",
    "section": "Simulation setup",
    "text": "Simulation setup\nUse \\(N=250\\) with \\(dx=1\\) (so \\(L=250\\)). Start from the homogeneous steady state \\((u^*, v^*)=(1,0)\\), then perturb a region with \\((u,v)=(0.5,0.5)\\) plus 10% noise. Apply periodic boundary conditions and integrate with \\(dt=2\\).\nn = 250\ndx = 1\ndt = 2\nuv = np.ones((2, n, n), dtype=np.float32)\nuv[1] = 0\n\n# TODO: add a perturbation block and noise",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html#animation",
    "href": "modules/pde-2d/gray-scott.html#animation",
    "title": "Gray-Scott Model",
    "section": "Animation",
    "text": "Animation\nimport matplotlib.animation as animation\n\nim = ax.imshow(uv[1], cmap=\"jet\", interpolation=\"bilinear\")\n\ndef update_frame(_):\n    # TODO: advance uv with Euler steps\n    # TODO: apply periodic boundary conditions\n    im.set_array(uv[1])\n    return [im]\n\nani = animation.FuncAnimation(fig, update_frame, interval=1, blit=True)",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-2d/gray-scott.html#parameter-sets",
    "href": "modules/pde-2d/gray-scott.html#parameter-sets",
    "title": "Gray-Scott Model",
    "section": "Parameter sets",
    "text": "Parameter sets\nTry the following Gray-Scott parameter sets (with \\(d_1=0.1\\), \\(d_2=0.05\\)):\n\nType A: \\(f=0.040\\), \\(k=0.060\\)\nType B: \\(f=0.014\\), \\(k=0.047\\)\nType C: \\(f=0.062\\), \\(k=0.065\\)\nType D: \\(f=0.078\\), \\(k=0.061\\)\nType E: \\(f=0.082\\), \\(k=0.059\\)\n\nIf you want interactive drawing and sliders, continue to the next page.",
    "crumbs": [
      "Session 5: PDEs",
      "Gray-Scott"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html",
    "href": "modules/pde-1d/index.html",
    "title": "Partial Differential Equations in 1D",
    "section": "",
    "text": "In this session we move from ODEs to reaction-diffusion PDEs in one spatial dimension. We will discretize space with finite differences, advance in time with Euler’s method, and visualize pattern formation.",
    "crumbs": [
      "Session 5: PDEs"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#case-studies",
    "href": "modules/pde-1d/index.html#case-studies",
    "title": "Partial Differential Equations in 1D",
    "section": "Case Studies",
    "text": "Case Studies\nGierer-Meinhardt 1D Turing Instability Assignment",
    "crumbs": [
      "Session 5: PDEs"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#goals",
    "href": "modules/pde-1d/index.html#goals",
    "title": "Partial Differential Equations in 1D",
    "section": "Goals",
    "text": "Goals\n\nImplement the 1D Laplacian with finite differences.\nSimulate a reaction-diffusion system with explicit time stepping.\nVisualize patterns and understand when they emerge.\nConnect parameter choices to stability and pattern formation.\nBuild animations and add simple user interaction.",
    "crumbs": [
      "Session 5: PDEs"
    ]
  },
  {
    "objectID": "modules/pde-1d/index.html#what-do-we-need",
    "href": "modules/pde-1d/index.html#what-do-we-need",
    "title": "Partial Differential Equations in 1D",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nWe use NumPy arrays to represent spatial fields and np.roll() to compute the discrete Laplacian.\n\n\nmatplotlib.pyplot\nInitialize the figure and axes and plot static elements (labels, titles, limits).\n\n\nmatplotlib.animation\nUpdate line objects frame-by-frame to create animations.\n\n\nmatplotlib.backend_bases\nHandle mouse clicks to let the user interact with the simulation.\n\n\nscipy\nGreat for ODEs, but we will not use it for PDEs in this session. We need to enforce boundary conditions at every step.",
    "crumbs": [
      "Session 5: PDEs"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html",
    "href": "modules/pde-1d/gierer-meinhardt.html",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "",
    "text": "The Gierer-Meinhardt model is a classical reaction-diffusion system that can generate spatial patterns. We will build a 1D solver from scratch and visualize \\(v(x)\\).\nIn 1D it reads\n\\[\n\\begin{aligned}\n\\frac{\\partial u}{\\partial t} &= \\Delta u + \\gamma \\left(a - b u + \\frac{u^2}{v}\\right), \\\\\n\\frac{\\partial v}{\\partial t} &= d\\,\\Delta v + \\gamma \\left(u^2 - v\\right),\n\\end{aligned}\n\\tag{1}\\]\nwhere \\(u(x,t)\\) and \\(v(x,t)\\) are concentrations, \\(a,b,\\gamma\\) are reaction parameters, and \\(d\\) is the diffusion ratio for \\(v\\).\nFigure 1: Gierer-Meinhardt 1D: example profile of \\(v(x)\\) after explicit Euler integration with \\(L=40\\), \\(dx=0.5\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), \\(\\gamma=1\\).",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#laplacian-in-1d",
    "href": "modules/pde-1d/gierer-meinhardt.html#laplacian-in-1d",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Laplacian in 1D",
    "text": "Laplacian in 1D\nIn one dimension, the Laplacian is the second derivative:\n\\[\n\\Delta u = \\frac{d^2 u}{dx^2}.\n\\tag{2}\\]\nUsing a centered finite difference on a grid with spacing \\(h\\):\n\\[\n\\Delta u(x) \\approx \\frac{u(x+h) - 2u(x) + u(x-h)}{h^2} + \\mathcal{O}(h^2).\n\\tag{3}\\]\nThis is easy to implement with np.roll() to access neighbors on a grid. We will assume \\(h = dx\\) and use the second-order centered difference.",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#boundary-conditions",
    "href": "modules/pde-1d/gierer-meinhardt.html#boundary-conditions",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Boundary Conditions",
    "text": "Boundary Conditions\n\nNeumann (zero flux)\n\\[u_x(0)=0,\\quad u(0)=u(h) \\tag{4}\\]\n\n\nDirichlet (fixed values)\n\\[u(0)=\\alpha,\\quad u(L)=\\beta \\tag{5}\\]\n\n\nPeriodic\n\\[u(0)=u(L) \\tag{6}\\]",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "href": "modules/pde-1d/gierer-meinhardt.html#exercise-simulate-the-pde",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Exercise: Simulate the PDE",
    "text": "Exercise: Simulate the PDE\nWe will use \\(L=40\\), \\(dx=0.5\\), \\(dt=0.001\\), \\(a=0.40\\), \\(b=1.00\\), \\(d=20\\), and \\(\\gamma=1\\). Follow the steps below and compare your result with Figure 1.\n\nInitialize the fields\nimport numpy as np\n\nlength = 40\ndx = 0.5\nlenx = int(length / dx)\n\nuv = np.ones((2, lenx))\nuv += uv * np.random.randn(2, lenx) / 100\nWhy add noise? A perfectly uniform initial condition can hide instabilities. Small perturbations reveal pattern-forming behavior.\n\n\nDefine the PDE (template)\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    # Laplacian via finite differences (np.roll handles neighbors)\n    lap = -2 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap /= dx**2\n\n    u, v = uv\n    lu, lv = lap\n\n    # TODO: implement the reaction terms f(u, v) and g(u, v)\n    # TODO: combine diffusion + reaction to build du_dt and dv_dt\n    return du_dt, dv_dt\n\n\n\n\n\n\nHint: Gierer-Meinhardt PDE (click to expand)\n\n\n\n\n\ndef gierer_meinhardt_pde(t, uv, gamma=1, a=0.40, b=1.00, d=20, dx=1):\n    lap = -2 * uv\n    lap += np.roll(uv, shift=1, axis=1)\n    lap += np.roll(uv, shift=-1, axis=1)\n    lap /= dx**2\n\n    u, v = uv\n    lu, lv = lap\n\n    f = a - b * u + (u**2) / v\n    g = u**2 - v\n    du_dt = lu + gamma * f\n    dv_dt = d * lv + gamma * g\n    return du_dt, dv_dt\n\n\n\n\n\nTime stepping (template)\nnum_iter = 50000\ndt = 0.001\n\nfor _ in range(num_iter):\n    dudt, dvdt = gierer_meinhardt_pde(0, uv, dx=dx)\n    # TODO: update u and v with Euler's method\n\n    # TODO: enforce Neumann boundary conditions\n\n\nPlot the final profile (template)\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, length, lenx)\nfig, ax = plt.subplots()\nax.plot(x, uv[1])\nax.set_xlabel(\"x\")\nax.set_ylabel(\"v(x)\")\nax.set_title(\"Gierer-Meinhardt 1D\")\nplt.show()\n\n\nExplore\nRe-run with \\(d=30\\) and compare the pattern. Try other \\((a, d)\\) pairs and share your observations.",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/pde-1d/gierer-meinhardt.html#animation-extension",
    "href": "modules/pde-1d/gierer-meinhardt.html#animation-extension",
    "title": "Gierer-Meinhardt Model (1D)",
    "section": "Animation Extension",
    "text": "Animation Extension\nInstead of plotting only the final state, update the line at every frame:\nimport matplotlib.animation as animation\n\n(plot_v,) = ax.plot(x, uv[1])\n\ndef animate(frame):\n    nonlocal uv\n    # TODO: compute dudt, dvdt and update uv\n    # TODO: update the line data\n    return (plot_v,)\n\nani = animation.FuncAnimation(fig, animate, interval=1, blit=True)\n\n\n\n\n\n\nHint: Animation update (click to expand)\n\n\n\n\n\ndef animate(frame):\n    nonlocal uv\n    dudt, dvdt = gierer_meinhardt_pde(frame, uv, dx=dx)\n    uv[0] = uv[0] + dudt * dt\n    uv[1] = uv[1] + dvdt * dt\n    plot_v.set_data(x, uv[1])\n    return (plot_v,)\n\n\n\nIf the system stays flat for some parameters and forms waves for others, you are seeing the onset of Turing instability. Proceed to the next page to analyze it.\n\n\n\n\n\n\nTip\n\n\n\nFull reference code is available in amlab/pdes_1d.",
    "crumbs": [
      "Session 5: PDEs",
      "Gierer-Meinhardt 1D"
    ]
  },
  {
    "objectID": "modules/lorenz/index.html",
    "href": "modules/lorenz/index.html",
    "title": "Lorenz Attractor",
    "section": "",
    "text": "This session explores the Lorenz attractor and how simple ODEs can generate chaotic trajectories.",
    "crumbs": [
      "Extra: Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/lorenz/index.html#case-studies",
    "href": "modules/lorenz/index.html#case-studies",
    "title": "Lorenz Attractor",
    "section": "Case Studies",
    "text": "Case Studies\nLorenz Attractor Assignment",
    "crumbs": [
      "Extra: Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/lorenz/index.html#what-do-we-need",
    "href": "modules/lorenz/index.html#what-do-we-need",
    "title": "Lorenz Attractor",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nRepresent the state and integrate with Euler’s method.\n\n\nmatplotlib.pyplot\nPlot the 3D trajectory.",
    "crumbs": [
      "Extra: Lorenz Attractor"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/index.html",
    "href": "modules/agent-based-modeling/index.html",
    "title": "Agent-Based Modeling",
    "section": "",
    "text": "In this session we explore agent-based models: simple local rules that produce global patterns. We focus on simulation, visualization, and interpretation.",
    "crumbs": [
      "Session 9: Agent Based Modeling"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/index.html#case-studies",
    "href": "modules/agent-based-modeling/index.html#case-studies",
    "title": "Agent-Based Modeling",
    "section": "Case Studies",
    "text": "Case Studies\nAssignment",
    "crumbs": [
      "Session 9: Agent Based Modeling"
    ]
  },
  {
    "objectID": "modules/agent-based-modeling/index.html#what-do-we-need",
    "href": "modules/agent-based-modeling/index.html#what-do-we-need",
    "title": "Agent-Based Modeling",
    "section": "What do we need?",
    "text": "What do we need?\n\nnumpy\nEfficient arrays to store agent states and positions.\n\n\nmatplotlib.pyplot\nPlot agent positions and time evolution.\n\n\nmatplotlib.animation\nAnimate the system over time.",
    "crumbs": [
      "Session 9: Agent Based Modeling"
    ]
  },
  {
    "objectID": "modules/network-dynamics/index.html",
    "href": "modules/network-dynamics/index.html",
    "title": "Network Dynamics",
    "section": "",
    "text": "In this session we implement a simple SIS model on a network. Nodes switch between Susceptible (S) and Infected (I).",
    "crumbs": [
      "Session 7: Network Dynamics"
    ]
  },
  {
    "objectID": "modules/network-dynamics/index.html#case-studies",
    "href": "modules/network-dynamics/index.html#case-studies",
    "title": "Network Dynamics",
    "section": "Case Studies",
    "text": "Case Studies\nSIS Model Assignment",
    "crumbs": [
      "Session 7: Network Dynamics"
    ]
  },
  {
    "objectID": "modules/network-dynamics/index.html#what-do-we-need",
    "href": "modules/network-dynamics/index.html#what-do-we-need",
    "title": "Network Dynamics",
    "section": "What do we need?",
    "text": "What do we need?\n\nnetworkx\nCreate graphs and store node states.\n\n\nmatplotlib.pyplot\nDraw graphs and plot time series of S and I.",
    "crumbs": [
      "Session 7: Network Dynamics"
    ]
  },
  {
    "objectID": "modules/network-dynamics/index.html#references",
    "href": "modules/network-dynamics/index.html#references",
    "title": "Network Dynamics",
    "section": "References",
    "text": "References\n\nSession code: amlab/networks_complex\nCurated references: references",
    "crumbs": [
      "Session 7: Network Dynamics"
    ]
  },
  {
    "objectID": "modules/network-dynamics/daley-kendall.html",
    "href": "modules/network-dynamics/daley-kendall.html",
    "title": "Daley-Kendall Model",
    "section": "",
    "text": "The Daley-Kendall model uses three states:\nAt each step:\nFigure 1: Daley-Kendall: example graph with states I, S, R.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Daley-Kendall Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/daley-kendall.html#load-a-real-graph",
    "href": "modules/network-dynamics/daley-kendall.html#load-a-real-graph",
    "title": "Daley-Kendall Model",
    "section": "Load a real graph",
    "text": "Load a real graph\nDownload the Facebook edge list from SNAP and load it with pandas.\nimport pandas as pd\nimport networkx as nx\n\nfacebook = pd.read_csv(\n    \"./data/facebook_combined.txt.gz\",\n    compression=\"gzip\",\n    sep=\" \",\n    names=[\"start_node\", \"end_node\"],\n)\nG = nx.from_pandas_edgelist(facebook, \"start_node\", \"end_node\")\nDownload: https://snap.stanford.edu/data/ego-Facebook.html",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Daley-Kendall Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/daley-kendall.html#implement-daley-kendall-transitions",
    "href": "modules/network-dynamics/daley-kendall.html#implement-daley-kendall-transitions",
    "title": "Daley-Kendall Model",
    "section": "Implement Daley-Kendall transitions",
    "text": "Implement Daley-Kendall transitions\nReuse the simulation framework from session 8 and replace the transition rule.\ndef state_transition(G, current_state, gamma=0.1, beta=0.2):\n    next_state = current_state.copy()\n\n    for node in G.nodes:\n        state = current_state[node]\n\n        if state == \"I\":\n            # TODO: if any neighbor is a spreader, become S with prob beta\n            pass\n        elif state == \"S\":\n            # TODO: if any neighbor is S or R, become R with prob gamma\n            pass\n\n    return next_state\n\n\n\n\n\n\nHint: Transition rule (click to expand)\n\n\n\n\n\nimport random\n\ndef state_transition(G, current_state, gamma=0.1, beta=0.2):\n    next_state = current_state.copy()\n    for node in G.nodes:\n        state = current_state[node]\n\n        if state == \"I\":\n            for neighbor in G.neighbors(node):\n                if current_state[neighbor] == \"S\" and random.random() &lt; beta:\n                    next_state[node] = \"S\"\n                    break\n        elif state == \"S\":\n            for neighbor in G.neighbors(node):\n                if current_state[neighbor] in (\"S\", \"R\") and random.random() &lt; gamma:\n                    next_state[node] = \"R\"\n                    break\n\n    return next_state",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Daley-Kendall Model"
    ]
  },
  {
    "objectID": "modules/network-dynamics/daley-kendall.html#extra-challenges",
    "href": "modules/network-dynamics/daley-kendall.html#extra-challenges",
    "title": "Daley-Kendall Model",
    "section": "Extra challenges",
    "text": "Extra challenges\n\nAdd key press controls (SPACE to pause, ENTER to reset).\nAdd sliders for \\(\\beta\\) and \\(\\gamma\\).\nImplement network attacks by forcing high-centrality nodes to stifle.\n\nReference code: amlab/networkx_data/simulation.py.",
    "crumbs": [
      "Session 7: Network Dynamics",
      "Daley-Kendall Model"
    ]
  },
  {
    "objectID": "modules/networks/index.html",
    "href": "modules/networks/index.html",
    "title": "Networks",
    "section": "",
    "text": "In this session we introduce two real-world datasets and practice basic NetworkX workflows.",
    "crumbs": [
      "Session 6: Networks"
    ]
  },
  {
    "objectID": "modules/networks/index.html#case-studies",
    "href": "modules/networks/index.html#case-studies",
    "title": "Networks",
    "section": "Case Studies",
    "text": "Case Studies\nUSA Flights Enron Email Assignment",
    "crumbs": [
      "Session 6: Networks"
    ]
  },
  {
    "objectID": "modules/networks/index.html#what-do-we-need",
    "href": "modules/networks/index.html#what-do-we-need",
    "title": "Networks",
    "section": "What do we need?",
    "text": "What do we need?\n\nnetworkx\nWe will build graphs, compute metrics, and visualize structure.\n\n\npandas\nUseful for loading edge lists from CSV or text files.\n\n\nmatplotlib.pyplot\nDraw graphs and basic plots like degree distributions.",
    "crumbs": [
      "Session 6: Networks"
    ]
  },
  {
    "objectID": "modules/networks/index.html#references",
    "href": "modules/networks/index.html#references",
    "title": "Networks",
    "section": "References",
    "text": "References\n\nSession notebooks: amlab/networks\nCurated references: references",
    "crumbs": [
      "Session 6: Networks"
    ]
  },
  {
    "objectID": "modules/networks/usa-flights.html",
    "href": "modules/networks/usa-flights.html",
    "title": "USA Flights",
    "section": "",
    "text": "The OpenFlights USA dataset represents airports as nodes and flight routes as edges. It is commonly used to study connectivity, robustness, and hub structure.\nFigure 1: USA flights: subgraph snapshot (random sample of airports).",
    "crumbs": [
      "Session 6: Networks",
      "USA Flights"
    ]
  },
  {
    "objectID": "modules/networks/usa-flights.html#load-the-graph",
    "href": "modules/networks/usa-flights.html#load-the-graph",
    "title": "USA Flights",
    "section": "Load the graph",
    "text": "Load the graph\nThe dataset is provided as GraphML and edge lists under data/openflights.\nimport networkx as nx\n\nG = nx.read_graphml(\"data/openflights/openflights_usa.graphml.gz\")",
    "crumbs": [
      "Session 6: Networks",
      "USA Flights"
    ]
  },
  {
    "objectID": "modules/networks/usa-flights.html#basic-checks",
    "href": "modules/networks/usa-flights.html#basic-checks",
    "title": "USA Flights",
    "section": "Basic checks",
    "text": "Basic checks\nTry these metrics:\nnum_nodes = G.number_of_nodes()\nnum_edges = G.number_of_edges()\navg_degree = sum(dict(G.degree()).values()) / num_nodes\n\nprint(num_nodes, num_edges, avg_degree)",
    "crumbs": [
      "Session 6: Networks",
      "USA Flights"
    ]
  },
  {
    "objectID": "modules/networks/usa-flights.html#explore-hubs",
    "href": "modules/networks/usa-flights.html#explore-hubs",
    "title": "USA Flights",
    "section": "Explore hubs",
    "text": "Explore hubs\nCompute the top airports by degree centrality.\nimport networkx as nx\n\ncentrality = nx.degree_centrality(G)\n# TODO: sort and print top 10 airports\n\n\n\n\n\n\nHint: Top 10 by degree (click to expand)\n\n\n\n\n\ncentrality = nx.degree_centrality(G)\ntop10 = sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:10]\nprint(top10)",
    "crumbs": [
      "Session 6: Networks",
      "USA Flights"
    ]
  },
  {
    "objectID": "modules/networks/usa-flights.html#questions-to-explore",
    "href": "modules/networks/usa-flights.html#questions-to-explore",
    "title": "USA Flights",
    "section": "Questions to explore",
    "text": "Questions to explore\n\nWhich airports act as hubs?\nHow does the network change if you remove the top hub?\nIs the graph connected, or are there isolated components?",
    "crumbs": [
      "Session 6: Networks",
      "USA Flights"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html",
    "href": "modules/ode-1d/index.html",
    "title": "Ordinary Differential Equations in 1D",
    "section": "",
    "text": "Numerical integration is fundamental for solving ordinary differential equations (ODEs) that don’t have analytical solutions. In this first session, you will learn how to:",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#contents",
    "href": "modules/ode-1d/index.html#contents",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Contents",
    "text": "Contents\n\nSIR Epidemic Model\nMichaelis–Menten Enzyme Kinetics\nSpruce Budworm Population Model\nAssignment",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#the-initial-value-problem",
    "href": "modules/ode-1d/index.html#the-initial-value-problem",
    "title": "Ordinary Differential Equations in 1D",
    "section": "The Initial Value Problem",
    "text": "The Initial Value Problem\nAn initial value problem (IVP) consists of:\n\\[\\frac{dy}{dt} = f(t, y), \\quad y(t_0) = y_0 \\tag{1}\\]\nWhere: - \\(f(t, y)\\) is the rate of change function - \\(y_0\\) is the initial condition at time \\(t_0\\)",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#scipys-solve_ivp",
    "href": "modules/ode-1d/index.html#scipys-solve_ivp",
    "title": "Ordinary Differential Equations in 1D",
    "section": "SciPy’s solve_ivp",
    "text": "SciPy’s solve_ivp\nThe scipy.integrate.solve_ivp function is the standard tool for solving ODEs in Python. Try the following code:\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef exponential_decay(t, y):\n     return -0.5 * y\n\nt_span = [0, 10]\ny0 = [2, 4, 8]\nsol = solve_ivp(\n    fun=exponential_decay,\n    t_span=t_span, \n    y0=y0)\n\nprint(sol.t)\n\nprint(sol.y)\nHow does solve_ivp work? Let’s understand its parameters (copied from the documentation):\n\nfun: Right-hand side of the system: the time derivative of the state \\(y\\) at time \\(t\\). The calling signature is fun(t, y), where t is a scalar and y is an ndarray with len(y) = len(y0). Additional arguments need to be passed if args is used (see documentation of args argument). fun must return an array of the same shape as y. In our example, exponential_decay defines the ODE \\(\\frac{dy}{dt} = -0.5y\\), which models exponential decay \\(y(t) = y_0 e^{-0.5t}\\).\nt_span: Interval of integration \\((t_0, t_f)\\). The solver starts with \\(t=t_0\\) and integrates until it reaches \\(t=t_f\\). Both \\(t_0\\) and \\(t_f\\) must be floats or values interpretable by the float conversion function.\ny0: Initial state. For problems in the complex domain, pass y0 with a complex data type (even if the initial value is purely real).\n\nYou can also specify additional parameters: - method: Integration method to use. Common choices include 'RK45' (default), 'RK23', 'DOP853', 'Radau', 'BDF', and 'LSODA'. - t_eval: Times at which to store the computed solution, must be sorted and lie within t_span. If None (default), use points selected by the solver. - args: Additional arguments to pass to the user-defined functions. If, for example, fun has the signature fun(t, y, a, b, c), then args=(a, b, c).",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#systems-of-odes",
    "href": "modules/ode-1d/index.html#systems-of-odes",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Systems of ODEs",
    "text": "Systems of ODEs\nFor multiple coupled equations, return a list or array of derivatives:\ndef sir_model(t, y, beta, gamma):\n    S, I, R = y\n    N = S + I + R\n    \n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    \n    return [dSdt, dIdt, dRdt]",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#best-practices",
    "href": "modules/ode-1d/index.html#best-practices",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways check convergence: Plot solutions at different tolerances\nUse appropriate methods: 'RK45' (default) works well for most problems\nVectorize when possible: Makes code faster and cleaner\nDocument parameters: Keep track of units and meanings\nValidate against known solutions: Test your implementation",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#next-steps",
    "href": "modules/ode-1d/index.html#next-steps",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Next Steps",
    "text": "Next Steps\nApply these techniques to the classical models in Session 1: - SIR epidemiological model - Spruce budworm population dynamics - Michaelis–Menten enzyme kinetics",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/index.html#resources",
    "href": "modules/ode-1d/index.html#resources",
    "title": "Ordinary Differential Equations in 1D",
    "section": "Resources",
    "text": "Resources\n\nSciPy solve_ivp documentation\nPython for ODEs tutorial",
    "crumbs": [
      "Session 1: ODEs in 1D"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html",
    "href": "modules/ode-1d/michaelis-menten.html",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "",
    "text": "Michaelis–Menten kinetics is a foundational model in biochemical reaction dynamics. It relates substrate concentration to reaction rate using a saturating nonlinearity.\nThe (simplified) substrate dynamics implemented in the reference script is:\n\\[\n\\dot s = \\frac{V_{\\max}s}{K_m + s}\n\\tag{1}\\]\nwhere \\(V_{\\max}\\) is the maximum rate and \\(K_m\\) is the Michaelis constant.",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-reference",
    "href": "modules/ode-1d/michaelis-menten.html#sec-reference",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Reference Implementation",
    "text": "Reference Implementation\nSee:\n\namlab/odes_1d/michaelis_menten.py\n\nThe helper plot_michaelis_menten(...) produces:\n\n\\(s(t)\\) over time\n\\(v(s)\\) with guides at \\(s=K_m\\) and \\(v=V_{\\max}/2\\)",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-render-figure",
    "href": "modules/ode-1d/michaelis-menten.html#sec-render-figure",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Render-time Figure",
    "text": "Render-time Figure\n\n\n\n\n\n\n\n\nFigure 1: Michaelis–Menten: time series \\(s(t)\\) and rate curve \\(v(s)\\).",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-exploration",
    "href": "modules/ode-1d/michaelis-menten.html#sec-exploration",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Exploration",
    "text": "Exploration\n\nIncrease \\(V_{\\max}\\) and observe how the rate curve changes.\nIncrease \\(K_m\\) (lower affinity). How does the saturation point shift?",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  },
  {
    "objectID": "modules/ode-1d/michaelis-menten.html#sec-run-locally",
    "href": "modules/ode-1d/michaelis-menten.html#sec-run-locally",
    "title": "Michaelis–Menten Enzyme Kinetics",
    "section": "Run Locally",
    "text": "Run Locally\npython amlab/odes_1d/michaelis_menten.py",
    "crumbs": [
      "Session 1: ODEs in 1D",
      "Michaelis–Menten Kinetics"
    ]
  }
]